<html>
<head>
  <title>Java线程详解 - you Richer - 博客园</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="7806"/>
<h1>Java线程详解 - you Richer - 博客园</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2015/9/21 0:02</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://www.cnblogs.com/riskyer/p/3263032.html"><i>http://www.cnblogs.com/riskyer/p/3263032.html</i></a></td></tr>
</table>
</div>
<br/>

<div><span><br/><div style="font-size: 16px"><div><div style="font-family:YoonGothic, AppleGothic, sans-serif;font-size:12px;line-height:1.5;text-align:center;background-color:rgb(119, 119, 119);"><div style="text-align:left;"><div style="background:url(http://www.cnblogs.com/skins/jeolee/images/notemiddle.gif) repeat-y;"><div style="font-size:12px;font-family:YoonGothic, AppleGothic;color:rgb(68, 68, 68);text-align:left;line-height:18px;background-color:rgb(255, 255, 255);"><div><div style="font-size:13px;"><div style="word-break:break-word;"><h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997763" target="_blank"></a><a name="_Toc258997460" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：概念与原理</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">一、操作系统中线程和进程的概念</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/> </span><span style="color:black;">现在的操作系统是多任务操作系统。多线程是实现多任务的一种方式。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/> </span><span style="color:black;">进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在</span><span style="color:black;">Windows</span><span style="color:black;">系统中，一个运行的</span><span style="color:black;">exe</span><span style="color:black;">就是一个进程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如</span><span style="color:black;">java.exe</span><span style="color:black;">进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">“</span><span style="color:black;">同时</span><span style="color:black;">”</span><span style="color:black;">执行是人的感觉，在线程之间实际上轮换执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">二、</span><span style="color:black;">Java</span><span style="color:black;">中的线程</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/> </span><span style="color:black;">在</span><span style="color:black;">Java</span><span style="color:black;">中，</span><span style="color:black;">“</span><span style="color:black;">线程</span><span style="color:black;">”</span><span style="color:black;">指两件不同的事情：</span><span style="color:black;"><br/> 1</span><span style="color:black;">、</span><span style="color:black;">java.lang.Thread</span><span style="color:black;">类的一个实例；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、线程的执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">使用</span><span style="color:black;">java.lang.Thread</span><span style="color:black;">类或者</span><span style="color:black;">java.lang.Runnable</span><span style="color:black;">接口编写代码来定义、实例化和启动新线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一个</span><span style="color:black;">Thread</span><span style="color:black;">类实例只是一个对象，像</span><span style="color:black;">Java</span><span style="color:black;">中的任何其他对象一样，具有变量和方法，生死于堆上。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java</span><span style="color:black;">中，每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一个</span><span style="color:black;">Java</span><span style="color:black;">应用总是从</span><span style="color:black;">main()</span><span style="color:black;">方法开始运行，</span><span style="color:black;">mian()</span><span style="color:black;">方法运行在一个线程内，它被称为主线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一旦创建一个新的线程，就产生一个新的调用栈。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程总体分两类：用户线程和守候线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/> </span><span style="color:black;">当所有用户线程执行完毕的时候，</span><span style="color:black;">JVM</span><span style="color:black;">自动关闭。但是守候线程却不独立于</span><span style="color:black;">JVM</span><span style="color:black;">，守候线程一般是由操作系统或者用户自己创建的</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="Java线程：创建与启动" target="_blank"></a><a name="_Toc258997764" target="_blank"></a><a name="_Toc258997461" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：创建与启动</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">一、定义线程</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、扩展</span><span style="color:black;">java.lang.Thread</span><span style="color:black;">类。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">此类中有个</span><span style="color:black;">run()</span><span style="color:black;">方法，应该注意其用法：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#f7f7f7;"><span style="color:black;">public void <strong> run</strong>()</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">如果该线程是使用独立的</span><span style="color:black;">Runnable</span><span style="color:black;">运行对象构造的，则调用该</span><span style="color:black;">Runnable</span><span style="color:black;">对象的</span><span style="color:black;">run</span><span style="color:black;">方法；否则，该方法不执行任何操作并返回。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Thread</span><span style="color:black;">的子类应该重写该方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、实现</span><span style="color:black;">java.lang.Runnable</span><span style="color:black;">接口。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">void <strong>run</strong>()</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">使用实现接口</span><span style="color:black;">Runnable</span><span style="color:black;">的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的</span><span style="color:black;">run</span><span style="color:black;">方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">方法</span><span style="color:black;">run</span><span style="color:black;">的常规协定是，它可能执行任何所需的操作。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">二、实例化线程</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、如果是扩展</span><span style="color:black;">java.lang.Thread</span><span style="color:black;">类的线程，则直接</span><span style="color:black;">new</span><span style="color:black;">即可。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、如果是实现了</span><span style="color:black;">java.lang.Runnable</span><span style="color:black;">接口的类，则用</span><span style="color:black;">Thread</span><span style="color:black;">的构造方法：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Thread(Runnable target) <br/> Thread(Runnable target, String name) <br/> Thread(ThreadGroup group, Runnable target) <br/> Thread(ThreadGroup group, Runnable target, String name) <br/> Thread(ThreadGroup group, Runnable target, String name, long stackSize) </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">三、启动线程</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在线程的</span><span style="color:black;">Thread</span><span style="color:black;">对象上调用</span><span style="color:black;">start()</span><span style="color:black;">方法，而不是</span><span style="color:black;">run()</span><span style="color:black;">或者别的方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在调用</span><span style="color:black;">start()</span><span style="color:black;">方法之前：线程处于新状态中，新状态指有一个</span><span style="color:black;">Thread</span><span style="color:black;">对象，但还没有一个真正的线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在调用</span><span style="color:black;">start()</span><span style="color:black;">方法之后：发生了一系列复杂的事情</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">启动新的执行线程（具有新的调用栈）；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">该线程从新状态转移到可运行状态；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当该线程获得机会执行时，其目标</span><span style="color:black;">run()</span><span style="color:black;">方法将运行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">注意：对</span><span style="color:black;">Java</span><span style="color:black;">来说，</span><span style="color:black;">run()</span><span style="color:black;">方法没有任何特别之处。像</span><span style="color:black;">main()</span><span style="color:black;">方法一样，它只是新线程知道调用的方法名称</span><span style="color:black;">(</span><span style="color:black;">和签名</span><span style="color:black;">)</span><span style="color:black;">。因此，在</span><span style="color:black;">Runnable</span><span style="color:black;">上或者</span><span style="color:black;">Thread</span><span style="color:black;">上调用</span><span style="color:black;">run</span><span style="color:black;">方法是合法的。但并不启动新的线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">四、例子</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、实现</span><span style="color:black;">Runnable</span><span style="color:black;">接口的多线程例子</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">实现</span><span style="color:green;">Runnable</span><span style="color:green;">接口的类</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2008-9-13 18:12:10 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> DoSomething</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>     </span><span style="color:blue;">private</span><span style="color:black;"> String name;<br/> <br/>     </span><span style="color:blue;">public</span><span style="color:black;"> DoSomething(String name) {<br/>         </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>         </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 5; i++) {<br/>             </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">long</span><span style="color:black;"> k = 0; k &lt; 100000000; k++) ;<br/>             System.out.println(name + </span><span style="color:maroon;">&quot;: &quot;</span><span style="color:black;"> + i);<br/>         } <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">测试</span><span style="color:green;">Runnable</span><span style="color:green;">类实现的多线程程序</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2008-9-13 18:15:02 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> TestRunnable {<br/>     </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>         DoSomething ds1 = </span><span style="color:blue;">new</span><span style="color:black;"> DoSomething(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">阿三</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>         DoSomething ds2 = </span><span style="color:blue;">new</span><span style="color:black;"> DoSomething(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/> <br/>         Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(ds1);<br/>         Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(ds2);<br/> <br/>         t1.start(); <br/>         t2.start(); <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">执行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">李四</span><span style="color:black;">: 0<br/> </span><span style="color:black;">阿三</span><span style="color:black;">: 0 <br/> </span><span style="color:black;">李四</span><span style="color:black;">: 1 <br/> </span><span style="color:black;">阿三</span><span style="color:black;">: 1 <br/> </span><span style="color:black;">李四</span><span style="color:black;">: 2 <br/> </span><span style="color:black;">李四</span><span style="color:black;">: 3 <br/> </span><span style="color:black;">阿三</span><span style="color:black;">: 2 <br/> </span><span style="color:black;">李四</span><span style="color:black;">: 4 <br/> </span><span style="color:black;">阿三</span><span style="color:black;">: 3 <br/> </span><span style="color:black;">阿三</span><span style="color:black;">: 4 <br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、扩展</span><span style="color:black;">Thread</span><span style="color:black;">类实现的多线程例子</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">测试扩展</span><span style="color:green;">Thread</span><span style="color:green;">类实现的多线程程序</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2008-9-13 18:22:13 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> TestThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread{ <br/>     </span><span style="color:blue;">public</span><span style="color:black;"> TestThread(String name) {<br/>         </span><span style="color:blue;">super</span><span style="color:black;">(name);<br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>         </span><span style="color:blue;">for</span><span style="color:black;">(</span><span style="color:blue;">int</span><span style="color:black;"> i = 0;i&lt;5;i++){<br/>             </span><span style="color:blue;">for</span><span style="color:black;">(</span><span style="color:blue;">long</span><span style="color:black;"> k= 0; k &lt;100000000;k++);<br/>             System.out.println(</span><span style="color:blue;">this</span><span style="color:black;">.getName()+</span><span style="color:maroon;">&quot; :&quot;</span><span style="color:black;">+i);<br/>         } <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>         Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> TestThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">阿三</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>         Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> TestThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>         t1.start(); <br/>         t2.start(); <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">执行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">阿三</span><span style="color:black;"> :0<br/> </span><span style="color:black;">李四</span><span style="color:black;"> :0 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :1 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :1 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :2 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :2 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :3 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :4 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :3 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :4 <br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于上面的多线程程序代码来说，输出的结果是不确定的。其中的一条语句</span><span style="color:black;">for(long k= 0; k &lt;100000000;k++);</span><span style="color:black;">是用来模拟一个非常耗时的操作的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">五、一些常见问题</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是你自己的定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是</span><span style="color:black;">mian</span><span style="color:black;">，非主线程的名字不确定。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、线程都可以设置名字，也可以获取线程的名字，连主线程也不例外。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、获取当前线程的对象的方法是：</span><span style="color:black;">Thread.currentThread()</span><span style="color:black;">；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、在上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按该顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">5</span><span style="color:black;">、当线程目标</span><span style="color:black;">run()</span><span style="color:black;">方法结束时该线程完成。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">6</span><span style="color:black;">、一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">7</span><span style="color:black;">、线程的调度是</span><span style="color:black;">JVM</span><span style="color:black;">的一部分，在一个</span><span style="color:black;">CPU</span><span style="color:black;">的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。</span><span style="color:black;">JVM</span><span style="color:black;">线程调度程序决定实际运行哪个处于可运行状态的线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">众多可运行线程中的某一个会被选中做为当前线程。可运行线程被选择运行的顺序是没有保障的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">8</span><span style="color:black;">、尽管通常采用队列形式，但这是没有保障的。队列形式是指当一个线程完成</span><span style="color:black;">“</span><span style="color:black;">一轮</span><span style="color:black;">”</span><span style="color:black;">时，它移到可运行队列的尾部等待，直到它最终排队到该队列的前端为止，它才能被再次选中。事实上，我们把它称为可运行池而不是一个可运行队列，目的是帮助认识线程并不都是以某种有保障的顺序排列唱呢个一个队列的事实。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">9</span><span style="color:black;">、尽管我们没有无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997765" target="_blank"></a><a name="_Toc258997462" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：线程栈模型与线程的变量</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">要理解线程调度的原理，以及线程执行过程，必须理解线程栈模型。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容是随着程序的运行动态变化的，因此研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方</span><span style="color:black;">)</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面通过一个示例性的代码说明线程（调用）栈的变化过程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这幅图描述在代码执行到两个不同时刻</span><span style="color:black;">1</span><span style="color:black;">、</span><span style="color:black;">2</span><span style="color:black;">时候，虚拟机线程调用栈示意图。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当程序执行到</span><span style="color:black;">t.start();</span><span style="color:black;">时候，程序多出一个分支（增加了一个调用栈</span><span style="color:black;">B</span><span style="color:black;">），这样，栈</span><span style="color:black;">A</span><span style="color:black;">、栈</span><span style="color:black;">B</span><span style="color:black;">并行执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从这里就可以看出方法调用和线程启动的区别了。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997766" target="_blank"></a><a name="_Toc258997463" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程状态的转换</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一、线程状态</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的状态转换是线程控制的基础。线程状态总的可分为五大状态：分别是生、死、可运行、运行、等待</span><span style="color:black;">/</span><span style="color:black;">阻塞。用一个图来描述如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、新状态：线程对象已经创建，还没有在其上调用</span><span style="color:black;">start()</span><span style="color:black;">方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、可运行状态：当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当</span><span style="color:black;">start()</span><span style="color:black;">方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、运行状态：线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、等待</span><span style="color:black;">/</span><span style="color:black;">阻塞</span><span style="color:black;">/</span><span style="color:black;">睡眠状态：这是线程有资格运行时它所处的状态。实际上这个三状态组合为一种，其共同点是：线程仍旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是如果某件事件出现，他可能返回到可运行状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">5</span><span style="color:black;">、死亡态：当线程的</span><span style="color:black;">run()</span><span style="color:black;">方法完成时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。</span><span style="color:black;">如果在一个死去的线程上调用</span><span style="color:black;">start()</span><span style="color:black;">方法，会抛出</span><span style="color:black;">java.lang.IllegalThreadStateException</span><span style="color:black;">异常。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">有关详细状态转换图可以参看本人的</span><span style="color:black;">“<a href="http://lavasoft.blog.51cto.com/62575/27069" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">Java</span><span style="color:black;">多线程编程总结</span></a></span>”<span style="color:black;">中的图</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">二、阻止线程执行</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于线程的阻止，考虑一下三个方面，不考虑</span><span style="color:black;">IO</span><span style="color:black;">阻塞的情况：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">睡眠；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">等待；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">因为需要一个对象的锁定而被阻塞。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、睡眠</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Thread.sleep(long millis)</span><span style="color:black;">和</span><span style="color:black;">Thread.sleep(long millis, int nanos)</span><span style="color:black;">静态方法强制当前正在执行的线程休眠（暂停执行），以</span><span style="color:black;">“</span><span style="color:black;">减慢线程</span><span style="color:black;">”</span><span style="color:black;">。当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程睡眠的原因：线程执行太快，或者需要强制进入下一轮，因为</span><span style="color:black;">Java</span><span style="color:black;">规范不保证合理的轮换。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">睡眠的实现：调用静态方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">        try {<br/>             Thread.sleep(123);<br/>         } catch (InterruptedException e) {<br/>             e.printStackTrace();  <br/>         }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">睡眠的位置：为了让其他线程有机会执行，可以将</span><span style="color:black;">Thread.sleep()</span><span style="color:black;">的调用放线程</span><span style="color:black;">run()</span><span style="color:black;">之内。这样才能保证该线程执行过程中会睡眠。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">例如，在前面的例子中，将一个耗时的操作改为睡眠，以减慢线程的执行。可以这么写：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">    public void run() {<br/>         for(int i = 0;i&lt;5;i++){</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">// </span><span style="color:black;">很耗时的操作，用来减慢线程的执行</span><span style="color:black;"><br/> //            for(long k= 0; k &lt;100000000;k++);<br/> </span><strong><span style="color:black;">            try {</span><span style="color:black;"><br/> </span><span style="color:black;">                </span><span style="color:blue;">Thread.sleep(3);</span><span style="color:blue;"><br/> </span><span style="color:black;">            } catch (InterruptedException e) {</span><span style="color:black;"><br/> </span><span style="color:black;">                e.printStackTrace();  .</span><span style="color:black;"><br/> </span><span style="color:black;">            }</span></strong><span style="color:black;"><br/>             System.out.println(this.getName()+&quot; :&quot;+i);<br/>         }<br/>     }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">运行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">阿三</span><span style="color:black;"> :0<br/> </span><span style="color:black;">李四</span><span style="color:black;"> :0 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :1 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :2 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :3 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :1 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :2 <br/> </span><span style="color:black;">阿三</span><span style="color:black;"> :4 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :3 <br/> </span><span style="color:black;">李四</span><span style="color:black;"> :4 <br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这样，线程在每次执行过程中，总会睡眠</span><span style="color:black;">3</span><span style="color:black;">毫秒，睡眠了，其他的线程就有机会执行了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">注意：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、线程睡眠是帮助所有线程获得运行机会的最好方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、线程睡眠到期自动苏醒，并返回到可运行状态，不是运行状态。</span><span style="color:black;">sleep()</span><span style="color:black;">中指定的时间是线程不会运行的最短时间。因此，</span><span style="color:black;">sleep()</span><span style="color:black;">方法不能保证该线程睡眠到期后就开始执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、</span><span style="color:black;">sleep()</span><span style="color:black;">是静态方法，只能控制当前正在运行的线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面给个例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">一个计数器，计数到</span><span style="color:green;">100</span><span style="color:green;">，在每个数字之间暂停</span><span style="color:green;">1</span><span style="color:green;">秒，每隔</span><span style="color:green;">10</span><span style="color:green;">个数字输出一个字符串</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2008-9-14 9:53:49 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> MyThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>         </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 100; i++) {<br/>             </span><span style="color:blue;">if</span><span style="color:black;"> ((i) % 10 == 0) {<br/>                 System.out.println(</span><span style="color:maroon;">&quot;-------&quot;</span><span style="color:black;"> + i);<br/>             } <br/>             System.out.print(i); <br/>             </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                 Thread.sleep(1); <br/>                 System.out.print(</span><span style="color:maroon;">&quot;    </span><span style="color:maroon;">线程睡眠</span><span style="color:maroon;">1</span><span style="color:maroon;">毫秒！</span><span style="color:maroon;">\n&quot;</span><span style="color:black;">);<br/>             } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                 e.printStackTrace(); <br/>             } <br/>         } <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>         </span><span style="color:blue;">new</span><span style="color:black;"> MyThread().start();<br/>     } <br/> } </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">-------0 <br/> 0    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 1    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 2    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 3    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 4    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 5    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 6    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 7    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 8    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 9    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------10 <br/> 10    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 11    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 12    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 13    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 14    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 15    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 16    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 17    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 18    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 19    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------20 <br/> 20    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 21    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 22    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 23    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 24    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 25    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 26    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 27    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 28    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 29    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------30 <br/> 30    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 31    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 32    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 33    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 34    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 35    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 36    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 37    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 38    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 39    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------40 <br/> 40    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 41    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 42    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 43    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 44    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 45    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 46    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 47    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 48    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 49    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------50 <br/> 50    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 51    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 52    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 53    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 54    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 55    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 56    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 57    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 58    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 59    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------60 <br/> 60    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 61    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 62    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 63    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 64    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 65    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 66    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 67    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 68    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 69    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------70 <br/> 70    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 71    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 72    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 73    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 74    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 75    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 76    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 77    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 78    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 79    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------80 <br/> 80    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 81    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 82    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 83    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 84    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 85    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 86    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 87    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 88    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 89    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> -------90 <br/> 90    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 91    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 92    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 93    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 94    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 95    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 96    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 97    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 98    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> 99    </span><span style="color:black;">线程睡眠</span><span style="color:black;">1</span><span style="color:black;">毫秒！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0 </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/> 2</span><span style="color:black;">、线程的优先级和线程让步</span><span style="color:black;">yield()</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的让步是通过</span><span style="color:black;">Thread.</span><strong><span style="color:black;">yield</span></strong><span style="color:black;">()</span><span style="color:black;">来实现的。</span><span style="color:black;">yield()</span><span style="color:black;">方法的作用是：暂停当前正在执行的线程对象，并执行其他线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">要理解</span><span style="color:black;">yield()</span><span style="color:black;">，必须了解线程的优先级的概念。线程总是存在优先级，优先级范围在</span><span style="color:black;">1~10</span><span style="color:black;">之间。</span><span style="color:black;">JVM</span><span style="color:black;">线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">注意：当设计多线程应用程序的时候，一定不要依赖于线程的优先级。因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当线程池中线程都具有相同的优先级，调度程序的</span><span style="color:black;">JVM</span><span style="color:black;">实现自由选择它喜欢的线程。这时候调度程序的操作有两种可能：一是选择一个线程运行，直到它阻塞或者运行完成为止。二是时间分片，为池内的每个线程提供均等的运行机会。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">设置线程的优先级：线程默认的优先级是创建它的执行线程的优先级。可以通过</span><span style="color:black;">setPriority(int newPriority)</span><span style="color:black;">更改线程的优先级。例如：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">        Thread t = new MyThread();<br/>         t.setPriority(8);<br/>         t.start();</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程优先级为</span><span style="color:black;">1~10</span><span style="color:black;">之间的正整数，</span><span style="color:black;">JVM</span><span style="color:black;">从不会改变一个线程的优先级。然而，</span><span style="color:black;">1~10</span><span style="color:black;">之间的值是没有保证的。一些</span><span style="color:black;">JVM</span><span style="color:black;">可能不能识别</span><span style="color:black;">10</span><span style="color:black;">个不同的值，而将这些优先级进行每两个或多个合并，变成少于</span><span style="color:black;">10</span><span style="color:black;">个的优先级，则两个或多个优先级的线程可能被映射为一个优先级。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程默认优先级是</span><span style="color:black;">5</span><span style="color:black;">，</span><span style="color:black;">Thread</span><span style="color:black;">类中有三个常量，定义线程优先级范围：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">static int MAX_PRIORITY <br/>           </span><span style="color:black;">线程可以具有的最高优先级。</span><span style="color:black;"><br/> static int MIN_PRIORITY <br/>           </span><span style="color:black;">线程可以具有的最低优先级。</span><span style="color:black;"><br/> static int NORM_PRIORITY <br/>           </span><span style="color:black;">分配给线程的默认优先级。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、</span><span style="color:black;">Thread.yield()</span><span style="color:black;">方法</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Thread.yield()</span><span style="color:black;">方法作用是：暂停当前正在执行的线程对象，并执行其他线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">yield()</span><span style="color:black;">应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用</span><span style="color:black;">yield()</span><span style="color:black;">的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证</span><span style="color:black;">yield()</span><span style="color:black;">达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">结论：</span><span style="color:black;">yield()</span><span style="color:black;">从未导致线程转到等待</span><span style="color:black;">/</span><span style="color:black;">睡眠</span><span style="color:black;">/</span><span style="color:black;">阻塞状态。在大多数情况下，</span><span style="color:black;">yield()</span><span style="color:black;">将导致线程从运行状态转到可运行状态，但有可能没有效果。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、</span><span style="color:black;">join()</span><span style="color:black;">方法</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Thread</span><span style="color:black;">的非静态方法</span><span style="color:black;">join()</span><span style="color:black;">让一个线程</span><span style="color:black;">B“</span><span style="color:black;">加入</span><span style="color:black;">”</span><span style="color:black;">到另外一个线程</span><span style="color:black;">A</span><span style="color:black;">的尾部。在</span><span style="color:black;">A</span><span style="color:black;">执行完毕之前，</span><span style="color:black;">B</span><span style="color:black;">不能工作。例如：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">        Thread t = new MyThread();<br/>         t.start();<br/>         t.join();</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">另外，</span><span style="color:black;">join()</span><span style="color:black;">方法还有带超时限制的重载版本。</span><span style="color:black;">例如</span><span style="color:black;">t.join(5000);</span><span style="color:black;">则让线程等待</span><span style="color:black;">5000</span><span style="color:black;">毫秒，如果超过这个时间，则停止等待，变为可运行状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的加入</span><span style="color:black;">join()</span><span style="color:black;">对线程栈导致的结果是线程栈发生了变化，当然这些变化都是瞬时的。下面给示意图：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">小结</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">到目前位置，介绍了线程离开运行状态的</span><span style="color:black;">3</span><span style="color:black;">种方法：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、调用</span><span style="color:black;">Thread.sleep()</span><span style="color:black;">：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、调用</span><span style="color:black;">Thread.yield()</span><span style="color:black;">：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、调用</span><span style="color:black;">join()</span><span style="color:black;">方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">除了以上三种方式外，还有下面几种特殊情况可能使线程离开运行状态：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、线程的</span><span style="color:black;">run()</span><span style="color:black;">方法完成。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、在对象上调用</span><span style="color:black;">wait()</span><span style="color:black;">方法（不是在线程上调用）。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997767" target="_blank"></a><a name="_Toc258997464" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的同步与锁</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">一、同步问题提出</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">例如：两个线程</span><span style="color:black;">ThreadA</span><span style="color:black;">、</span><span style="color:black;">ThreadB</span><span style="color:black;">都操作同一个对象</span><span style="color:black;">Foo</span><span style="color:black;">对象，并修改</span><span style="color:black;">Foo</span><span style="color:black;">对象上的数据。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Foo {<br/>     </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x = 100;<br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> getX() {<br/>         </span><span style="color:blue;">return</span><span style="color:black;"> x;<br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> fix(</span><span style="color:blue;">int</span><span style="color:black;"> y) {<br/>         x = x - y; <br/>         </span><span style="color:blue;">return</span><span style="color:black;"> x;<br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> MyRunnable</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>     </span><span style="color:blue;">private</span><span style="color:black;"> Foo foo =</span><span style="color:blue;">new</span><span style="color:black;"> Foo(); <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>         MyRunnable r = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable();<br/>         Thread ta = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(r,</span><span style="color:maroon;">&quot;Thread-A&quot;</span><span style="color:black;">); <br/>         Thread tb = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(r,</span><span style="color:maroon;">&quot;Thread-B&quot;</span><span style="color:black;">); <br/>         ta.start(); <br/>         tb.start(); <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>         </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 3; i++) {<br/>             </span><span style="color:blue;">this</span><span style="color:black;">.fix(30);<br/>             </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                 Thread.sleep(1); <br/>             } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                 e.printStackTrace(); <br/>             } <br/>             System.out.println(Thread.currentThread().getName() + </span><span style="color:maroon;">&quot; :</span><span style="color:maroon;">当前</span><span style="color:maroon;">foo</span><span style="color:maroon;">对象的</span><span style="color:maroon;">x</span><span style="color:maroon;">值</span><span style="color:maroon;">= &quot;</span><span style="color:black;"> + foo.getX());<br/>         } <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> fix(</span><span style="color:blue;">int</span><span style="color:black;"> y) {<br/>         </span><span style="color:blue;">return</span><span style="color:black;"> foo.fix(y);<br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">运行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">Thread-A : </span> <span style="color:black;">当前</span><span style="color:black;">foo</span><span style="color:black;">对象的</span><span style="color:black;">x</span><span style="color:black;">值</span><span style="color:black;">= 40<br/> Thread-B : </span><span style="color:black;">当前</span><span style="color:black;">foo</span><span style="color:black;">对象的</span><span style="color:black;">x</span><span style="color:black;">值</span><span style="color:black;">= 40<br/> Thread-B : </span><span style="color:black;">当前</span><span style="color:black;">foo</span><span style="color:black;">对象的</span><span style="color:black;">x</span><span style="color:black;">值</span><span style="color:black;">= -20<br/> Thread-A : </span><span style="color:black;">当前</span><span style="color:black;">foo</span><span style="color:black;">对象的</span><span style="color:black;">x</span><span style="color:black;">值</span><span style="color:black;">= -50<br/> Thread-A : </span><span style="color:black;">当前</span><span style="color:black;">foo</span><span style="color:black;">对象的</span><span style="color:black;">x</span><span style="color:black;">值</span><span style="color:black;">= -80<br/> Thread-B : </span><span style="color:black;">当前</span><span style="color:black;">foo</span><span style="color:black;">对象的</span><span style="color:black;">x</span><span style="color:black;">值</span><span style="color:black;">= -80<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从结果发现，这样的输出值明显是不合理的。原因是两个线程不加控制的访问</span><span style="color:black;">Foo</span><span style="color:black;">对象并修改其数据所致。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">如果要保持结果的合理性，只需要达到一个目的，就是将对</span><span style="color:black;">Foo</span><span style="color:black;">的访问加以限制，每次只能有一个线程在访问。这样就能保证</span><span style="color:black;">Foo</span><span style="color:black;">对象中数据的合理性了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在具体的</span><span style="color:black;">Java</span><span style="color:black;">代码中需要完成一下两个操作：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">把竞争访问的资源类</span><span style="color:black;">Foo</span><span style="color:black;">变量</span><span style="color:black;">x</span><span style="color:black;">标识为</span><span style="color:black;">private</span><span style="color:black;">；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">同步哪些修改变量的代码，使用</span><span style="color:black;">synchronized</span><span style="color:black;">关键字同步方法或代码。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">二、同步和锁定</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、锁的原理</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java</span><span style="color:black;">中每个对象都有一个内置锁</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当程序运行到非静态的</span><span style="color:black;">synchronized</span><span style="color:black;">同步方法上时，自动获得与正在执行代码类的当前实例（</span><span style="color:black;">this</span><span style="color:black;">实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当程序运行到</span><span style="color:black;">synchronized</span><span style="color:black;">同步方法或代码块时才该对象锁才起作用。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的</span><span style="color:black;">synchronized</span><span style="color:black;">方法或代码块，直到该锁被释放。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">释放锁是指持锁线程退出了</span><span style="color:black;">synchronized</span><span style="color:black;">同步方法或代码块。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">关于锁和同步，有一下几个要点：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">）、只能同步方法，而不能同步变量和类；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">）、如果两个线程要执行一个类中的</span><span style="color:black;">synchronized</span><span style="color:black;">方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">5</span><span style="color:black;">）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">6</span><span style="color:black;">）、线程睡眠时，它所持的任何锁都不会释放。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">7</span><span style="color:black;">）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">8</span><span style="color:black;">）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">9</span><span style="color:black;">）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">    public int fix(int y) {<br/>         synchronized (this) {<br/>             x = x - y;<br/>         }<br/>         return x;<br/>     }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">    public synchronized int getX() {<br/>         return x++;<br/>     }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">与</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">    public int getX() {<br/>         synchronized (this) {<br/>             return x;<br/>         }<br/>     }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">效果是完全一样的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">三、静态方法同步</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（</span><span style="color:black;">XXX.class)</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">例如：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">public static synchronized int setName(String name){</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">      Xxx.name = name;</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">}</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">等价于</span><span style="color:black;"><br/> public static int setName(String name){<br/>       synchronized(Xxx.class){<br/>             Xxx.name = name;<br/>       }<br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/>  </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">四、如果线程不能不能获得锁会怎么样</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可运行或运行为止。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当考虑阻塞时，一定要注意哪个对象正被用于锁定：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的</span><span style="color:black;">Class</span><span style="color:black;">对象上。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在</span><span style="color:black;">Class</span><span style="color:black;">对象上，非静态方法锁定在该类的对象上。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、对于同步代码块，要看清楚什么对象已经用于锁定（</span><span style="color:black;">synchronized</span><span style="color:black;">后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">五、何时需要同步</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于非静态字段中可更改的数据，通常使用非静态方法访问。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于静态字段中可更改的数据，通常使用静态方法访问。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">如果需要在非静态方法中使用静态字段，或者在静态字段中调用非静态方法，问题将变得非常复杂。已经超出</span><span style="color:black;">SJCP</span><span style="color:black;">考试范围了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">六、线程安全类</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当一个类已经很好的同步以保护它的数据时，这个类就称为</span><span style="color:black;">“</span><span style="color:black;">线程安全的</span><span style="color:black;">”</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">即使是线程安全类，也应该特别小心，因为操作的线程是间仍然不一定安全。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">举个形象的例子，比如一个集合是线程安全的，有两个线程在操作同一个集合对象，当第一个线程查询集合非空后，删除集合中所有元素的时候。第二个线程也来执行与第一个线程相同的操作，也许在第一个线程查询后，第二个线程也查询出集合非空，但是当第一个执行清除后，第二个再执行删除显然是不对的，因为此时集合已经为空了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">看个代码：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> NameList {<br/>     </span><span style="color:blue;">private</span><span style="color:black;"> List nameList = Collections.synchronizedList(</span><span style="color:blue;">new</span><span style="color:black;"> LinkedList());<br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> add(String name) {<br/>         nameList.add(name); <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:black;"> String removeFirst() {<br/>         </span><span style="color:blue;">if</span><span style="color:black;"> (nameList.size() &gt; 0) {<br/>             </span><span style="color:blue;">return</span><span style="color:black;"> (String) nameList.remove(0);<br/>         } </span><span style="color:blue;">else</span><span style="color:black;"> {<br/>             </span><span style="color:blue;">return</span><span style="color:blue;">null</span><span style="color:black;">;<br/>         } <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>     </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>         </span><span style="color:blue;">final</span><span style="color:black;"> NameList nl =</span><span style="color:blue;">new</span><span style="color:black;"> NameList(); <br/>         nl.add(</span><span style="color:maroon;">&quot;aaa&quot;</span><span style="color:black;">);<br/>         </span><span style="color:blue;">class</span><span style="color:black;"> NameDropper</span><span style="color:blue;">extends</span><span style="color:black;"> Thread{ <br/>             </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run(){<br/>                 String name = nl.removeFirst(); <br/>                 System.out.println(name); <br/>             } <br/>         } <br/> <br/>         Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> NameDropper();<br/>         Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> NameDropper();<br/>         t1.start(); <br/>         t2.start(); <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">虽然集合对象</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">    private List nameList = Collections.synchronizedList(new LinkedList());<br/> </span><span style="color:black;">是同步的，但是程序还不是线程安全的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">出现这种事件的原因是，上例中一个线程操作列表过程中无法阻止另外一个线程对列表的其他操作。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">解决上面问题的办法是，在操作集合对象的</span><span style="color:black;">NameList</span><span style="color:black;">上面做一个同步。改写后的代码如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> NameList {<br/>     </span><span style="color:blue;">private</span><span style="color:black;"> List nameList = Collections.synchronizedList(</span><span style="color:blue;">new</span><span style="color:black;"> LinkedList());<br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> add(String name) {<br/>         nameList.add(name); <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:black;"> String removeFirst() {<br/>         </span><span style="color:blue;">if</span><span style="color:black;"> (nameList.size() &gt; 0) {<br/>             </span><span style="color:blue;">return</span><span style="color:black;"> (String) nameList.remove(0);<br/>         } </span><span style="color:blue;">else</span><span style="color:black;"> {<br/>             </span><span style="color:blue;">return</span><span style="color:blue;">null</span><span style="color:black;">;<br/>         } <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这样，当一个线程访问其中一个同步方法时，其他线程只有等待。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">七、线程死锁</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">死锁对</span><span style="color:black;">Java</span><span style="color:black;">程序来说，是很复杂的，也很难发现问题。当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">还是看一个比较直观的死锁例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> DeadlockRisk {<br/>     </span><span style="color:blue;">private</span><span style="color:blue;">static</span><span style="color:blue;">class</span><span style="color:black;"> Resource {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> value;<br/>     } <br/> <br/>     </span><span style="color:blue;">private</span><span style="color:black;"> Resource resourceA =</span><span style="color:blue;">new</span><span style="color:black;"> Resource(); <br/>     </span><span style="color:blue;">private</span><span style="color:black;"> Resource resourceB =</span><span style="color:blue;">new</span><span style="color:black;"> Resource(); <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> read() {<br/>         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceA) {<br/>             </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceB) {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> resourceB.value + resourceA.value;<br/>             } <br/>         } <br/>     } <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> write(</span><span style="color:blue;">int</span><span style="color:black;"> a,</span><span style="color:blue;">int</span><span style="color:black;"> b) { <br/>         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceB) {<br/>             </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceA) {<br/>                 resourceA.value = a; <br/>                 resourceB.value = b; <br/>             } <br/>         } <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">假设</span><span style="color:black;">read()</span><span style="color:black;">方法由一个线程启动，</span><span style="color:black;">write()</span><span style="color:black;">方法由另外一个线程启动。读线程将拥有</span><span style="color:black;">resourceA</span><span style="color:black;">锁，写线程将拥有</span><span style="color:black;">resourceB</span><span style="color:black;">锁，两者都坚持等待的话就出现死锁。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">实际上，上面这个例子发生死锁的概率很小。因为在代码内的某个点，</span><span style="color:black;">CPU</span><span style="color:black;">必须从读线程切换到写线程，所以，死锁基本上不能发生。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">但是，无论代码中发生死锁的概率有多小，一旦发生死锁，程序就死掉。有一些设计方法能帮助避免死锁，包括始终按照预定义的顺序获取锁这一策略。已经超出</span><span style="color:black;">SCJP</span><span style="color:black;">的考试范围。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">八、线程同步小结</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、对于静态同步方法，锁是针对这个类的，锁对象是该类的</span><span style="color:black;">Class</span><span style="color:black;">对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、对于同步，要时刻清醒在哪个对象上同步，这是关键。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">5</span><span style="color:black;">、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对</span><span style="color:black;">“</span><span style="color:black;">原子</span><span style="color:black;">”</span><span style="color:black;">操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">6</span><span style="color:black;">、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">7</span><span style="color:black;">、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997768" target="_blank"></a><a name="_Toc258997465" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的交互</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程交互是比较复杂的问题，</span><span style="color:black;">SCJP</span><span style="color:black;">要求不很基础：给定一个场景，编写代码来恰当使用等待、通知和通知所有线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一、线程交互的基础知识</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">SCJP</span><span style="color:black;">所要求的线程交互知识点需要从</span><strong><span style="color:black;">java.lang.Object</span></strong><span style="color:black;">的类的三个方法来学习：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> void notify() <br/>           </span><span style="color:black;">唤醒在此对象监视器上等待的单个线程。</span><span style="color:black;"><br/>  void notifyAll() <br/>           </span><span style="color:black;">唤醒在此对象监视器上等待的所有线程。</span><span style="color:black;"><br/>  void wait() <br/>           </span><span style="color:black;">导致当前的线程等待，直到其他线程调用此对象的</span><span style="color:black;"> notify()</span><span style="color:black;">方法或</span><span style="color:black;"> notifyAll()</span><span style="color:black;">方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当然，</span><span style="color:black;">wait()</span><span style="color:black;">还有另外两个重载方法：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> void wait(long timeout) <br/>           </span><span style="color:black;">导致当前的线程等待，直到其他线程调用此对象的</span><span style="color:black;"> notify()</span><span style="color:black;">方法或</span><span style="color:black;"> notifyAll()</span><span style="color:black;">方法，或者超过指定的时间量。</span><span style="color:black;"> <br/>  void wait(long timeout, int nanos) <br/>           </span><span style="color:black;">导致当前的线程等待，直到其他线程调用此对象的</span><span style="color:black;"> notify()</span><span style="color:black;">方法或</span><span style="color:black;"> notifyAll()</span><span style="color:black;">方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">以上这些方法是帮助线程传递线程关心的时间状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">关于等待</span><span style="color:black;">/</span><span style="color:black;">通知，要记住的关键点是：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">必须从同步环境内调用</span><span style="color:black;">wait()</span><span style="color:black;">、</span><span style="color:black;">notify()</span><span style="color:black;">、</span><span style="color:black;">notifyAll()</span><span style="color:black;">方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">wait()</span><span style="color:black;">、</span><span style="color:black;">notify()</span><span style="color:black;">、</span><span style="color:black;">notifyAll()</span><span style="color:black;">都是</span><span style="color:black;">Object</span><span style="color:black;">的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的</span><span style="color:black;">wait()</span><span style="color:black;">方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的</span><span style="color:black;">notify()</span><span style="color:black;">方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面看个例子就明白了：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">计算输出其他线程锁计算的数据</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2008-9-15 13:20:38 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> ThreadA {<br/>     </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>         ThreadB b = </span><span style="color:blue;">new</span><span style="color:black;"> ThreadB();<br/>         </span><span style="color:green;">//</span><span style="color:green;">启动计算线程</span><span style="color:black;"><br/>         b.start(); <br/>         </span><span style="color:green;">//</span><span style="color:green;">线程</span><span style="color:green;">A</span><span style="color:green;">拥有</span><span style="color:green;">b</span><span style="color:green;">对象上的锁。线程为了调用</span><span style="color:green;">wait()</span><span style="color:green;">或</span><span style="color:green;">notify()</span><span style="color:green;">方法，该线程必须是那个对象锁的拥有者</span><span style="color:black;"><br/>         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (b) {<br/>             </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                 System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">等待对象</span><span style="color:maroon;">b</span><span style="color:maroon;">完成计算。。。</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">当前线程</span><span style="color:green;">A</span><span style="color:green;">等待</span><span style="color:black;"><br/>                 b.wait(); <br/>             } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                 e.printStackTrace(); <br/>             } <br/>             System.out.println(</span><span style="color:maroon;">&quot;b</span><span style="color:maroon;">对象计算的总和是：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + b.total);<br/>         } <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">计算</span><span style="color:green;">1+2+3 ... +100</span><span style="color:green;">的和</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2008-9-15 13:20:49 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> ThreadB</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>     </span><span style="color:blue;">int</span><span style="color:black;"> total; <br/> <br/>     </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (</span><span style="color:blue;">this</span><span style="color:black;">) {<br/>             </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 101; i++) {<br/>                 total += i; <br/>             } <br/>             </span><span style="color:green;">//</span><span style="color:green;">（完成计算了）唤醒在此对象监视器上等待的单个线程，在本例中线程</span><span style="color:green;">A</span><span style="color:green;">被唤醒</span><span style="color:black;"><br/>             notify(); <br/>         } <br/>     } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">等待对象</span><span style="color:black;">b</span><span style="color:black;">完成计算。。。</span><span style="color:black;"><br/> b</span><span style="color:black;">对象计算的总和是：</span><span style="color:black;">5050 <br/> <br/> Process finished with exit code 0 </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">千万注意：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当在对象上调用</span><span style="color:black;">wait()</span><span style="color:black;">方法时，执行该代码的线程立即放弃它在对象上的锁。然而调用</span><span style="color:black;">notify()</span><span style="color:black;">时，并不意味着这时线程会放弃其锁。如果线程荣然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用</span><span style="color:black;">notify()</span><span style="color:black;">并不意味着这时该锁变得可用。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">二、多个线程在等待一个对象锁时候使用</span><span style="color:black;">notifyAll()</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在多数情况下，最好通知等待某个对象的所有线程。如果这样做，可以在对象上使用</span><span style="color:black;">notifyAll()</span><span style="color:black;">让所有在此对象上等待的线程冲出等待区，返回到可运行状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面给个例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">计算线程</span><span style="color:green;"> <br/> * <br/> * @author leizhimin 2008-9-20 11:15:46 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Calculator</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">int</span><span style="color:black;"> total;<br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">synchronized</span><span style="color:black;"> (</span><span style="color:blue;">this</span><span style="color:black;">) {<br/>                         </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 101; i++) {<br/>                                 total += i; <br/>                         } <br/>                 } <br/>                 </span><span style="color:green;">//</span><span style="color:green;">通知所有在此对象上等待的线程</span><span style="color:black;"><br/>                 notifyAll(); <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * </span><span style="color:green;">获取计算结果并输出</span><span style="color:green;"> <br/> * <br/> * @author leizhimin 2008-9-20 11:15:22 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> ReaderResult</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         Calculator c; <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> ReaderResult(Calculator c) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.c = c;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">synchronized</span><span style="color:black;"> (c) {<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 System.out.println(Thread.currentThread() + </span> <span style="color:maroon;">&quot;</span><span style="color:maroon;">等待计算结果。。。</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                                 c.wait(); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                         System.out.println(Thread.currentThread() + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">计算结果为：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + c.total);<br/>                 } <br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Calculator calculator = </span><span style="color:blue;">new</span><span style="color:black;"> Calculator();<br/> <br/>                 </span><span style="color:green;">//</span><span style="color:green;">启动三个线程，分别获取计算结果</span><span style="color:black;"><br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> ReaderResult(calculator).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> ReaderResult(calculator).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> ReaderResult(calculator).start();<br/>                 </span><span style="color:green;">//</span><span style="color:green;">启动计算线程</span><span style="color:black;"><br/>                 calculator.start(); <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">运行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">Thread[Thread-1,5,main]</span><span style="color:black;">等待计算结果。。。</span><span style="color:black;"><br/> Thread[Thread-2,5,main]</span><span style="color:black;">等待计算结果。。。</span><span style="color:black;"><br/> Thread[Thread-3,5,main]</span><span style="color:black;">等待计算结果。。。</span><span style="color:black;"><br/> Exception in thread </span><span style="color:maroon;">&quot;Thread-0&quot;</span><span style="color:black;"> java.lang.IllegalMonitorStateException: current thread not owner<br/>   at java.lang.Object.notifyAll(Native Method) <br/>   at threadtest.Calculator.run(Calculator.java:18) <br/> Thread[Thread-1,5,main]</span><span style="color:black;">计算结果为：</span><span style="color:black;">5050<br/> Thread[Thread-2,5,main]</span><span style="color:black;">计算结果为：</span><span style="color:black;">5050<br/> Thread[Thread-3,5,main]</span><span style="color:black;">计算结果为：</span><span style="color:black;">5050<br/> <br/> Process finished with exit code 0 </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">运行结果表明，程序中有异常，并且多次运行结果可能有多种输出结果。这就是说明，这个多线程的交互程序还存在问题。究竟是出了什么问题，需要深入的分析和思考，下面将做具体分析。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">实际上，上面这个代码中，我们期望的是读取结果的线程在计算线程调用</span><span style="color:black;">notifyAll()</span><span style="color:black;">之前等待即可。</span><span style="color:black;">但是，如果计算线程先执行，并在读取结果线程等待之前调用了</span><span style="color:black;">notify()</span><span style="color:black;">方法，那么又会发生什么呢？这种情况是可能发生的。因为无法保证线程的不同部分将按照什么顺序来执行。幸运的是当读取线程运行时，它只能马上进入等待状态</span><span style="color:black;">----</span><span style="color:black;">它没有做任何事情来检查等待的事件是否已经发生。</span><span style="color:black;">  ----</span><span style="color:black;">因此，如果计算线程已经调用了</span><span style="color:black;">notifyAll()</span><span style="color:black;">方法，那么它就不会再次调用</span><span style="color:black;">notifyAll()</span><span style="color:black;">，</span><span style="color:black;">----</span><span style="color:black;">并且等待的读取线程将永远保持等待。这当然是开发者所不愿意看到的问题。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">因此，当等待的事件发生时，需要能够检查</span><span style="color:black;">notifyAll()</span><span style="color:black;">通知事件是否已经发生。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">通常，解决上面问题的最佳方式是将</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997769" target="_blank"></a><a name="_Toc258997466" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的调度<span style="font-family:Times New Roman;">-</span>休眠</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java</span><span style="color:black;">线程调度是</span><span style="color:black;">Java</span><span style="color:black;">多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这里要明确的一点，不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程休眠的目的是使线程让出</span><span style="color:black;">CPU</span><span style="color:black;">的最简单的做法之一，线程休眠时候，会将</span><span style="color:black;">CPU</span><span style="color:black;">资源交给其他线程，以便能轮换执行，当休眠一定时间后，线程会苏醒，进入准备状态等待执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程休眠的方法是</span><span style="color:black;">Thread.sleep(long millis)</span><span style="color:black;">和</span><span style="color:black;">Thread.sleep(long millis, int nanos)</span><span style="color:black;">，均为静态方法，那调用</span><span style="color:black;">sleep</span><span style="color:black;">休眠的哪个线程呢？简单说，哪个线程调用</span><span style="color:black;">sleep</span><span style="color:black;">，就休眠哪个线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的调度</span><span style="color:green;">-</span><span style="color:green;">休眠</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 9:02:40 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread1();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(</span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable());<br/>                 t1.start(); <br/>                 t2.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread1 </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 3; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">1</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 Thread.sleep(50); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyRunnable</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 3; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">2</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 Thread.sleep(50); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从上面的结果输出可以看出，无法精准保证线程执行次序。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997770" target="_blank"></a><a name="_Toc258997467" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的调度<span style="font-family:Times New Roman;">-</span>优先级</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取</span><span style="color:black;">CPU</span><span style="color:black;">资源的概率较大，优先级低的并非没机会执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的优先级用</span><span style="color:black;">1-10</span><span style="color:black;">之间的整数表示，数值越大优先级越高，默认的优先级为</span><span style="color:black;">5</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的调度</span><span style="color:green;">-</span><span style="color:green;">优先级</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 9:02:40 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread1();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(</span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable());<br/>                 t1.setPriority(10); <br/>                 t2.setPriority(1); <br/> <br/>                 t2.start(); <br/>                 t1.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread1 </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 10; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">1</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 Thread.sleep(100); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyRunnable</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 10; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">2</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 Thread.sleep(100); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">8</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">8</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">9</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">9</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997771" target="_blank"></a><a name="_Toc258997468" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的调度<span style="font-family:Times New Roman;">-</span>让步</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的让步含义就是使当前运行着线程让出</span><span style="color:black;">CPU</span><span style="color:black;">资源，但是然给谁不知道，仅仅是让出，线程状态回到可运行状态。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的让步使用</span><span style="color:black;">Thread.yield()</span><span style="color:black;">方法，</span><span style="color:black;">yield()</span><span style="color:black;">为静态方法，功能是暂停当前正在执行的线程对象，并执行其他线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的调度</span><span style="color:green;">-</span><span style="color:green;">让步</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 9:02:40 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread1();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(</span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable());<br/> <br/>                 t2.start(); <br/>                 t1.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread1 </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 10; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">1</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 } <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyRunnable</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 10; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">2</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         Thread.yield(); <br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">8</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">9</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">8</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">2</span><span style="color:black;">第</span><span style="color:black;">9</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997772" target="_blank"></a><a name="_Toc258997469" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的调度<span style="font-family:Times New Roman;">-</span>合并</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用</span><span style="color:black;">join</span><span style="color:black;">方法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">join</span><span style="color:black;">为非静态方法，定义如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">void</span><span style="color:black;"> join()    <br/>     </span><span style="color:black;">等待该线程终止。</span><span style="color:black;">    <br/> </span><span style="color:blue;">void</span><span style="color:black;"> join(</span><span style="color:blue;">long</span><span style="color:black;"> millis)    <br/>     </span><span style="color:black;">等待该线程终止的时间最长为</span><span style="color:black;"> millis</span><span style="color:black;">毫秒。</span><span style="color:black;">    <br/> </span><span style="color:blue;">void</span><span style="color:black;"> join(</span><span style="color:blue;">long</span><span style="color:black;"> millis,</span><span style="color:blue;">int</span><span style="color:black;"> nanos)    <br/>     </span><span style="color:black;">等待该线程终止的时间最长为</span><span style="color:black;"> millis</span><span style="color:black;">毫秒</span><span style="color:black;"> + nanos </span><span style="color:black;">纳秒。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的调度</span><span style="color:green;">-</span><span style="color:green;">合并</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 9:02:40 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread1();<br/>                 t1.start(); <br/> <br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 20; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">主线程第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">if</span><span style="color:black;"> (i &gt; 2)</span><span style="color:blue;">try</span><span style="color:black;"> { <br/>                                 </span><span style="color:green;">//t1</span><span style="color:green;">线程合并到主线程中，主线程停止执行过程，转而执行</span><span style="color:green;">t1</span><span style="color:green;">线程，直到</span><span style="color:green;">t1</span><span style="color:green;">执行完毕后继续。</span><span style="color:black;"><br/>                                 t1.join(); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread1 </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 10; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">1</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">主线程第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">8</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">9</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">8</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">9</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">10</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">11</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">12</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">13</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">14</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">15</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">16</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">17</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">18</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">主线程第</span><span style="color:black;">19</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997787" target="_blank"></a><a name="_Toc258997773" target="_blank"></a><a name="_Toc258997470" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的调度<span style="font-family:Times New Roman;">-</span>守护线程</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">守护线程与普通线程写法上基本么啥区别，调用线程对象的方法</span><span style="color:black;">setDaemon(true)</span><span style="color:black;">，则可以将其设置为守护线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">守护线程使用的情况较少，但并非无用，举例来说，</span><span style="color:black;">JVM</span><span style="color:black;">的垃圾回收、内存管理等线程都是守护线程。还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">setDaemon</span><span style="color:black;">方法的详细说明：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">public</span><span style="color:blue;">final</span><span style="color:blue;">void</span><span style="color:black;"> setDaemon(</span><span style="color:blue;">boolean</span><span style="color:black;"> on)</span><span style="color:black;">将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，</span><span style="color:black;">Java</span><span style="color:black;">虚拟机退出。</span><span style="color:black;">    <br/>   </span><span style="color:black;">该方法必须在启动线程前调用。</span><span style="color:black;">    <br/> <br/>   </span><span style="color:black;">该方法首先调用该线程的</span><span style="color:black;"> checkAccess</span><span style="color:black;">方法，且不带任何参数。这可能抛出</span><span style="color:black;"> SecurityException</span><span style="color:black;">（在当前线程中）。</span><span style="color:black;">    <br/> <br/> <br/>   </span><strong><span style="color:black;">参数</span></strong><span style="color:black;">：</span><span style="color:black;"><br/>     on - </span><span style="color:black;">如果为</span><span style="color:blue;">true</span><span style="color:black;">，则将该线程标记为守护线程。</span><span style="color:black;">    <br/>   </span><strong><span style="color:black;">抛出</span></strong><span style="color:black;">：</span><span style="color:black;">    <br/>     IllegalThreadStateException - </span><span style="color:black;">如果该线程处于活动状态。</span><span style="color:black;">    <br/>     SecurityException - </span><span style="color:black;">如果当前线程无法修改该线程。</span><span style="color:black;"><br/>   </span><strong><span style="color:black;">另请参见</span></strong><span style="color:black;">：</span><span style="color:black;"><br/>     isDaemon(), checkAccess()</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"><br/>  </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的调度</span><span style="color:green;">-</span><span style="color:green;">守护线程</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 9:02:40 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyCommon();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> Thread(</span><span style="color:blue;">new</span><span style="color:black;"> MyDaemon());<br/>                 t2.setDaemon(</span><span style="color:blue;">true</span><span style="color:black;">);        </span><span style="color:green;">//</span><span style="color:green;">设置为守护线程</span><span style="color:black;"><br/> <br/>                 t2.start(); <br/>                 t1.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCommon </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 5; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">1</span><span style="color:maroon;">第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 Thread.sleep(7); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyDaemon </span> <span style="color:blue;">implements</span><span style="color:black;"> Runnable { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">long</span><span style="color:black;"> i = 0; i &lt; 9999999L; i++) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">后台线程第</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + i +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">次执行！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 Thread.sleep(7); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">后台线程第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">0</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">1</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">2</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">3</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">线程</span><span style="color:black;">1</span><span style="color:black;">第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">4</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">5</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">6</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> </span><span style="color:black;">后台线程第</span><span style="color:black;">7</span><span style="color:black;">次执行！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从上面的执行结果可以看出：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">前台线程是保证执行完毕的，后台线程还没有执行完毕就退出了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">实际上：</span><span style="color:black;">JRE</span><span style="color:black;">判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台县城时候一定要注意这个问题。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997774" target="_blank"></a><a name="_Toc258997471" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的同步<span style="font-family:Times New Roman;">-</span>同步方法</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的同步是保证多线程安全访问竞争资源的一种手段。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程的同步是</span><span style="color:black;">Java</span><span style="color:black;">多线程编程的难点，往往开发者搞不清楚什么是竞争资源、什么时候需要考虑同步，怎么同步等等问题，当然，这些问题没有很明确的答案，但有些原则问题需要考虑，是否有竞争资源被同时改动的问题？</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在本文之前，请参阅《</span><span style="color:black;"><a href="http://lavasoft.blog.51cto.com/62575/99155" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">Java</span><span style="color:black;">线程：线程的同步与锁</span></a></span><span style="color:black;">》，本文是在此基础上所写的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于同步，在具体的</span><span style="color:black;">Java</span><span style="color:black;">代码中需要完成一下两个操作：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">把竞争访问的资源标识为</span><span style="color:black;">private</span><span style="color:black;">；</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">同步哪些修改变量的代码，使用</span><span style="color:black;">synchronized</span><span style="color:black;">关键字同步方法或代码。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><em><span style="color:black;">当然这不是唯一控制并发安全的途径。</span></em></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">synchronized</span><span style="color:black;">关键字使用说明</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">synchronized</span><span style="color:black;">只能标记非抽象的方法，不能标识成员变量。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">为了演示同步方法的使用，构建了一个信用卡账户，起初信用额为</span><span style="color:black;">100w</span><span style="color:black;">，然后模拟透支、存款等多个操作。显然银行账户</span><span style="color:black;">User</span><span style="color:black;">对象是个竞争资源，而多个并发操作的是账户方法</span><span style="color:black;">oper(int x)</span><span style="color:black;">，当然应该在此方法上加上同步，并将账户的余额设为私有变量，禁止直接访问。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的同步</span><span style="color:green;"> <br/> * <br/> * @author leizhimin 2009-11-4 11:23:32 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 User u = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 100);<br/>                 MyThread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">A&quot;</span><span style="color:black;">, u, 20);<br/>                 MyThread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">B&quot;</span><span style="color:black;">, u, -60);<br/>                 MyThread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">C&quot;</span><span style="color:black;">, u, -80);<br/>                 MyThread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">D&quot;</span><span style="color:black;">, u, -30);<br/>                 MyThread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">E&quot;</span><span style="color:black;">, u, 32);<br/>                 MyThread t6 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">F&quot;</span><span style="color:black;">, u, 21);<br/> <br/>                 t1.start(); <br/>                 t2.start(); <br/>                 t3.start(); <br/>                 t4.start(); <br/>                 t5.start(); <br/>                 t6.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> User u;<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> y = 0;<br/> <br/>         MyThread(String name, User u, </span><span style="color:blue;">int</span><span style="color:black;"> y) {<br/>                 </span><span style="color:blue;">super</span><span style="color:black;">(name);<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.u = u;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.y = y;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 u.oper(y); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> User { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String code;<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;<br/> <br/>         User(String code, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.code = code;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String getCode() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> code;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setCode(String code) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.code = code;<br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">业务方法</span><span style="color:green;"><br/>          * @param x </span><span style="color:green;">添加</span><span style="color:green;">x</span><span style="color:green;">万元</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> oper(</span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                         Thread.sleep(10L); <br/>                         </span><span style="color:blue;">this</span><span style="color:black;">.cash += x;<br/>                         System.out.println(Thread.currentThread().getName() + </span> <span style="color:maroon;">&quot;</span><span style="color:maroon;">运行结束，增加</span><span style="color:maroon;">“&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;”</span><span style="color:maroon;">，当前用户账户余额为：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                         Thread.sleep(10L); <br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                         e.printStackTrace(); <br/>                 } <br/>         } <br/> <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String toString() {<br/>                 </span><span style="color:blue;">return</span><span style="color:maroon;">&quot;User{&quot;</span><span style="color:black;"> +<br/>                                 </span><span style="color:maroon;">&quot;code='&quot;</span><span style="color:black;"> + code + '\'' +<br/>                                 </span><span style="color:maroon;">&quot;, cash=&quot;</span><span style="color:black;"> + cash +<br/>                                 '}'; <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">输出结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">线程</span><span style="color:black;">A</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“20”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">120<br/> </span><span style="color:black;">线程</span><span style="color:black;">F</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“21”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">141<br/> </span><span style="color:black;">线程</span><span style="color:black;">E</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“32”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">173<br/> </span><span style="color:black;">线程</span><span style="color:black;">C</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-80”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">93<br/> </span><span style="color:black;">线程</span><span style="color:black;">B</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-60”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">33<br/> </span><span style="color:black;">线程</span><span style="color:black;">D</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-30”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">3<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">反面教材，不同步的情况，也就是去掉</span><span style="color:black;">oper(int x)</span><span style="color:black;">方法的</span><span style="color:black;">synchronized</span><span style="color:black;">修饰符，然后运行程序，结果如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">线程</span><span style="color:black;">A</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“20”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">61<br/> </span><span style="color:black;">线程</span><span style="color:black;">D</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-30”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">63<br/> </span><span style="color:black;">线程</span><span style="color:black;">B</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-60”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">3<br/> </span><span style="color:black;">线程</span><span style="color:black;">F</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“21”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">61<br/> </span><span style="color:black;">线程</span><span style="color:black;">E</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“32”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">93<br/> </span><span style="color:black;">线程</span><span style="color:black;">C</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-80”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">61<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">很显然，上面的结果是错误的，导致错误的原因是多个线程并发访问了竞争资源</span><span style="color:black;">u</span><span style="color:black;">，并对</span><span style="color:black;">u</span><span style="color:black;">的属性做了改动。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">可见同步的重要性。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">注意：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">通过前文可知，线程退出同步方法时将释放掉方法所属对象的锁，但还应该注意的是，同步方法中还可以使用特定的方法对线程进行调度。这些方法来自于</span><span style="color:black;">java.lang.Object</span><span style="color:black;">类。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">void</span><span style="color:black;"> notify()    <br/>                     </span><span style="color:black;">唤醒在此对象监视器上等待的单个线程。</span><span style="color:black;">    <br/> </span><span style="color:blue;">void</span><span style="color:black;"> notifyAll()    <br/>                     </span><span style="color:black;">唤醒在此对象监视器上等待的所有线程。</span><span style="color:black;">    <br/> </span><span style="color:blue;">void</span><span style="color:black;"> wait()    <br/>                     </span><span style="color:black;">导致当前的线程等待，直到其他线程调用此对象的</span><span style="color:black;"> notify()</span><span style="color:black;">方法或</span><span style="color:black;"> notifyAll()</span><span style="color:black;">方法。</span><span style="color:black;">    <br/> </span><span style="color:blue;">void</span><span style="color:black;"> wait(</span><span style="color:blue;">long</span><span style="color:black;"> timeout)    <br/>                     </span><span style="color:black;">导致当前的线程等待，直到其他线程调用此对象的</span><span style="color:black;"> notify()</span><span style="color:black;">方法或</span><span style="color:black;"> notifyAll()</span><span style="color:black;">方法，或者超过指定的时间量。</span><span style="color:black;">    <br/> </span><span style="color:blue;">void</span><span style="color:black;"> wait(</span><span style="color:blue;">long</span><span style="color:black;"> timeout,</span><span style="color:blue;">int</span><span style="color:black;"> nanos)    <br/>                     </span><span style="color:black;">导致当前的线程等待，直到其他线程调用此对象的</span><span style="color:black;"> notify()</span><span style="color:black;">方法或</span><span style="color:black;"> notifyAll()</span><span style="color:black;">方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">结合以上方法，处理多线程同步与互斥问题非常重要，著名的生产者</span><span style="color:black;">-</span><span style="color:black;">消费者例子就是一个经典的例子，任何语言多线程必学的例子。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997775" target="_blank"></a><a name="_Toc258997472" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：线程的同步<span style="font-family:Times New Roman;">-</span>同步块</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于同步，除了同步方法外，还可以使用同步代码块，有时候同步代码块会带来比同步方法更好的效果。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">追其同步的根本的目的，是控制竞争资源的正确的访问，因此只要在访问竞争资源的时候保证同一时刻只能一个线程访问即可，因此</span><span style="color:black;">Java</span><span style="color:black;">引入了同步代码快的策略，以提高性能。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在上个例子的基础上，对</span><span style="color:black;">oper</span><span style="color:black;">方法做了改动，由同步方法改为同步代码块模式，程序的执行逻辑并没有问题。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程的同步</span><span style="color:green;">-</span><span style="color:green;">同步代码块</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 11:23:32 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 User u = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 100);<br/>                 MyThread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">A&quot;</span><span style="color:black;">, u, 20);<br/>                 MyThread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">B&quot;</span><span style="color:black;">, u, -60);<br/>                 MyThread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">C&quot;</span><span style="color:black;">, u, -80);<br/>                 MyThread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">D&quot;</span><span style="color:black;">, u, -30);<br/>                 MyThread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">E&quot;</span><span style="color:black;">, u, 32);<br/>                 MyThread t6 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">线程</span><span style="color:maroon;">F&quot;</span><span style="color:black;">, u, 21);<br/> <br/>                 t1.start(); <br/>                 t2.start(); <br/>                 t3.start(); <br/>                 t4.start(); <br/>                 t5.start(); <br/>                 t6.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> User u;<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> y = 0;<br/> <br/>         MyThread(String name, User u, </span><span style="color:blue;">int</span><span style="color:black;"> y) {<br/>                 </span><span style="color:blue;">super</span><span style="color:black;">(name);<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.u = u;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.y = y;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 u.oper(y); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> User { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String code;<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;<br/> <br/>         User(String code, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.code = code;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String getCode() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> code;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setCode(String code) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.code = code;<br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">业务方法</span><span style="color:green;"><br/>          * <br/>          * @param x </span><span style="color:green;">添加</span><span style="color:green;">x</span><span style="color:green;">万元</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> oper(</span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                         Thread.sleep(10L); <br/>                         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (</span><span style="color:blue;">this</span><span style="color:black;">) {<br/>                                 </span><span style="color:blue;">this</span><span style="color:black;">.cash += x;<br/>                                 System.out.println(Thread.currentThread().getName() +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">运行结束，增加</span><span style="color:maroon;">“&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;”</span><span style="color:maroon;">，当前用户账户余额为：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                         } <br/>                         Thread.sleep(10L); <br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                         e.printStackTrace(); <br/>                 } <br/>         } <br/> <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String toString() {<br/>                 </span><span style="color:blue;">return</span><span style="color:maroon;">&quot;User{&quot;</span><span style="color:black;"> +<br/>                                 </span><span style="color:maroon;">&quot;code='&quot;</span><span style="color:black;"> + code + '\'' +<br/>                                 </span><span style="color:maroon;">&quot;, cash=&quot;</span><span style="color:black;"> + cash +<br/>                                 '}'; <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">线程</span><span style="color:black;">E</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“32”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">132<br/> </span><span style="color:black;">线程</span><span style="color:black;">B</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-60”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">72<br/> </span><span style="color:black;">线程</span><span style="color:black;">D</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-30”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">42<br/> </span><span style="color:black;">线程</span><span style="color:black;">F</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“21”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">63<br/> </span><span style="color:black;">线程</span><span style="color:black;">C</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“-80”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">-17<br/> </span><span style="color:black;">线程</span><span style="color:black;">A</span><span style="color:black;">运行结束，增加</span><span style="color:black;">“20”</span><span style="color:black;">，当前用户账户余额为：</span><span style="color:black;">3<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">注意：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在使用</span><span style="color:black;">synchronized</span><span style="color:black;">关键字时候，应该尽可能避免在</span><span style="color:black;">synchronized</span><span style="color:black;">方法或</span><span style="color:black;">synchronized</span><span style="color:black;">块中使用</span><span style="color:black;">sleep</span><span style="color:black;">或者</span><span style="color:black;">yield</span><span style="color:black;">方法，因为</span><span style="color:black;">synchronized</span><span style="color:black;">程序块占有着对象锁，你休息那么其他的线程只能一边等着你醒来执行完了才能执行。不但严重影响效率，也不合逻辑。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">同样，在同步程序块内调用</span><span style="color:black;">yeild</span><span style="color:black;">方法让出</span><span style="color:black;">CPU</span><span style="color:black;">资源也没有意义，因为你占用着锁，其他互斥线程还是无法访问同步程序块。当然与同步程序块无关的线程可以获得更多的执行时间。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997776" target="_blank"></a><a name="_Toc258997473" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：并发协作<span style="font-family:Times New Roman;">-</span>生产者消费者模型</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于多线程程序来说，不管任何编程语言，生产者和消费者模型都是最经典的。就像学习每一门编程语言一样，</span><span style="color:black;">Hello World</span><span style="color:black;">！都是最经典的例子。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">实际上，准确说应该是</span><span style="color:black;">“</span><span style="color:black;">生产者</span><span style="color:black;">-</span><span style="color:black;">消费者</span><span style="color:black;">-</span><span style="color:black;">仓储</span><span style="color:black;">”</span><span style="color:black;">模型，离开了仓储，生产者消费者模型就显得没有说服力了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于此模型，应该明确一下几点：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">1</span><span style="color:black;">、生产者仅仅在仓储未满时候生产，仓满则停止生产。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">2</span><span style="color:black;">、消费者仅仅在仓储有产品时候才能消费，仓空则等待。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">3</span><span style="color:black;">、当消费者发现仓储没产品可消费时候会通知生产者生产。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">4</span><span style="color:black;">、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">此模型将要结合</span><span style="color:black;">java.lang.Object</span><span style="color:black;">的</span><span style="color:black;">wait</span><span style="color:black;">与</span><span style="color:black;">notify</span><span style="color:black;">、</span><span style="color:black;">notifyAll</span><span style="color:black;">方法来实现以上的需求。这是非常重要的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：并发协作</span><span style="color:green;">-</span><span style="color:green;">生产者消费者模型</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-4 14:54:36 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 Godown godown = </span><span style="color:blue;">new</span><span style="color:black;"> Godown(30);<br/>                 Consumer c1 = </span><span style="color:blue;">new</span><span style="color:black;"> Consumer(50, godown);<br/>                 Consumer c2 = </span><span style="color:blue;">new</span><span style="color:black;"> Consumer(20, godown);<br/>                 Consumer c3 = </span><span style="color:blue;">new</span><span style="color:black;"> Consumer(30, godown);<br/>                 Producer p1 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(10, godown);<br/>                 Producer p2 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(10, godown);<br/>                 Producer p3 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(10, godown);<br/>                 Producer p4 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(10, godown);<br/>                 Producer p5 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(10, godown);<br/>                 Producer p6 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(10, godown);<br/>                 Producer p7 = </span><span style="color:blue;">new</span><span style="color:black;"> Producer(80, godown);<br/> <br/>                 c1.start(); <br/>                 c2.start(); <br/>                 c3.start(); <br/>                 p1.start(); <br/>                 p2.start(); <br/>                 p3.start(); <br/>                 p4.start(); <br/>                 p5.start(); <br/>                 p6.start(); <br/>                 p7.start(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">仓库</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> Godown { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">final</span><span style="color:blue;">int</span><span style="color:black;"> max_size = 100;</span><span style="color:green;">//</span><span style="color:green;">最大库存量</span><span style="color:black;"><br/>         </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> curnum;    </span><span style="color:green;">//</span><span style="color:green;">当前库存量</span><span style="color:black;"><br/> <br/>         Godown() { <br/>         } <br/> <br/>         Godown(</span><span style="color:blue;">int</span><span style="color:black;"> curnum) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.curnum = curnum;<br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">生产指定数量的产品</span><span style="color:green;"><br/>          * <br/>          * @param neednum <br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> produce(</span><span style="color:blue;">int</span><span style="color:black;"> neednum) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">测试是否需要生产</span><span style="color:black;"><br/>                 </span><span style="color:blue;">while</span><span style="color:black;"> (neednum + curnum &gt; max_size) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">要生产的产品数量</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + neednum +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">超过剩余库存量</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + (max_size - curnum) +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，暂时不能执行生产任务</span><span style="color:maroon;">!&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 </span><span style="color:green;">//</span><span style="color:green;">当前的生产线程等待</span><span style="color:black;"><br/>                                 wait(); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>                 </span><span style="color:green;">//</span><span style="color:green;">满足生产条件，则进行生产，这里简单的更改当前库存量</span><span style="color:black;"><br/>                 curnum += neednum; <br/>                 System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">已经生产了</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + neednum +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">个产品，现仓储量为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + curnum);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">唤醒在此对象监视器上等待的所有线程</span><span style="color:black;"><br/>                 notifyAll(); <br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">消费指定数量的产品</span><span style="color:green;"><br/>          * <br/>          * @param neednum <br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> consume(</span><span style="color:blue;">int</span><span style="color:black;"> neednum) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">测试是否可消费</span><span style="color:black;"><br/>                 </span><span style="color:blue;">while</span><span style="color:black;"> (curnum &lt; neednum) {<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 </span><span style="color:green;">//</span><span style="color:green;">当前的生产线程等待</span><span style="color:black;"><br/>                                 wait(); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                                 e.printStackTrace(); <br/>                         } <br/>                 } <br/>                 </span><span style="color:green;">//</span><span style="color:green;">满足消费条件，则进行消费，这里简单的更改当前库存量</span><span style="color:black;"><br/>                 curnum -= neednum; <br/>                 System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">已经消费了</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + neednum +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">个产品，现仓储量为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + curnum);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">唤醒在此对象监视器上等待的所有线程</span><span style="color:black;"><br/>                 notifyAll(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">生产者</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> Producer </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> neednum;                </span><span style="color:green;">//</span><span style="color:green;">生产产品的数量</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Godown godown;            </span><span style="color:green;">//</span><span style="color:green;">仓库</span><span style="color:black;"><br/> <br/>         Producer(</span><span style="color:blue;">int</span><span style="color:black;"> neednum, Godown godown) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.neednum = neednum;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.godown = godown;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">生产指定数量的产品</span><span style="color:black;"><br/>                 godown.produce(neednum); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">消费者</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> Consumer </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> neednum;                </span><span style="color:green;">//</span><span style="color:green;">生产产品的数量</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Godown godown;            </span><span style="color:green;">//</span><span style="color:green;">仓库</span><span style="color:black;"><br/> <br/>         Consumer(</span><span style="color:blue;">int</span><span style="color:black;"> neednum, Godown godown) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.neednum = neednum;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.godown = godown;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">消费指定数量的产品</span><span style="color:black;"><br/>                 godown.consume(neednum); <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">已经生产了</span><span style="color:black;">10</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">40<br/> </span><span style="color:black;">已经生产了</span><span style="color:black;">10</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">50<br/> </span><span style="color:black;">已经消费了</span><span style="color:black;">50</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">0<br/> </span><span style="color:black;">已经生产了</span><span style="color:black;">80</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">80<br/> </span><span style="color:black;">已经消费了</span><span style="color:black;">30</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">50<br/> </span><span style="color:black;">已经生产了</span><span style="color:black;">10</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">60<br/> </span><span style="color:black;">已经消费了</span><span style="color:black;">20</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">40<br/> </span><span style="color:black;">已经生产了</span><span style="color:black;">10</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">50<br/> </span><span style="color:black;">已经生产了</span><span style="color:black;">10</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">60<br/> </span><span style="color:black;">已经生产了</span><span style="color:black;">10</span><span style="color:black;">个产品，现仓储量为</span><span style="color:black;">70<br/> <br/> Process finished with exit code 0 </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">说明：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于本例，要说明的是当发现不能满足生产或者消费条件的时候，调用对象的</span><span style="color:black;">wait</span><span style="color:black;">方法，</span><span style="color:black;">wait</span><span style="color:black;">方法的作用是释放当前线程的所获得的锁，并调用对象的</span><span style="color:black;">notifyAll()</span><span style="color:black;">方法，通知（唤醒）该对象上其他等待线程，使得其继续执行。这样，整个生产者、消费者线程得以正确的协作执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">notifyAll() </span><span style="color:black;">方法，起到的是一个通知作用，不释放锁，也不获取锁。只是告诉该对象上等待的线程</span><span style="color:black;">“</span><span style="color:black;">可以竞争执行了，都醒来去执行吧</span><span style="color:black;">”</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">本例仅仅是生产者消费者模型中最简单的一种表示，本例中，如果消费者消费的仓储量达不到满足，而又没有生产者，则程序会一直处于等待状态，这当然是不对的。实际上可以将此例进行修改，修改为，根据消费驱动生产，同时生产兼顾仓库，如果仓不满就生产，并对每次最大消费量做个限制，这样就不存在此问题了，当然这样的例子更复杂，更难以说明这样一个简单模型。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">我喜欢简单的例子。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997777" target="_blank"></a><a name="_Toc258997474" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：并发协作<span style="font-family:Times New Roman;">-</span>死锁</h1>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程发生死锁可能性很小，即使看似可能发生死锁的代码，在运行时发生死锁的可能性也是小之又小。</span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">发生死锁的原因一般是两个对象的锁相互等待造成的。</span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在《</span><span style="color:black;">Java</span><span style="color:black;">线程：线程的同步与锁》一文中，简述死锁的概念与简单例子，但是所给的例子是不完整的，这里给出一个完整的例子。</span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：并发协作</span><span style="color:green;">-</span><span style="color:green;">死锁</span><span style="color:green;"><br/> * <br/> * @author Administrator 2009-11-4 22:06:13 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 DeadlockRisk dead = </span><span style="color:blue;">new</span><span style="color:black;"> DeadlockRisk();<br/>                 MyThread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(dead, 1, 2);<br/>                 MyThread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(dead, 3, 4);<br/>                 MyThread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(dead, 5, 6);<br/>                 MyThread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(dead, 7, 8);<br/> <br/>                 t1.start(); <br/>                 t2.start(); <br/>                 t3.start(); <br/>                 t4.start(); <br/>         } <br/> <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> DeadlockRisk dead;<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> a, b;<br/> <br/> <br/>         MyThread(DeadlockRisk dead, </span><span style="color:blue;">int</span><span style="color:black;"> a,</span><span style="color:blue;">int</span><span style="color:black;"> b) { <br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.dead = dead;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.a = a;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.b = b;<br/>         } <br/> <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 dead.read(); <br/>                 dead.write(a, b); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> DeadlockRisk {<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">static</span><span style="color:blue;">class</span><span style="color:black;"> Resource {<br/>                 </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> value;<br/>         } <br/> <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Resource resourceA =</span><span style="color:blue;">new</span><span style="color:black;"> Resource(); <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Resource resourceB =</span><span style="color:blue;">new</span><span style="color:black;"> Resource(); <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> read() {<br/>                 </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceA) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;read():&quot;</span><span style="color:black;"> + Thread.currentThread().getName() +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">获取了</span><span style="color:maroon;">resourceA</span><span style="color:maroon;">的锁！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceB) {<br/>                                 System.out.println(</span><span style="color:maroon;">&quot;read():&quot;</span><span style="color:black;"> + Thread.currentThread().getName() +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">获取了</span><span style="color:maroon;">resourceB</span><span style="color:maroon;">的锁！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                                 </span><span style="color:blue;">return</span><span style="color:black;"> resourceB.value + resourceA.value;<br/>                         } <br/>                 } <br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> write(</span><span style="color:blue;">int</span><span style="color:black;"> a,</span><span style="color:blue;">int</span><span style="color:black;"> b) { <br/>                 </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceB) {<br/>                         System.out.println(</span><span style="color:maroon;">&quot;write():&quot;</span><span style="color:black;"> + Thread.currentThread().getName() +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">获取了</span><span style="color:maroon;">resourceA</span><span style="color:maroon;">的锁！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (resourceA) {<br/>                                 System.out.println(</span><span style="color:maroon;">&quot;write():&quot;</span><span style="color:black;"> + Thread.currentThread().getName() +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">获取了</span><span style="color:maroon;">resourceB</span><span style="color:maroon;">的锁！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                                 resourceA.value = a; <br/>                                 resourceB.value = b; <br/>                         } <br/>                 } <br/>         } <br/> }</span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面死锁的情况发生了，真是难得一见啊：</span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:red;">Java</span><span style="color:red;">线程：</span><span style="color:red;">volatile</span><span style="color:red;">关键字</span></strong></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java™ </span><span style="color:black;">语言包含两种内在的同步机制：同步块（或方法）和</span><span style="color:black;"> volatile</span><span style="color:black;">变量。这两种机制的提出都是为了实现代码线程的安全性。其中</span><span style="color:black;"> Volatile</span><span style="color:black;">变量的同步性较差（但有时它更简单并且开销更低），而且其使用也更容易出错。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">谈及到</span><span style="color:black;">volatile</span><span style="color:black;">关键字，不得不提的一篇文章是：《</span><span style="color:black;"><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">Java</span><span style="color:black;">理论与实践</span></a></span><span style="color:black;">:</span><span style="color:black;">正确使用</span><span style="color:black;"> Volatile </span><span style="color:black;">变量</span><span style="color:black;">》，这篇文章对</span><span style="color:black;">volatile</span><span style="color:black;">关键字的用法做了相当精辟的阐述。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">之所以要单独提出</span><span style="color:black;">volatile</span><span style="color:black;">这个不常用的关键字原因是这个关键字在高性能的多线程程序中也有很重要的用途，只是这个关键字用不好会出很多问题。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">首先考虑一个问题，为什么变量需要</span><span style="color:black;">volatile</span><span style="color:black;">来修饰呢？</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">要搞清楚这个问题，首先应该明白计算机内部都做什么了。比如做了一个</span><span style="color:black;">i++</span><span style="color:black;">操作，计算机内部做了三次处理：读取－修改－写入。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">同样，对于一个</span><span style="color:black;">long</span><span style="color:black;">型数据，做了个赋值操作，在</span><span style="color:black;">32</span><span style="color:black;">系统下需要经过两步才能完成，先修改低</span><span style="color:black;">32</span><span style="color:black;">位，然后修改高</span><span style="color:black;">32</span><span style="color:black;">位。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">假想一下，当将以上的操作放到一个多线程环境下操作时候，有可能出现的问题，是这些步骤执行了一部分，而另外一个线程就已经引用了变量值，这样就导致了读取脏数据的问题。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">通过这个设想，就不难理解</span><span style="color:black;">volatile</span><span style="color:black;">关键字了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">volatile</span><span style="color:black;">可以用在任何变量前面，但不能用于</span><span style="color:black;">final</span><span style="color:black;">变量前面，因为</span><span style="color:black;">final</span><span style="color:black;">型的变量是禁止修改的。也不存在线程安全的问题。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">更多的内容，请参看：：《</span><span style="color:black;"><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">Java</span><span style="color:black;">理论与实践</span></a></span><span style="color:black;">:</span><span style="color:black;">正确使用</span><span style="color:black;"> Volatile </span><span style="color:black;">变量</span><span style="color:black;">》一文，写得很好。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997778" target="_blank"></a><a name="_Toc258997475" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：新特征<span style="font-family:Times New Roman;">-</span>线程池</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Sun</span><span style="color:black;">在</span><span style="color:black;">Java5</span><span style="color:black;">中，对</span><span style="color:black;">Java</span><span style="color:black;">线程的类库做了大量的扩展，其中线程池就是</span><span style="color:black;">Java5</span><span style="color:black;">的新特征之一，除了线程池之外，还有很多多线程相关的内容，为多线程的编程带来了极大便利。为了编写高效稳定可靠的多线程程序，线程部分的新增内容显得尤为重要。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">有关</span><span style="color:black;">Java5</span><span style="color:black;">线程新特征的内容全部在</span><span style="color:black;">java.util.concurrent</span><span style="color:black;">下面，里面包含数目众多的接口和类，熟悉这部分</span><span style="color:black;">API</span><span style="color:black;">特征是一项艰难的学习过程。目前有关这方面的资料和书籍都少之又少，大所属介绍线程方面书籍还停留在</span><span style="color:black;">java5</span><span style="color:black;">之前的知识层面上。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">当然新特征对做多线程程序没有必须的关系，在</span><span style="color:black;">java5</span><span style="color:black;">之前通用可以写出很优秀的多线程程序。只是代价不一样而已。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在</span><span style="color:black;">Java5</span><span style="color:black;">之前，要实现一个线程池是相当有难度的，现在</span><span style="color:black;">Java5</span><span style="color:black;">为我们做好了一切，我们只需要按照提供的</span><span style="color:black;">API</span><span style="color:black;">来使用，即可享受线程池带来的极大便利。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java5</span><span style="color:black;">的线程池分好多种：固定尺寸的线程池、可变尺寸连接池、。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在使用线程池之前，必须知道如何去创建一个线程池，在</span><span style="color:black;">Java5</span><span style="color:black;">中，需要了解的是</span><span style="color:black;">java.util.concurrent.Executors</span><span style="color:black;">类的</span><span style="color:black;">API</span><span style="color:black;">，这个类提供大量创建连接池的静态方法，是必须掌握的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">一、固定大小的线程池</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程池</span><span style="color:green;">- <br/> * <br/> * @author Administrator 2009-11-4 23:30:44 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个可重用固定线程数的线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建实现了</span><span style="color:green;">Runnable</span><span style="color:green;">接口对象，</span><span style="color:green;">Thread</span><span style="color:green;">对象当然也实现了</span><span style="color:green;">Runnable</span><span style="color:green;">接口</span><span style="color:black;"><br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 </span><span style="color:green;">//</span><span style="color:green;">将线程放入池中进行执行</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread{ <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 System.out.println(Thread.currentThread().getName()+</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">正在执行。。。</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">二、单任务线程池</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在上例的基础上改一行创建</span><span style="color:black;">pool</span><span style="color:black;">对象的代码为：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">                </span><span style="color:green;">//</span><span style="color:green;">创建一个使用单个</span><span style="color:green;"> worker</span><span style="color:green;">线程的</span><span style="color:green;"> Executor</span><span style="color:green;">，以无界队列方式来运行该线程。</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newSingleThreadExecutor(); </span> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">输出结果为：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于以上两种连接池，大小都是固定的，当要加入的池的线程（或者任务）超过池最大尺寸时候，则入此线程池需要排队等待。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">一旦池中有线程完毕，则排队等待的某个线程会入池执行。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">三、可变尺寸的线程池</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">与上面的类似，只是改动下</span><span style="color:black;">pool</span><span style="color:black;">的创建方式：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">                </span><span style="color:green;">//</span><span style="color:green;">创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newCachedThreadPool(); </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">pool-1-thread-5</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-4</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-3</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">四、延迟连接池</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ScheduledExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.TimeUnit;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程池</span><span style="color:green;">- <br/> * <br/> * @author Administrator 2009-11-4 23:30:44 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><span style="color:black;"><br/>                 ScheduledExecutorService pool = Executors.newScheduledThreadPool(2);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建实现了</span><span style="color:green;">Runnable</span><span style="color:green;">接口对象，</span><span style="color:green;">Thread</span><span style="color:green;">对象当然也实现了</span><span style="color:green;">Runnable</span><span style="color:green;">接口</span><span style="color:black;"><br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 </span><span style="color:green;">//</span><span style="color:green;">将线程放入池中进行执行</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">使用延迟执行风格的方法</span><span style="color:black;"><br/>                 pool.schedule(t4, 10, TimeUnit.MILLISECONDS); <br/>                 pool.schedule(t5, 10, TimeUnit.MILLISECONDS); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 System.out.println(Thread.currentThread().getName() + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">正在执行。。。</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">五、单任务延迟连接池</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在四代码基础上，做改动</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">                </span><span style="color:green;">//</span><span style="color:green;">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。</span><span style="color:black;"><br/>                 ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor();</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> <br/> Process finished with exit code 0 </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:black;">六、自定义线程池</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ArrayBlockingQueue;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.BlockingQueue;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ThreadPoolExecutor;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.TimeUnit;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：线程池</span><span style="color:green;">-</span><span style="color:green;">自定义线程池</span><span style="color:green;"><br/> * <br/> * @author Administrator 2009-11-4 23:30:44 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建等待队列</span><span style="color:black;"><br/>                 BlockingQueue&lt;Runnable&gt; bqueue = </span><span style="color:blue;">new</span><span style="color:black;"> ArrayBlockingQueue&lt;Runnable&gt;(20);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。</span><span style="color:black;"><br/>                 ThreadPoolExecutor pool = </span><span style="color:blue;">new</span><span style="color:black;"> ThreadPoolExecutor(2,3,2,TimeUnit.MILLISECONDS,bqueue);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建实现了</span><span style="color:green;">Runnable</span><span style="color:green;">接口对象，</span><span style="color:green;">Thread</span><span style="color:green;">对象当然也实现了</span><span style="color:green;">Runnable</span><span style="color:green;">接口</span><span style="color:black;"><br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t6 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 Thread t7 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread();<br/>                 </span><span style="color:green;">//</span><span style="color:green;">将线程放入池中进行执行</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 pool.execute(t6); <br/>                 pool.execute(t7); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 System.out.println(Thread.currentThread().getName() + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">正在执行。。。</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                         Thread.sleep(100L); <br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                         e.printStackTrace(); <br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-1</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> pool-1-thread-2</span><span style="color:black;">正在执行。。。</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">创建自定义线程池的构造方法很多，本例中参数的含义如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><strong><span style="color:black;">ThreadPoolExecutor</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#f7f7f7;"><span style="color:black;">public <strong> ThreadPoolExecutor</strong>(int corePoolSize,</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#f7f7f7;"><span style="color:black;">                         </span>int maximumPoolSize,</p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#f7f7f7;"><span style="color:black;">                         </span>long keepAliveTime,</p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#f7f7f7;"><span style="color:black;">            </span>               <a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent"><span style="color:black;">TimeUnit</span></a> unit,</p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#f7f7f7;"><span style="color:black;">                         </span><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent"><span style="color:black;">BlockingQueue</span></a>&lt;<a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.lang"><span style="color:black;">Runnable</span></a>&gt; workQueue)</p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;">用给定的初始参数和默认的线程工厂及处理程序创建新的</span><span style="color:black;">ThreadPoolExecutor</span><span style="color:black;">。使用</span><span style="color:black;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent"><span style="color:black;">Executors</span></a></span><span style="color:black;">工厂方法之一比使用此通用构造方法方便得多。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><strong><span style="color:black;">参数：</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;">corePoolSize</span><span style="color:black;"> -</span><span style="color:black;">池中所保存的线程数，包括空闲线程。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;">maximumPoolSize</span><span style="color:black;"> -</span><span style="color:black;">池中允许的最大线程数。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;">keepAliveTime</span><span style="color:black;"> -</span><span style="color:black;">当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;">unit</span><span style="color:black;"> - keepAliveTime</span><span style="color:black;">参数的时间单位。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;">workQueue</span><span style="color:black;"> -</span><span style="color:black;">执行前用于保持任务的队列。此队列仅保持由</span><span style="color:black;">execute</span><span style="color:black;">方法提交的</span><span style="color:black;">Runnable</span><span style="color:black;">任务。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><strong><span style="color:black;">抛出：</span></strong></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.lang"><span style="color:black;">IllegalArgumentException</span></a></span><span style="color:black;"> -</span><span style="color:black;">如果</span><span style="color:black;"> corePoolSize</span><span style="color:black;">或</span><span style="color:black;"> keepAliveTime</span><span style="color:black;">小于零，或者</span><span style="color:black;"> maximumPoolSize</span><span style="color:black;">小于或等于零，或者</span><span style="color:black;"> corePoolSize</span><span style="color:black;">大于</span><span style="color:black;"> maximumPoolSize</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:snow;"><span style="color:black;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.lang"><span style="color:black;">NullPointerException</span></a></span><span style="color:black;"> -</span><span style="color:black;">如果</span><span style="color:black;">workQueue</span><span style="color:black;">为</span><span style="color:black;"> null</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">自定义连接池稍微麻烦些，不过通过创建的</span><span style="color:black;">ThreadPoolExecutor</span><span style="color:black;">线程池对象，可以获取到当前线程池的尺寸、正在执行任务的线程数、工作队列等等。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">有关</span><span style="color:black;">Java5</span><span style="color:black;">线程池的内容到此就没有了，更多的内容还需要研读</span><span style="color:black;">API</span><span style="color:black;">来获取。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997779" target="_blank"></a><a name="_Toc258997476" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：新特征</span><span style="color:red;">-</span><span style="color:red;">有返回值的线程</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在</span><span style="color:black;">Java5</span><span style="color:black;">之前，线程是没有返回值的，常常为了</span><span style="color:black;">“</span><span style="color:black;">有</span><span style="color:black;">”</span><span style="color:black;">返回值，破费周折，而且代码很不好写。或者干脆绕过这道坎，走别的路了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">现在</span><span style="color:black;">Java</span><span style="color:black;">终于有可返回值的任务（也可以叫做线程）了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">可返回值的任务必须实现</span><span style="color:black;">Callable</span><span style="color:black;">接口，类似的，无返回值的任务必须</span><span style="color:black;">Runnable</span><span style="color:black;">接口。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">执行</span><span style="color:black;">Callable</span><span style="color:black;">任务后，可以获取一个</span><span style="color:black;">Future</span><span style="color:black;">的对象，在该对象上调用</span><span style="color:black;">get</span><span style="color:black;">就可以获取到</span><span style="color:black;">Callable</span><span style="color:black;">任务返回的</span><span style="color:black;">Object</span><span style="color:black;">了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面是个很简单的例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.*;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：有返回值的线程</span><span style="color:green;"><br/> * <br/> * @author Administrator 2009-11-5 0:41:50 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args)</span><span style="color:blue;">throws</span><span style="color:black;"> ExecutionException, InterruptedException {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建两个有返回值的任务</span><span style="color:black;"><br/>                 Callable c1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyCallable(</span><span style="color:maroon;">&quot;A&quot;</span><span style="color:black;">);<br/>                 Callable c2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyCallable(</span><span style="color:maroon;">&quot;B&quot;</span><span style="color:black;">);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行任务并获取</span><span style="color:green;">Future</span><span style="color:green;">对象</span><span style="color:black;"><br/>                 Future f1 = pool.submit(c1); <br/>                 Future f2 = pool.submit(c2); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">从</span><span style="color:green;">Future</span><span style="color:green;">对象上获取任务的返回值，并输出到控制台</span><span style="color:black;"><br/>                 System.out.println(</span><span style="color:maroon;">&quot;&gt;&gt;&gt;&quot;</span><span style="color:black;">+f1.get().toString());<br/>                 System.out.println(</span><span style="color:maroon;">&quot;&gt;&gt;&gt;&quot;</span><span style="color:black;">+f2.get().toString());<br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCallable</span><span style="color:blue;">implements</span><span style="color:black;"> Callable{<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String oid;<br/> <br/>         MyCallable(String oid) { <br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>         } <br/> <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> Object call()</span><span style="color:blue;">throws</span><span style="color:black;"> Exception {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> oid+</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">任务返回的内容</span><span style="color:maroon;">&quot;</span><span style="color:black;">;<br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">&gt;&gt;&gt;A</span><span style="color:black;">任务返回的内容</span><span style="color:black;"><br/> &gt;&gt;&gt;B</span><span style="color:black;">任务返回的内容</span><span style="color:black;"> <br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">非常的简单，要深入了解还需要看</span><span style="color:black;">Callable</span><span style="color:black;">和</span><span style="color:black;">Future</span><span style="color:black;">接口的</span><span style="color:black;">API</span><span style="color:black;">啊。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997780" target="_blank"></a><a name="_Toc258997477" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：新特征</span><span style="color:red;">-</span><span style="color:red;">锁（上）</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在</span><span style="color:black;">Java5</span><span style="color:black;">中，专门提供了锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，这些内容主要集中在</span><span style="color:black;">java.util.concurrent.locks</span><span style="color:black;">包下面，里面有三个重要的接口</span><span style="color:black;">Condition</span><span style="color:black;">、</span><span style="color:black;">Lock</span><span style="color:black;">、</span><span style="color:black;">ReadWriteLock</span><span style="color:black;">。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<table border="1" cellpadding="0" cellspacing="0" style="font-size:inherit;font-weight:inherit;font-style:inherit;font-variant:inherit;border:1px solid silver;border-collapse:collapse;word-break:break-word;">
<tbody>
<tr>
<td style="border:1px solid silver;border-collapse:collapse;padding:3px;background:white;">
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent.locks"><span style="color:black;">Condition</span></a></span></strong></p>
 </td>
<td style="border:1px solid silver;border-collapse:collapse;padding:3px;background:white;">
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:#333333;">Condition</span><span style="color:#333333;">将</span><span style="color:#333333;">Object</span><span style="color:#333333;">监视器方法（</span><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">wait</span></a></span><span style="color:#333333;">、</span><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">notify</span></a></span><span style="color:#333333;">和</span><span style="color:#333333;"> <a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank"><span style="color:black;">notifyAll</span></a></span><span style="color:#333333;">）分解成截然不同的对象，以便通过将这些对象与任意</span><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent.locks"><span style="color:black;">Lock</span></a></span><span style="color:#333333;">实现组合使用，为每个对象提供多个等待</span><span style="color:#333333;"> set</span><span style="color:#333333;">（</span><span style="color:#333333;">wait-set</span><span style="color:#333333;">）。</span></p>
 </td>
 
   </tr>
<tr>
<td style="border:1px solid silver;border-collapse:collapse;padding:3px;background:white;">
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent.locks"><span style="color:black;">Lock</span></a></span></strong></p>
 </td>
<td style="border:1px solid silver;border-collapse:collapse;padding:3px;background:white;">
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:#333333;">Lock</span><span style="color:#333333;">实现提供了比使用</span><span style="color:#333333;">synchronized</span><span style="color:#333333;">方法和语句可获得的更广泛的锁定操作。</span></p>
 </td>
 
   </tr>
<tr>
<td style="border:1px solid silver;border-collapse:collapse;padding:3px;background:white;">
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><strong><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent.locks"><span style="color:black;">ReadWriteLock</span></a></span></strong></p>
 </td>
<td style="border:1px solid silver;border-collapse:collapse;padding:3px;background:white;">
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:#333333;">ReadWriteLock</span><span style="color:#333333;">维护了一对相关的</span><span style="color:#333333;"><a href="http://www.cnblogs.com/riskyer/admin/" style="color:rgb(102, 0, 204);text-decoration:none;" target="_blank" title="java.util.concurrent.locks"><span style="color:black;">锁定</span></a></span><span style="color:#333333;">，一个用于只读操作，另一个用于写入操作。</span></p>
 </td>
 
   </tr>
 
  </tbody>
 
 </table>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">有关锁的介绍</span><span style="color:black;">,API</span><span style="color:black;">文档解说很多，看得很烦，还是看个例子再看文档比较容易理解。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.Lock;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.ReentrantLock;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：锁</span><span style="color:green;"> <br/> * <br/> * @author leizhimin 2009-11-5 10:57:29 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建并发访问的账户</span><span style="color:black;"><br/>                 MyCount myCount = </span><span style="color:blue;">new</span><span style="color:black;"> MyCount(</span><span style="color:maroon;">&quot;95599200901215522&quot;</span><span style="color:black;">, 10000);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个锁对象</span><span style="color:black;"><br/>                 Lock lock = </span><span style="color:blue;">new</span><span style="color:black;"> ReentrantLock();<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newCachedThreadPool(); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊</span><span style="color:black;"><br/>                 User u1 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, -4000, lock); <br/>                 User u2 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三他爹</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 6000, lock); <br/>                 User u3 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三他弟</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, -8000, lock); <br/>                 User u4 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 800, lock);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">在线程池中执行各个用户的操作</span><span style="color:black;"><br/>                 pool.execute(u1); <br/>                 pool.execute(u2); <br/>                 pool.execute(u3); <br/>                 pool.execute(u4); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">信用卡的用户</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> User </span> <span style="color:blue;">implements</span><span style="color:black;"> Runnable { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">用户名</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">所要操作的账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> iocash;                </span><span style="color:green;">//</span><span style="color:green;">操作的金额，当然有正负之分了</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Lock myLock;                </span><span style="color:green;">//</span><span style="color:green;">执行操作所需的锁对象</span><span style="color:black;"><br/> <br/>         User(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> iocash, Lock myLock) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.iocash = iocash;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myLock = myLock;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">获取锁</span><span style="color:black;"><br/>                 myLock.lock(); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行现金业务</span><span style="color:black;"><br/>                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">正在操作</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">账户，金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + iocash +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount.getCash());<br/>                 myCount.setCash(myCount.getCash() + iocash); <br/>                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">操作</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">账户成功，金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + iocash +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount.getCash());<br/>                 </span><span style="color:green;">//</span><span style="color:green;">释放锁，否则别的线程没有机会执行了</span><span style="color:black;"><br/>                 myLock.unlock(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">信用卡账户，可随意透支</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCount { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String oid;        </span><span style="color:green;">//</span><span style="color:green;">账号</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;            </span><span style="color:green;">//</span><span style="color:green;">账户余额</span><span style="color:black;"><br/> <br/>         MyCount(String oid, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String getOid() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> oid;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setOid(String oid) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> getCash() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> cash;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setCash(</span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String toString() {<br/>                 </span><span style="color:blue;">return</span><span style="color:maroon;">&quot;MyCount{&quot;</span><span style="color:black;"> +<br/>                                 </span><span style="color:maroon;">&quot;oid='&quot;</span><span style="color:black;"> + oid + '\'' +<br/>                                 </span><span style="color:maroon;">&quot;, cash=&quot;</span><span style="color:black;"> + cash +<br/>                                 '}'; <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">张三正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=10000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">-4000</span><span style="color:black;">，当前金额为</span><span style="color:black;">10000<br/> </span><span style="color:black;">张三操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=6000}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">-4000</span><span style="color:black;">，当前金额为</span><span style="color:black;">6000<br/> </span><span style="color:black;">张三他爹正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=6000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">6000</span><span style="color:black;">，当前金额为</span><span style="color:black;">6000<br/> </span><span style="color:black;">张三他爹操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=12000}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">6000</span><span style="color:black;">，当前金额为</span><span style="color:black;">12000<br/> </span><span style="color:black;">张三他弟正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=12000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">-8000</span><span style="color:black;">，当前金额为</span><span style="color:black;">12000<br/> </span><span style="color:black;">张三他弟操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=4000}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">-8000</span><span style="color:black;">，当前金额为</span><span style="color:black;">4000<br/> </span><span style="color:black;">张三正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=4000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">800</span><span style="color:black;">，当前金额为</span><span style="color:black;">4000<br/> </span><span style="color:black;">张三操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=4800}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">800</span><span style="color:black;">，当前金额为</span><span style="color:black;">4800<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从上面的输出可以看到，利用锁对象太方便了，比直接在某个不知情的对象上用锁清晰多了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">但一定要注意的是，在获取了锁对象后，用完后应该尽快释放锁，以便别的等待该锁的线程有机会去执行。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997781" target="_blank"></a><a name="_Toc258997478" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：新特征<span style="font-family:Times New Roman;">-</span>锁（下）</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在上文中提到了</span><span style="color:black;">Lock</span><span style="color:black;">接口以及对象，使用它，很优雅的控制了竞争资源的安全访问，但是这种锁不区分读写，称这种锁为普通锁。为了提高性能，</span><span style="color:black;">Java</span><span style="color:black;">提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，在一定程度上提高了程序的执行效率。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java</span><span style="color:black;">中读写锁有个接口</span><span style="color:black;">java.util.concurrent.locks.ReadWriteLock</span><span style="color:black;">，也有具体的实现</span><span style="color:black;">ReentrantReadWriteLock</span><span style="color:black;">，详细的</span><span style="color:black;">API</span><span style="color:black;">可以查看</span><span style="color:black;">JavaAPI</span><span style="color:black;">文档。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面这个例子是在文例子的基础上，将普通锁改为读写锁，并添加账户余额查询的功能，代码如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.ReadWriteLock;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.ReentrantReadWriteLock;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：锁</span><span style="color:green;"> <br/> * <br/> * @author leizhimin 2009-11-5 10:57:29 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建并发访问的账户</span><span style="color:black;"><br/>                 MyCount myCount = </span><span style="color:blue;">new</span><span style="color:black;"> MyCount(</span><span style="color:maroon;">&quot;95599200901215522&quot;</span><span style="color:black;">, 10000);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个锁对象</span><span style="color:black;"><br/>                 ReadWriteLock lock = </span><span style="color:blue;">new</span><span style="color:black;"> ReentrantReadWriteLock(</span><span style="color:blue;">false</span><span style="color:black;">);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一些并发访问用户，一个信用卡，存的存，取的取，好热闹啊</span><span style="color:black;"><br/>                 User u1 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, -4000, lock, </span><span style="color:blue;">false</span><span style="color:black;">); <br/>                 User u2 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三他爹</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 6000, lock, </span><span style="color:blue;">false</span><span style="color:black;">); <br/>                 User u3 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三他弟</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, -8000, lock, </span><span style="color:blue;">false</span><span style="color:black;">); <br/>                 User u4 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 800, lock,</span><span style="color:blue;">false</span><span style="color:black;">); <br/>                 User u5 = </span><span style="color:blue;">new</span><span style="color:black;"> User(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三他爹</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 0, lock,</span><span style="color:blue;">true</span><span style="color:black;">); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">在线程池中执行各个用户的操作</span><span style="color:black;"><br/>                 pool.execute(u1); <br/>                 pool.execute(u2); <br/>                 pool.execute(u3); <br/>                 pool.execute(u4); <br/>                 pool.execute(u5); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">信用卡的用户</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> User </span> <span style="color:blue;">implements</span><span style="color:black;"> Runnable { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">用户名</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">所要操作的账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> iocash;                </span><span style="color:green;">//</span><span style="color:green;">操作的金额，当然有正负之分了</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> ReadWriteLock myLock;                </span><span style="color:green;">//</span><span style="color:green;">执行操作所需的锁对象</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">boolean</span><span style="color:black;"> ischeck;        </span><span style="color:green;">//</span><span style="color:green;">是否查询</span><span style="color:black;"><br/> <br/>         User(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> iocash, ReadWriteLock myLock,</span><span style="color:blue;">boolean</span><span style="color:black;"> ischeck) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.iocash = iocash;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myLock = myLock;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.ischeck = ischeck;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">if</span><span style="color:black;"> (ischeck) {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">获取读锁</span><span style="color:black;"><br/>                         myLock.readLock().lock(); <br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">读：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + name +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">正在查询</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">账户，当前金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount.getCash());<br/>                         </span><span style="color:green;">//</span><span style="color:green;">释放读锁</span><span style="color:black;"><br/>                         myLock.readLock().unlock(); <br/>                 } </span><span style="color:blue;">else</span><span style="color:black;"> {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">获取写锁</span><span style="color:black;"><br/>                         myLock.writeLock().lock(); <br/>                         </span><span style="color:green;">//</span><span style="color:green;">执行现金业务</span><span style="color:black;"><br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">写：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + name +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">正在操作</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">账户，金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + iocash +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount.getCash());<br/>                         myCount.setCash(myCount.getCash() + iocash); <br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">写：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + name +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">操作</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">账户成功，金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + iocash +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前金额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + myCount.getCash());<br/>                         </span><span style="color:green;">//</span><span style="color:green;">释放写锁</span><span style="color:black;"><br/>                         myLock.writeLock().unlock(); <br/>                 } <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">信用卡账户，可随意透支</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCount { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String oid;        </span><span style="color:green;">//</span><span style="color:green;">账号</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;            </span><span style="color:green;">//</span><span style="color:green;">账户余额</span><span style="color:black;"><br/> <br/>         MyCount(String oid, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String getOid() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> oid;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setOid(String oid) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">int</span><span style="color:black;"> getCash() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> cash;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setCash(</span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         @Override <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> String toString() {<br/>                 </span><span style="color:blue;">return</span><span style="color:maroon;">&quot;MyCount{&quot;</span><span style="color:black;"> +<br/>                                 </span><span style="color:maroon;">&quot;oid='&quot;</span><span style="color:black;"> + oid + '\'' +<br/>                                 </span><span style="color:maroon;">&quot;, cash=&quot;</span><span style="color:black;"> + cash +<br/>                                 '}'; <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">写：张三正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=10000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">-4000</span><span style="color:black;">，当前金额为</span><span style="color:black;">10000<br/> </span><span style="color:black;">写：张三操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=6000}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">-4000</span><span style="color:black;">，当前金额为</span><span style="color:black;">6000<br/> </span><span style="color:black;">写：张三他弟正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=6000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">-8000</span><span style="color:black;">，当前金额为</span><span style="color:black;">6000<br/> </span><span style="color:black;">写：张三他弟操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=-2000}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">-8000</span><span style="color:black;">，当前金额为</span><span style="color:black;">-2000<br/> </span><span style="color:black;">写：张三正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=-2000}</span><span style="color:black;">账户，金额为</span><span style="color:black;">800</span><span style="color:black;">，当前金额为</span><span style="color:black;">-2000<br/> </span><span style="color:black;">写：张三操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=-1200}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">800</span><span style="color:black;">，当前金额为</span><span style="color:black;">-1200<br/> </span><span style="color:black;">读：张三他爹正在查询</span><span style="color:black;">MyCount{oid='95599200901215522', cash=-1200}</span><span style="color:black;">账户，当前金额为</span><span style="color:black;">-1200<br/> </span><span style="color:black;">写：张三他爹正在操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=-1200}</span><span style="color:black;">账户，金额为</span><span style="color:black;">6000</span><span style="color:black;">，当前金额为</span><span style="color:black;">-1200<br/> </span><span style="color:black;">写：张三他爹操作</span><span style="color:black;">MyCount{oid='95599200901215522', cash=4800}</span><span style="color:black;">账户成功，金额为</span><span style="color:black;">6000</span><span style="color:black;">，当前金额为</span><span style="color:black;">4800<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">在实际开发中，最好在能用读写锁的情况下使用读写锁，而不要用普通锁，以求更好的性能。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997782" target="_blank"></a><a name="_Toc258997479" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：新特征<span style="font-family:Times New Roman;">-</span>信号量</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java</span><span style="color:black;">的信号量实际上是一个功能完毕的计数器，对控制一定资源的消费与回收有着很重要的意义，信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等，这里总是在强调</span><span style="color:black;">“</span><span style="color:black;">数目</span><span style="color:black;">”</span><span style="color:black;">二字，但不能指出来有哪些在等待，哪些资源可用。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">因此，本人认为，这个信号量类如果能返回数目，还能知道哪些对象在等待，哪些资源可使用，就非常完美了，仅仅拿到这些概括性的数字，对精确控制意义不是很大。目前还没想到更好的用法。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面是一个简单例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Semaphore;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：新特征</span><span style="color:green;">-</span><span style="color:green;">信号量</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-5 13:44:45 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 MyPool myPool = </span><span style="color:blue;">new</span><span style="color:black;"> MyPool(20);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建线程池</span><span style="color:black;"><br/>                 ExecutorService threadPool = Executors.newFixedThreadPool(2); <br/>                 MyThread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">任务</span><span style="color:maroon;">A&quot;</span><span style="color:black;">, myPool, 3); <br/>                 MyThread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">任务</span><span style="color:maroon;">B&quot;</span><span style="color:black;">, myPool, 12); <br/>                 MyThread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">任务</span><span style="color:maroon;">C&quot;</span><span style="color:black;">, myPool, 7); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">在线程池中执行任务</span><span style="color:black;"><br/>                 threadPool.execute(t1); <br/>                 threadPool.execute(t2); <br/>                 threadPool.execute(t3); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭池</span><span style="color:black;"><br/>                 threadPool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">一个池</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyPool { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Semaphore sp;    </span><span style="color:green;">//</span><span style="color:green;">池相关的信号量</span><span style="color:black;"><br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">池的大小，这个大小会传递给信号量</span><span style="color:green;"><br/>          * <br/>          * @param size </span><span style="color:green;">池的大小</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         MyPool(</span><span style="color:blue;">int</span><span style="color:black;"> size) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.sp =</span><span style="color:blue;">new</span><span style="color:black;"> Semaphore(size);<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:black;"> Semaphore getSp() {<br/>                 </span><span style="color:blue;">return</span><span style="color:black;"> sp;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> setSp(Semaphore sp) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.sp = sp;<br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyThread </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String threadname;            </span><span style="color:green;">//</span><span style="color:green;">线程的名称</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyPool pool;                        </span><span style="color:green;">//</span><span style="color:green;">自定义池</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                                    </span><span style="color:green;">//</span><span style="color:green;">申请信号量的大小</span><span style="color:black;"><br/> <br/>         MyThread(String threadname, MyPool pool, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.threadname = threadname;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.pool = pool;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">从此信号量获取给定数目的许可</span><span style="color:black;"><br/>                         pool.getSp().acquire(x); <br/>                         </span><span style="color:green;">//todo</span><span style="color:green;">：也许这里可以做更复杂的业务</span><span style="color:black;"><br/>                         System.out.println(threadname + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">成功获取了</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">个许可！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                         e.printStackTrace(); <br/>                 } </span><span style="color:blue;">finally</span><span style="color:black;"> {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">释放给定数目的许可，将其返回到信号量。</span><span style="color:black;"><br/>                         pool.getSp().release(x); <br/>                         System.out.println(threadname + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">释放了</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">个许可！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">任务</span><span style="color:black;">B</span><span style="color:black;">成功获取了</span><span style="color:black;">12</span><span style="color:black;">个许可！</span><span style="color:black;"><br/> </span><span style="color:black;">任务</span><span style="color:black;">B</span><span style="color:black;">释放了</span><span style="color:black;">12</span><span style="color:black;">个许可！</span><span style="color:black;"><br/> </span><span style="color:black;">任务</span><span style="color:black;">A</span><span style="color:black;">成功获取了</span><span style="color:black;">3</span><span style="color:black;">个许可！</span><span style="color:black;"><br/> </span><span style="color:black;">任务</span><span style="color:black;">C</span><span style="color:black;">成功获取了</span><span style="color:black;">7</span><span style="color:black;">个许可！</span><span style="color:black;"><br/> </span><span style="color:black;">任务</span><span style="color:black;">C</span><span style="color:black;">释放了</span><span style="color:black;">7</span><span style="color:black;">个许可！</span><span style="color:black;"><br/> </span><span style="color:black;">任务</span><span style="color:black;">A</span><span style="color:black;">释放了</span><span style="color:black;">3</span><span style="color:black;">个许可！</span><span style="color:black;"><br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从结果可以看出，信号量仅仅是对池资源进行监控，但不保证线程的安全，因此，在使用时候，应该自己控制线程的安全访问池资源。</span></p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Hlt258997789" target="_blank"></a><a name="_Toc258997783" target="_blank"></a><a name="_Toc258997480" target="_blank"></a><span style="font-family:Times New Roman;">Java</span>线程：新特征<span style="font-family:Times New Roman;">-</span>阻塞队列</h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">阻塞队列是</span><span style="color:black;">Java5</span><span style="color:black;">线程新特征中的内容，</span><span style="color:black;">Java</span><span style="color:black;">定义了阻塞队列的接口</span><span style="color:black;">java.util.concurrent.BlockingQueue</span><span style="color:black;">，阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">java.util.concurrent.BlockingQueue</span><span style="color:black;">继承了</span><span style="color:black;">java.util.Queue</span><span style="color:black;">接口，可以参看</span><span style="color:black;">API</span><span style="color:black;">文档。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面给出一个简单应用的例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.BlockingQueue;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ArrayBlockingQueue;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：新特征</span><span style="color:green;">-</span><span style="color:green;">阻塞队列</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-5 14:59:15 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args)</span><span style="color:blue;">throws</span><span style="color:black;"> InterruptedException {<br/>                 BlockingQueue bqueue = </span><span style="color:blue;">new</span><span style="color:black;"> ArrayBlockingQueue(20);<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 30; i++) {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">将指定元素添加到此队列中，如果没有可用空间，将一直等待（如果有必要）。</span><span style="color:black;"><br/>                         bqueue.put(i); <br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">向阻塞队列中添加了元素</span><span style="color:maroon;">:&quot;</span><span style="color:black;"> + i);<br/>                 } <br/>                 System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">程序到此运行结束，即将退出</span><span style="color:maroon;">----&quot;</span><span style="color:black;">);<br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">输出结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:0<br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:1 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:2 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:3 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:4 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:5 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:6 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:7 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:8 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:9 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:10 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:11 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:12 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:13 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:14 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:15 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:16 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:17 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:18 <br/> </span><span style="color:black;">向阻塞队列中添加了元素</span><span style="color:black;">:19 </span> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">可以看出，输出到元素</span><span style="color:black;">19</span><span style="color:black;">时候，就一直处于等待状态，因为队列满了，程序阻塞了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这里没有用多线程来演示，没有这个必要。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">另外，阻塞队列还有更多实现类，用来满足各种复杂的需求：</span><span style="color:black;">ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue</span><span style="color:black;">，具体的</span><span style="color:black;">API</span><span style="color:black;">差别也很小。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997784" target="_blank"></a><a name="_Toc258997481" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：新特征</span><span style="color:red;">-</span><span style="color:red;">阻塞栈</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对于阻塞栈，与阻塞队列相似。不同点在于栈是</span><span style="color:black;">“</span><span style="color:black;">后入先出</span><span style="color:black;">”</span><span style="color:black;">的结构，每次操作的是栈顶，而队列是</span><span style="color:black;">“</span><span style="color:black;">先进先出</span><span style="color:black;">”</span><span style="color:black;">的结构，每次操作的是队列头。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这里要特别说明一点的是，阻塞栈是</span><span style="color:black;">Java6</span><span style="color:black;">的新特征。、</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java</span><span style="color:black;">为阻塞栈定义了接口：</span><span style="color:black;">java.util.concurrent.BlockingDeque</span><span style="color:black;">，其实现类也比较多，具体可以查看</span><span style="color:black;">JavaAPI</span><span style="color:black;">文档。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面看一个简单例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.BlockingDeque;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.LinkedBlockingDeque;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：新特征</span><span style="color:green;">-</span><span style="color:green;">阻塞栈</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-5 15:34:29 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args)</span><span style="color:blue;">throws</span><span style="color:black;"> InterruptedException {<br/>                 BlockingDeque bDeque = </span><span style="color:blue;">new</span><span style="color:black;"> LinkedBlockingDeque(20);<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 30; i++) {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">将指定元素添加到此阻塞栈中，如果没有可用空间，将一直等待（如果有必要）。</span><span style="color:black;"><br/>                         bDeque.putFirst(i); <br/>                         System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">向阻塞栈中添加了元素</span><span style="color:maroon;">:&quot;</span><span style="color:black;"> + i);<br/>                 } <br/>                 System.out.println(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">程序到此运行结束，即将退出</span><span style="color:maroon;">----&quot;</span><span style="color:black;">);<br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">输出结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:0<br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:1 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:2 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:3 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:4 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:5 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:6 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:7 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:8 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:9 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:10 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:11 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:12 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:13 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:14 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:15 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:16 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:17 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:18 <br/> </span><span style="color:black;">向阻塞栈中添加了元素</span><span style="color:black;">:19 </span> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从上面结果可以看到，程序并没结束，二是阻塞住了，原因是栈已经满了，后面追加元素的操作都被阻塞了。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997785" target="_blank"></a><a name="_Toc258997482" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：新特征</span><span style="color:red;">-</span><span style="color:red;">条件变量</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">条件变量是</span><span style="color:black;">Java5</span><span style="color:black;">线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这里的条件和普通意义上的条件表达式有着天壤之别。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">条件变量都实现了</span><span style="color:black;">java.util.concurrent.locks.Condition</span><span style="color:black;">接口，条件变量的实例化是通过一个</span><span style="color:black;">Lock</span><span style="color:black;">对象上调用</span><span style="color:black;">newCondition()</span><span style="color:black;">方法来获取的，这样，条件就和一个锁对象绑定起来了。因此，</span><span style="color:black;">Java</span><span style="color:black;">中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">条件变量的出现是为了更精细控制线程等待与唤醒，在</span><span style="color:black;">Java5</span><span style="color:black;">之前，线程的等待与唤醒依靠的是</span><span style="color:black;">Object</span><span style="color:black;">对象的</span><span style="color:black;">wait()</span><span style="color:black;">和</span><span style="color:black;">notify()/notifyAll()</span><span style="color:black;">方法，这样的处理不够精细。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">而在</span><span style="color:black;">Java5</span><span style="color:black;">中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用</span><span style="color:black;">await()</span><span style="color:black;">方法，可以让线程在该条件下等待。当调用</span><span style="color:black;">signalAll()</span><span style="color:black;">方法，又可以唤醒该条件下的等待的线程。有关</span><span style="color:black;">Condition</span><span style="color:black;">接口的</span><span style="color:black;">API</span><span style="color:black;">可以具体参考</span><span style="color:black;">JavaAPI</span><span style="color:black;">文档。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">条件变量比较抽象，原因是他不是自然语言中的条件概念，而是程序控制的一种手段。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面以一个银行存取款的模拟程序为例来揭盖</span><span style="color:black;">Java</span><span style="color:black;">多线程条件变量的神秘面纱：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">有一个账户，多个用户（线程）在同时操作这个账户，有的存款有的取款，存款随便存，取款有限制，不能透支，任何试图透支的操作都将等待里面有足够存款才执行操作。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.Condition;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.Lock;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.ReentrantLock;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：条件变量</span><span style="color:green;"> <br/> * <br/> * @author leizhimin 2009-11-5 10:57:29 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建并发访问的账户</span><span style="color:black;"><br/>                 MyCount myCount = </span><span style="color:blue;">new</span><span style="color:black;"> MyCount(</span><span style="color:maroon;">&quot;95599200901215522&quot;</span><span style="color:black;">, 10000);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 2000); <br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 3600); <br/>                 Thread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">王五</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 2700); <br/>                 Thread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老张</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 600); <br/>                 Thread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老牛</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 1300); <br/>                 Thread t6 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">胖子</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 800); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行各个线程</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 pool.execute(t6); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">存款线程类</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> SaveThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">存款金额</span><span style="color:black;"><br/> <br/>         SaveThread(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 myCount.saving(x, name); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">取款线程类</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> DrawThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">存款金额</span><span style="color:black;"><br/> <br/>         DrawThread(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 myCount.drawing(x, name); <br/>         } <br/> } <br/> <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">普通银行账户，不可透支</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCount { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String oid;                        </span><span style="color:green;">//</span><span style="color:green;">账号</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;                            </span><span style="color:green;">//</span><span style="color:green;">账户余额</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Lock lock =</span><span style="color:blue;">new</span><span style="color:black;"> ReentrantLock();                </span><span style="color:green;">//</span><span style="color:green;">账户锁</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Condition _save = lock.newCondition();    </span><span style="color:green;">//</span><span style="color:green;">存款条件</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Condition _draw = lock.newCondition();    </span><span style="color:green;">//</span><span style="color:green;">取款条件</span><span style="color:black;"><br/> <br/>         MyCount(String oid, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">存款</span><span style="color:green;"> <br/>          * <br/>          * @param x        </span><span style="color:green;">操作金额</span><span style="color:green;"><br/>          * @param name </span><span style="color:green;">操作人</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> saving(</span><span style="color:blue;">int</span><span style="color:black;"> x, String name) {<br/>                 lock.lock();                        </span><span style="color:green;">//</span><span style="color:green;">获取锁</span><span style="color:black;"><br/>                 </span><span style="color:blue;">if</span><span style="color:black;"> (x &gt; 0) {<br/>                         cash += x;                    </span><span style="color:green;">//</span><span style="color:green;">存款</span><span style="color:black;"><br/>                         System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">存款</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                 } <br/>                 _draw.signalAll();            </span><span style="color:green;">//</span><span style="color:green;">唤醒所有等待线程。</span><span style="color:black;"><br/>                 lock.unlock();                    </span><span style="color:green;">//</span><span style="color:green;">释放锁</span><span style="color:black;"><br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">取款</span><span style="color:green;"> <br/>          * <br/>          * @param x        </span><span style="color:green;">操作金额</span><span style="color:green;"><br/>          * @param name </span><span style="color:green;">操作人</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> drawing(</span><span style="color:blue;">int</span><span style="color:black;"> x, String name) {<br/>                 lock.lock();                                 </span><span style="color:green;">//</span><span style="color:green;">获取锁</span><span style="color:black;"><br/>                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                         </span><span style="color:blue;">if</span><span style="color:black;"> (cash - x &lt; 0) {<br/>                                 _draw.await();             </span><span style="color:green;">//</span><span style="color:green;">阻塞取款操作</span><span style="color:black;"><br/>                         } </span><span style="color:blue;">else</span><span style="color:black;"> {<br/>                                 cash -= x;                     </span><span style="color:green;">//</span><span style="color:green;">取款</span><span style="color:black;"><br/>                                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">取款</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                         } <br/>                         _save.signalAll();             </span><span style="color:green;">//</span><span style="color:green;">唤醒所有存款操作</span><span style="color:black;"><br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                         e.printStackTrace(); <br/>                 } </span><span style="color:blue;">finally</span><span style="color:black;"> {<br/>                         lock.unlock();                     </span><span style="color:green;">//</span><span style="color:green;">释放锁</span><span style="color:black;"><br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">李四存款</span><span style="color:black;">3600</span><span style="color:black;">，当前余额为</span><span style="color:black;">13600<br/> </span><span style="color:black;">张三存款</span><span style="color:black;">2000</span><span style="color:black;">，当前余额为</span><span style="color:black;">15600<br/> </span><span style="color:black;">老张存款</span><span style="color:black;">600</span><span style="color:black;">，当前余额为</span><span style="color:black;">16200<br/> </span><span style="color:black;">老牛取款</span><span style="color:black;">1300</span><span style="color:black;">，当前余额为</span><span style="color:black;">14900<br/> </span><span style="color:black;">胖子取款</span><span style="color:black;">800</span><span style="color:black;">，当前余额为</span><span style="color:black;">14100<br/> </span><span style="color:black;">王五取款</span><span style="color:black;">2700</span><span style="color:black;">，当前余额为</span><span style="color:black;">11400<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">假如我们不用锁和条件变量，如何实现此功能呢？下面是实现代码：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：不用条件变量</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-5 10:57:29 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建并发访问的账户</span><span style="color:black;"><br/>                 MyCount myCount = </span><span style="color:blue;">new</span><span style="color:black;"> MyCount(</span><span style="color:maroon;">&quot;95599200901215522&quot;</span><span style="color:black;">, 10000);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 2000); <br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 3600); <br/>                 Thread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">王五</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 2700); <br/>                 Thread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老张</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 600); <br/>                 Thread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老牛</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 1300); <br/>                 Thread t6 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">胖子</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 800); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行各个线程</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 pool.execute(t6); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">存款线程类</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> SaveThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">存款金额</span><span style="color:black;"><br/> <br/>         SaveThread(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 myCount.saving(x, name); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">取款线程类</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> DrawThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">存款金额</span><span style="color:black;"><br/> <br/>         DrawThread(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 myCount.drawing(x, name); <br/>         } <br/> } <br/> <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">普通银行账户，不可透支</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCount { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String oid;                        </span><span style="color:green;">//</span><span style="color:green;">账号</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;                            </span><span style="color:green;">//</span><span style="color:green;">账户余额</span><span style="color:black;"><br/> <br/>         MyCount(String oid, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">存款</span><span style="color:green;"> <br/>          * <br/>          * @param x        </span><span style="color:green;">操作金额</span><span style="color:green;"><br/>          * @param name </span><span style="color:green;">操作人</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> saving(</span><span style="color:blue;">int</span><span style="color:black;"> x, String name) {<br/>                 </span><span style="color:blue;">if</span><span style="color:black;"> (x &gt; 0) {<br/>                         cash += x;                    </span><span style="color:green;">//</span><span style="color:green;">存款</span><span style="color:black;"><br/>                         System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">存款</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                 } <br/>                 notifyAll();            </span><span style="color:green;">//</span><span style="color:green;">唤醒所有等待线程。</span><span style="color:black;"><br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">取款</span><span style="color:green;"> <br/>          * <br/>          * @param x        </span><span style="color:green;">操作金额</span><span style="color:green;"><br/>          * @param name </span><span style="color:green;">操作人</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> drawing(</span><span style="color:blue;">int</span><span style="color:black;"> x, String name) {<br/>                 </span><span style="color:blue;">if</span><span style="color:black;"> (cash - x &lt; 0) {<br/>                         </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                 wait(); <br/>                         } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e1) {<br/>                                 e1.printStackTrace(); <br/>                         } <br/>                 } </span><span style="color:blue;">else</span><span style="color:black;"> {<br/>                         cash -= x;                     </span><span style="color:green;">//</span><span style="color:green;">取款</span><span style="color:black;"><br/>                         System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">取款</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                 } <br/>                 notifyAll();             </span><span style="color:green;">//</span><span style="color:green;">唤醒所有存款操作</span><span style="color:black;"><br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">输出结果为：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">李四存款</span><span style="color:black;">3600</span><span style="color:black;">，当前余额为</span><span style="color:black;">13600<br/> </span><span style="color:black;">王五取款</span><span style="color:black;">2700</span><span style="color:black;">，当前余额为</span><span style="color:black;">10900<br/> </span><span style="color:black;">老张存款</span><span style="color:black;">600</span><span style="color:black;">，当前余额为</span><span style="color:black;">11500<br/> </span><span style="color:black;">老牛取款</span><span style="color:black;">1300</span><span style="color:black;">，当前余额为</span><span style="color:black;">10200<br/> </span><span style="color:black;">胖子取款</span><span style="color:black;">800</span><span style="color:black;">，当前余额为</span><span style="color:black;">9400<br/> </span><span style="color:black;">张三存款</span><span style="color:black;">2000</span><span style="color:black;">，当前余额为</span><span style="color:black;">11400<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">结合先前同步代码知识，举一反三，将此例改为同步代码块来实现，代码如下：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：改为同步代码块</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-5 10:57:29 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建并发访问的账户</span><span style="color:black;"><br/>                 MyCount myCount = </span><span style="color:blue;">new</span><span style="color:black;"> MyCount(</span><span style="color:maroon;">&quot;95599200901215522&quot;</span><span style="color:black;">, 10000);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建一个线程池</span><span style="color:black;"><br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 Thread t1 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 2000); <br/>                 Thread t2 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 3600); <br/>                 Thread t3 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">王五</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 2700); <br/>                 Thread t4 = </span><span style="color:blue;">new</span><span style="color:black;"> SaveThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老张</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 600); <br/>                 Thread t5 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老牛</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 1300); <br/>                 Thread t6 = </span><span style="color:blue;">new</span><span style="color:black;"> DrawThread(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">胖子</span><span style="color:maroon;">&quot;</span><span style="color:black;">, myCount, 800); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行各个线程</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 pool.execute(t6); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">存款线程类</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> SaveThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">存款金额</span><span style="color:black;"><br/> <br/>         SaveThread(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 myCount.saving(x, name); <br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">取款线程类</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> DrawThread</span><span style="color:blue;">extends</span><span style="color:black;"> Thread {<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> MyCount myCount;        </span><span style="color:green;">//</span><span style="color:green;">账户</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">存款金额</span><span style="color:black;"><br/> <br/>         DrawThread(String name, MyCount myCount, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.myCount = myCount;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 myCount.drawing(x, name); <br/>         } <br/> } <br/> <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">普通银行账户，不可透支</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyCount { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String oid;                        </span><span style="color:green;">//</span><span style="color:green;">账号</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> cash;                            </span><span style="color:green;">//</span><span style="color:green;">账户余额</span><span style="color:black;"><br/> <br/>         MyCount(String oid, </span><span style="color:blue;">int</span><span style="color:black;"> cash) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.oid = oid;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cash = cash;<br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">存款</span><span style="color:green;"> <br/>          * <br/>          * @param x        </span><span style="color:green;">操作金额</span><span style="color:green;"><br/>          * @param name </span><span style="color:green;">操作人</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> saving(</span><span style="color:blue;">int</span><span style="color:black;"> x, String name) {<br/>                 </span><span style="color:blue;">if</span><span style="color:black;"> (x &gt; 0) {<br/>                         </span><span style="color:blue;">synchronized</span><span style="color:black;"> (</span><span style="color:blue;">this</span><span style="color:black;">) {<br/>                                 cash += x;                    </span><span style="color:green;">//</span><span style="color:green;">存款</span><span style="color:black;"><br/>                                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">存款</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                                 notifyAll();            </span><span style="color:green;">//</span><span style="color:green;">唤醒所有等待线程。</span><span style="color:black;"><br/>                         } <br/>                 } <br/>         } <br/> <br/>         </span><span style="color:green;">/** <br/>          * </span><span style="color:green;">取款</span><span style="color:green;"> <br/>          * <br/>          * @param x        </span><span style="color:green;">操作金额</span><span style="color:green;"><br/>          * @param name </span><span style="color:green;">操作人</span><span style="color:green;"><br/>          */</span><span style="color:black;"> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">synchronized</span><span style="color:blue;">void</span><span style="color:black;"> drawing(</span><span style="color:blue;">int</span><span style="color:black;"> x, String name) {<br/>                 </span><span style="color:blue;">synchronized</span><span style="color:black;"> (</span><span style="color:blue;">this</span><span style="color:black;">) {<br/>                         </span><span style="color:blue;">if</span><span style="color:black;"> (cash - x &lt; 0) {<br/>                                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                                         wait(); <br/>                                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e1) {<br/>                                         e1.printStackTrace(); <br/>                                 } <br/>                         } </span><span style="color:blue;">else</span><span style="color:black;"> {<br/>                                 cash -= x;                     </span><span style="color:green;">//</span><span style="color:green;">取款</span><span style="color:black;"><br/>                                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">取款</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额为</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + cash);<br/>                         } <br/>                 } <br/>                 notifyAll();             </span><span style="color:green;">//</span><span style="color:green;">唤醒所有存款操作</span><span style="color:black;"><br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">李四存款</span><span style="color:black;">3600</span><span style="color:black;">，当前余额为</span><span style="color:black;">13600<br/> </span><span style="color:black;">王五取款</span><span style="color:black;">2700</span><span style="color:black;">，当前余额为</span><span style="color:black;">10900<br/> </span><span style="color:black;">老张存款</span><span style="color:black;">600</span><span style="color:black;">，当前余额为</span><span style="color:black;">11500<br/> </span><span style="color:black;">老牛取款</span><span style="color:black;">1300</span><span style="color:black;">，当前余额为</span><span style="color:black;">10200<br/> </span><span style="color:black;">胖子取款</span><span style="color:black;">800</span><span style="color:black;">，当前余额为</span><span style="color:black;">9400<br/> </span><span style="color:black;">张三存款</span><span style="color:black;">2000</span><span style="color:black;">，当前余额为</span><span style="color:black;">11400<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">对比以上三种方式，从控制角度上讲，第一种最灵活，第二种代码最简单，第三种容易犯错。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997786" target="_blank"></a><a name="_Toc258997483" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：新特征</span><span style="color:red;">-</span><span style="color:red;">原子量</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">所谓的原子量即操作变量的操作是</span><span style="color:black;">“</span><span style="color:black;">原子的</span><span style="color:black;">”</span><span style="color:black;">，该操作不可再分，因此是线程安全的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">为何要使用原子变量呢，原因是多个线程对单个变量操作也会引起一些问题。在</span><span style="color:black;">Java5</span><span style="color:black;">之前，可以通过</span><span style="color:black;">volatile</span><span style="color:black;">、</span><span style="color:black;">synchronized</span><span style="color:black;">关键字来解决并发访问的安全问题，但这样太麻烦。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java5</span><span style="color:black;">之后，专门提供了用来进行单变量多线程并发安全访问的工具包</span><span style="color:black;">java.util.concurrent.atomic</span><span style="color:black;">，其中的类也很简单。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面给出一个反面例子（切勿模仿）：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.atomic.AtomicLong;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：新特征</span><span style="color:green;">-</span><span style="color:green;">原子量</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-6 9:53:11 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 Runnable t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 2000);<br/>                 Runnable t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 3600);<br/>                 Runnable t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">王五</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 2700);<br/>                 Runnable t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老张</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 600);<br/>                 Runnable t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老牛</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 1300);<br/>                 Runnable t6 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">胖子</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 800);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行各个线程</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 pool.execute(t6); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyRunnable</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">static</span><span style="color:black;"> AtomicLong aLong =</span><span style="color:blue;">new</span><span style="color:black;"> AtomicLong(10000);        </span><span style="color:green;">//</span><span style="color:green;">原子量，每个线程都可以自由操作</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">操作数额</span><span style="color:black;"><br/> <br/>         MyRunnable(String name, </span><span style="color:blue;">int</span><span style="color:black;"> x) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">执行了</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + aLong.addAndGet(x));<br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">运行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">李四执行了</span><span style="color:black;">3600</span><span style="color:black;">，当前余额：</span><span style="color:black;">13600<br/> </span><span style="color:black;">王五执行了</span><span style="color:black;">2700</span><span style="color:black;">，当前余额：</span><span style="color:black;">16300<br/> </span><span style="color:black;">老张执行了</span><span style="color:black;">600</span><span style="color:black;">，当前余额：</span><span style="color:black;">16900<br/> </span><span style="color:black;">老牛执行了</span><span style="color:black;">1300</span><span style="color:black;">，当前余额：</span><span style="color:black;">18200<br/> </span><span style="color:black;">胖子执行了</span><span style="color:black;">800</span><span style="color:black;">，当前余额：</span><span style="color:black;">19000<br/> </span><span style="color:black;">张三执行了</span><span style="color:black;">2000</span><span style="color:black;">，当前余额：</span><span style="color:black;">21000<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">张三执行了</span><span style="color:black;">2000</span><span style="color:black;">，当前余额：</span><span style="color:black;">12000<br/> </span><span style="color:black;">王五执行了</span><span style="color:black;">2700</span><span style="color:black;">，当前余额：</span><span style="color:black;">18300<br/> </span><span style="color:black;">老张执行了</span><span style="color:black;">600</span><span style="color:black;">，当前余额：</span><span style="color:black;">18900<br/> </span><span style="color:black;">老牛执行了</span><span style="color:black;">1300</span><span style="color:black;">，当前余额：</span><span style="color:black;">20200<br/> </span><span style="color:black;">胖子执行了</span><span style="color:black;">800</span><span style="color:black;">，当前余额：</span><span style="color:black;">21000<br/> </span><span style="color:black;">李四执行了</span><span style="color:black;">3600</span><span style="color:black;">，当前余额：</span><span style="color:black;">15600<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">张三执行了</span><span style="color:black;">2000</span><span style="color:black;">，当前余额：</span><span style="color:black;">12000<br/> </span><span style="color:black;">李四执行了</span><span style="color:black;">3600</span><span style="color:black;">，当前余额：</span><span style="color:black;">15600<br/> </span><span style="color:black;">老张执行了</span><span style="color:black;">600</span><span style="color:black;">，当前余额：</span><span style="color:black;">18900<br/> </span><span style="color:black;">老牛执行了</span><span style="color:black;">1300</span><span style="color:black;">，当前余额：</span><span style="color:black;">20200<br/> </span><span style="color:black;">胖子执行了</span><span style="color:black;">800</span><span style="color:black;">，当前余额：</span><span style="color:black;">21000<br/> </span><span style="color:black;">王五执行了</span><span style="color:black;">2700</span><span style="color:black;">，当前余额：</span><span style="color:black;">18300<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从运行结果可以看出，虽然使用了原子量，但是程序并发访问还是有问题，那究竟问题出在哪里了？</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这里要注意的一点是，原子量虽然可以保证单个变量在某一个操作过程的安全，但无法保证你整个代码块，或者整个程序的安全性。因此，通常还应该使用锁等同步机制来控制整个程序的安全性。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">下面是对这个错误修正：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.ExecutorService;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.Executors;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.Lock;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.locks.ReentrantLock;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.atomic.AtomicLong;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：新特征</span><span style="color:green;">-</span><span style="color:green;">原子量</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-6 9:53:11 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 ExecutorService pool = Executors.newFixedThreadPool(2); <br/>                 Lock lock = </span><span style="color:blue;">new</span><span style="color:black;"> ReentrantLock(</span><span style="color:blue;">false</span><span style="color:black;">);<br/>                 Runnable t1 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">张三</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 2000,lock);<br/>                 Runnable t2 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">李四</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 3600,lock);<br/>                 Runnable t3 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">王五</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 2700,lock);<br/>                 Runnable t4 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老张</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 600,lock);<br/>                 Runnable t5 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">老牛</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 1300,lock);<br/>                 Runnable t6 = </span><span style="color:blue;">new</span><span style="color:black;"> MyRunnable(</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">胖子</span><span style="color:maroon;">&quot;</span><span style="color:black;">, 800,lock);<br/>                 </span><span style="color:green;">//</span><span style="color:green;">执行各个线程</span><span style="color:black;"><br/>                 pool.execute(t1); <br/>                 pool.execute(t2); <br/>                 pool.execute(t3); <br/>                 pool.execute(t4); <br/>                 pool.execute(t5); <br/>                 pool.execute(t6); <br/>                 </span><span style="color:green;">//</span><span style="color:green;">关闭线程池</span><span style="color:black;"><br/>                 pool.shutdown(); <br/>         } <br/> } <br/> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MyRunnable</span><span style="color:blue;">implements</span><span style="color:black;"> Runnable {<br/>         </span><span style="color:blue;">private</span><span style="color:blue;">static</span><span style="color:black;"> AtomicLong aLong =</span><span style="color:blue;">new</span><span style="color:black;"> AtomicLong(10000);        </span><span style="color:green;">//</span><span style="color:green;">原子量，每个线程都可以自由操作</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;                </span><span style="color:green;">//</span><span style="color:green;">操作人</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:blue;">int</span><span style="color:black;"> x;                            </span><span style="color:green;">//</span><span style="color:green;">操作数额</span><span style="color:black;"><br/>         </span><span style="color:blue;">private</span><span style="color:black;"> Lock lock;<br/> <br/>         MyRunnable(String name, </span><span style="color:blue;">int</span><span style="color:black;"> x,Lock lock) {<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.x = x;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.lock = lock;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 lock.lock(); <br/>                 System.out.println(name + </span><span style="color:maroon;">&quot;</span><span style="color:maroon;">执行了</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + x +</span><span style="color:maroon;">&quot;</span><span style="color:maroon;">，当前余额：</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + aLong.addAndGet(x));<br/>                 lock.unlock(); <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">执行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">张三执行了</span><span style="color:black;">2000</span><span style="color:black;">，当前余额：</span><span style="color:black;">12000<br/> </span><span style="color:black;">王五执行了</span><span style="color:black;">2700</span><span style="color:black;">，当前余额：</span><span style="color:black;">14700<br/> </span><span style="color:black;">老张执行了</span><span style="color:black;">600</span><span style="color:black;">，当前余额：</span><span style="color:black;">15300<br/> </span><span style="color:black;">老牛执行了</span><span style="color:black;">1300</span><span style="color:black;">，当前余额：</span><span style="color:black;">16600<br/> </span><span style="color:black;">胖子执行了</span><span style="color:black;">800</span><span style="color:black;">，当前余额：</span><span style="color:black;">17400<br/> </span><span style="color:black;">李四执行了</span><span style="color:black;">3600</span><span style="color:black;">，当前余额：</span><span style="color:black;">21000<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">这里使用了一个对象锁，来控制对并发代码的访问。不管运行多少次，执行次序如何，最终余额均为</span><span style="color:black;">21000</span><span style="color:black;">，这个结果是正确的。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="font-size:14px;">有关原子量的用法很简单，关键是对原子量的认识，原子仅仅是保证变量操作的原子性，但整个程序还需要考虑线程安全的。</span></p>
<h1 style="font-size:28px;font-weight:bold;"><a name="_Toc258997484" target="_blank"></a><strong><span style="color:red;">Java</span></strong><strong><span style="color:red;">线程：新特征</span><span style="color:red;">-</span><span style="color:red;">障碍器</span></strong></h1>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">Java5</span><span style="color:black;">中，添加了障碍器类，为了适应一种新的设计需求，比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，这时候，就可以选择障碍器了。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">障碍器是多线程并发控制的一种手段，用法很简单。下面给个例子：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.BrokenBarrierException;<br/> </span><span style="color:blue;">import</span><span style="color:black;"> java.util.concurrent.CyclicBarrier;<br/> <br/> </span><span style="color:green;">/** <br/> * Java</span><span style="color:green;">线程：新特征</span><span style="color:green;">-</span><span style="color:green;">障碍器</span><span style="color:green;"><br/> * <br/> * @author leizhimin 2009-11-6 10:50:10 <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">public</span><span style="color:blue;">class</span><span style="color:black;"> Test {<br/>         </span><span style="color:blue;">public</span><span style="color:blue;">static</span><span style="color:blue;">void</span><span style="color:black;"> main(String[] args) {<br/>                 </span><span style="color:green;">//</span><span style="color:green;">创建障碍器，并设置</span><span style="color:green;">MainTask</span><span style="color:green;">为所有定数量的线程都达到障碍点时候所要执行的任务</span><span style="color:green;">(Runnable)</span><span style="color:black;"><br/>                 CyclicBarrier cb = </span><span style="color:blue;">new</span><span style="color:black;"> CyclicBarrier(7,</span><span style="color:blue;">new</span><span style="color:black;"> MainTask());<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;A&quot;</span><span style="color:black;">, cb).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;B&quot;</span><span style="color:black;">, cb).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;C&quot;</span><span style="color:black;">, cb).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;D&quot;</span><span style="color:black;">, cb).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;E&quot;</span><span style="color:black;">, cb).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;F&quot;</span><span style="color:black;">, cb).start();<br/>                 </span><span style="color:blue;">new</span><span style="color:black;"> SubTask(</span><span style="color:maroon;">&quot;G&quot;</span><span style="color:black;">, cb).start();<br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">主任务</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> MainTask </span> <span style="color:blue;">implements</span><span style="color:black;"> Runnable { <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 System.out.println(</span><span style="color:maroon;">&quot;&gt;&gt;&gt;&gt;</span><span style="color:maroon;">主任务执行了！</span><span style="color:maroon;">&lt;&lt;&lt;&lt;&quot;</span><span style="color:black;">);<br/>         } <br/> } <br/> <br/> </span><span style="color:green;">/** <br/> * </span><span style="color:green;">子任务</span><span style="color:green;"> <br/> */</span><span style="color:black;"> <br/> </span><span style="color:blue;">class</span><span style="color:black;"> SubTask </span> <span style="color:blue;">extends</span><span style="color:black;"> Thread { <br/>         </span><span style="color:blue;">private</span><span style="color:black;"> String name;<br/>         </span><span style="color:blue;">private</span><span style="color:black;"> CyclicBarrier cb;<br/> <br/>         SubTask(String name, CyclicBarrier cb) { <br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.name = name;<br/>                 </span><span style="color:blue;">this</span><span style="color:black;">.cb = cb;<br/>         } <br/> <br/>         </span><span style="color:blue;">public</span><span style="color:blue;">void</span><span style="color:black;"> run() {<br/>                 System.out.println(</span><span style="color:maroon;">&quot;[</span><span style="color:maroon;">子任务</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + name +</span><span style="color:maroon;">&quot;]</span><span style="color:maroon;">开始执行了！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 </span><span style="color:blue;">for</span><span style="color:black;"> (</span><span style="color:blue;">int</span><span style="color:black;"> i = 0; i &lt; 999999; i++) ;    </span><span style="color:green;">//</span><span style="color:green;">模拟耗时的任务</span><span style="color:black;"><br/>                 System.out.println(</span><span style="color:maroon;">&quot;[</span><span style="color:maroon;">子任务</span><span style="color:maroon;">&quot;</span><span style="color:black;"> + name +</span><span style="color:maroon;">&quot;]</span><span style="color:maroon;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:maroon;">&quot;</span><span style="color:black;">);<br/>                 </span><span style="color:blue;">try</span><span style="color:black;"> {<br/>                         </span><span style="color:green;">//</span><span style="color:green;">通知障碍器已经完成</span><span style="color:black;"><br/>                         cb.await(); <br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (InterruptedException e) {<br/>                         e.printStackTrace(); <br/>                 } </span><span style="color:blue;">catch</span><span style="color:black;"> (BrokenBarrierException e) {<br/>                         e.printStackTrace(); <br/>                 } <br/>         } <br/> }</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">运行结果：</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;background:#eeeeee;"><span style="color:black;">[</span><span style="color:black;">子任务</span><span style="color:black;">E]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">E]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">F]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">G]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">F]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">G]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">C]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">B]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">C]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">D]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">A]</span><span style="color:black;">开始执行了！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">D]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">B]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> [</span><span style="color:black;">子任务</span><span style="color:black;">A]</span><span style="color:black;">开始执行完成了，并通知障碍器已经完成！</span><span style="color:black;"><br/> &gt;&gt;&gt;&gt;</span><span style="color:black;">主任务执行了！</span><span style="color:black;">&lt;&lt;&lt;&lt;<br/> <br/> Process finished with exit code 0</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;"> </span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"><span style="color:black;">从执行结果可以看出，所有子任务完成的时候，主任务执行了，达到了控制的目标。</span></p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p align="right" style="line-height:150%;margin:10px auto;text-indent:0px;">转载请标明出处<a href="http://blog.csdn.net/shimiso" style="color:#ff9900;text-decoration:none;" target="_blank"><span style="color:#0;">http://blog<span style="font-size:12px;color:#000000;">.</span>csdn.net/shimiso</span></a> </p>
<p align="right" style="line-height:150%;margin:10px auto;text-indent:0px;">欢迎有识之士加入我们的技术交流群:173711587</p>
<p align="left" style="line-height:150%;margin:10px auto;text-indent:0px;"> </p>
<p style="line-height:150%;margin:10px auto;text-indent:0px;"> </p></div></div></div></div></div></div></div></div></div><br/></span>
</div></body></html> 