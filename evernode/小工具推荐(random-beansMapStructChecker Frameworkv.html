<html>
<head>
  <title>小工具推荐(random-beans/MapStruct/Checker Framework/vjtools) - CSDN博客</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4520"/>
<h1>小工具推荐(random-beans/MapStruct/Checker Framework/vjtools) - CSDN博客</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2018/9/5 17:01</i></td></tr>
<tr><td><b>标签：</b></td><td><i>微信</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="https://blog.csdn.net/KimmKing/article/details/82391835"><i>https://blog.csdn.net/KimmKing/article/details/82391835</i></a></td></tr>
</table>
</div>
<br/>

<div><span style="margin:0px;"><div><div><div><div><a href="https://blog.csdn.net/KimmKing" target="_blank"><span>KimmKing</span></a><div><a href="https://blog.csdn.net/KimmKing/article/details/82391835###">关注</a></div></div><a href="https://blog.csdn.net/KimmKing" target="_blank"><div><span>访问量 </span><span>157万+</span><span>原创 </span><span>170</span><span>博主更多文章&gt;</span></div></a></div><div><h1><span> 原 </span> 小工具推荐(random-beans/MapStruct/Checker Framework/vjtools) </h1><div><div><div><a href="https://blog.csdn.net/KimmKing" target="_blank"><span>KimmKing</span></a><span>阅读数：188</span><span>2018-09-04</span></div></div></div><div><div><p>[TOC]</p><p> </p><p>## 小工具推荐</p><p>1. Mock Bean对象生成工具：random-beans</p><p>2. Bean属性复制：MapStruct</p><p>3. Java代码检查工具：Checker Framework</p><p>4. java相关的工具库：vjtools（唯品会出品）</p><p><br/> ### 1. Mock Bean对象生成工具：random-beans</p><p>地址：https://github.com/benas/random-beans</p><p>随机生成Pojo对象，填充字段，UnitTest利器，牛逼之处在于</p><p>1) 能处理所有常见类型，包括枚举。</p><p>2) 能处理级联对象结构，Bean里嵌套Bean这种。</p><p> </p><p>简单示例如下，90%的情况下都够用，再也不用new一个Bean，然后一顿Set属性了：</p><p>```</p><p>Person person =EnhancedRandom.random(Person.class); // one pojo</p><p>Stream&lt;Person&gt; persons = EnhancedRandom.randomStreamOf(10, Person.class); //  batch 10 pojos</p><p>```</p><p>使用EnhancedRandom实现自定义规则的bean填充：</p><p> </p><p>```</p><p>EnhancedRandom enhancedRandom = EnhancedRandomBuilder.aNewEnhancedRandom();<br/> Person person = enhancedRandom.nextObject(Person.class);<br/><br/> EnhancedRandom random = EnhancedRandomBuilder.aNewEnhancedRandomBuilder()<br/>    .seed(123L)<br/>    .objectPoolSize(100)<br/>    .randomizationDepth(3)<br/>    .charset(forName(&quot;UTF-8&quot;))<br/>    .timeRange(nine, five)<br/>    .dateRange(today, tomorrow)<br/>    .stringLengthRange(5, 50)<br/>    .collectionSizeRange(1, 10)<br/>    .scanClasspathForConcreteTypes(true)<br/>    .overrideDefaultInitialization(false)<br/>    .build();</p><p>```</p><p>更高级的定制，精确控制字段：</p><p> </p><p>```</p><p>EnhancedRandom enhancedRandom = EnhancedRandomBuilder.aNewEnhancedRandomBuilder()<br/>    .randomize(String.class, (Randomizer&lt;String&gt;) () -&gt; &quot;foo&quot;)<br/>    .exclude(field().named(&quot;age&quot;).ofType(Integer.class).inClass(Person.class).get())<br/>    .build();<br/> Person person = enhancedRandom.nextObject(Person.class);</p><p>```</p><p> </p><p> </p><p>### 2. Bean属性复制：MapStruct</p><p> </p><p>地址：http://mapstruct.org/</p><p>牛逼之处在于可以处理不同名称的属性映射，也可以处理级联关系。</p><p>参考：https://blog.csdn.net/lx_yoyo/article/details/75061614</p><p>```</p><p>...<br/> &lt;properties&gt;<br/>     &lt;!-- &lt;org.mapstruct.version&gt;1.1.0.Beta1&lt;/org.mapstruct.version&gt;--&gt;<br/>       &lt;org.mapstruct.version&gt;1.1.0.Final&lt;/org.mapstruct.version&gt;<br/> &lt;/properties&gt;<br/> ...<br/> &lt;dependencies&gt;<br/>     &lt;dependency&gt;<br/>         &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;<br/>         &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt;<br/>         &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;<br/>     &lt;/dependency&gt;<br/>      &lt;dependency&gt;<br/>             &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;<br/>             &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;<br/>             &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;<br/>         &lt;/dependency&gt;<br/>    &lt;!-- &lt;dependency&gt;<br/>             &lt;groupId&gt;junit&lt;/groupId&gt;<br/>             &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>             &lt;version&gt;4.12&lt;/version&gt;--&gt;<br/>         &lt;/dependency&gt;<br/>  &lt;/dependencies&gt;<br/> ...<br/> &lt;build&gt;<br/>     &lt;plugins&gt;<br/>         &lt;plugin&gt;<br/>             &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/>             &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br/>             &lt;version&gt;3.5.1&lt;/version&gt;<br/>             &lt;configuration&gt;<br/>                 &lt;source&gt;1.8&lt;/source&gt;<br/>                 &lt;target&gt;1.8&lt;/target&gt;<br/>                 &lt;annotationProcessorPaths&gt;<br/>                     &lt;path&gt;<br/>                         &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;<br/>                         &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;<br/>                         &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;<br/>                     &lt;/path&gt;<br/>                 &lt;/annotationProcessorPaths&gt;<br/>             &lt;/configuration&gt;<br/>         &lt;/plugin&gt;<br/>     &lt;/plugins&gt;&lt;/build&gt;<br/> ...</p><p>```</p><p>其核心原理是通过@Mapper接口和@Mapping映射关系定义，自动生成一个MapperImpl实现类，在这个实现类里做生成好了setter属性值的代码。<br/> @Mapper注解标记这个接口作为一个映射接口，并且是编译时MapStruct处理器的入口。<br/> @Mapping解决源对象和目标对象中，属性名字不同的情况。<br/> Mappers.getMapper自动生成的接口的实现可以通过Mapper的class对象获取,从而让客户端可以访问Mapper接口的实现。</p><p>```</p><p>@Mapper<br/> public interface PeopleMapper {<br/>     PeopleMapper INSTANCE = Mappers.getMapper(PeopleMapper.class);<br/>     /**<br/>      * PO转DTO<br/>      *<br/>      * @param entity PO<br/>      * @return DTO<br/>      */<br/>     @Mapping(target = &quot;phoneNumber&quot;, source = &quot;callNumber&quot;)<br/>     @Mapping(target = &quot;user.name&quot;, source = &quot;name&quot;)<br/>     @Mapping(target = &quot;user.age&quot;, source = &quot;age&quot;)<br/>     PeopleDTO entityToDTO(PeopleEntity entity);<br/>     /**<br/>      * DTO转PO<br/>      *<br/>      * @param peopleDTO DTO<br/>      * @param entity PO<br/>      */<br/>     @Mapping(target = &quot;callNumber&quot;, source = &quot;phoneNumber&quot;)<br/>     @Mapping(target = &quot;name&quot;, source = &quot;user.name&quot;)<br/>     @Mapping(target = &quot;age&quot;, source = &quot;user.age&quot;)<br/>     void updateEntityFromDto(PeopleDTO peopleDTO, @MappingTarget PeopleEntity entity);<br/> }</p><p>```</p><p> </p><p>### 3. Java代码检查工具：Checker Framework</p><p>地址：<a href="https://checkerframework.org/" rel="nofollow">https://checkerframework.org/</a></p><p>源码：<a href="https://github.com/typetools/checker-framework/" rel="nofollow">https://github.com/typetools/checker-framework/</a></p><p>内置了几十种检查规则，也可以方便的自定义检查规则。</p><p>例如空指针检查：</p><p>```</p><p>public class NullnessExample {<br/>     public static void main(String[] args) {<br/>         Object myObject = null;<br/>         System.out.println(myObject.toString());<br/>     }<br/> }</p><p>```</p><p>执行：</p><p>```</p><p>$ javacheck -processor org.checkerframework.checker.nullness.NullnessChecker NullnessExample.java</p><p>```</p><p>我们将看到：</p><p> </p><p>```</p><p>NullnessExample.java:9: error: [dereference.of.nullable] dereference of possibly-null reference myObject<br/>         System.out.println(myObject.toString());<br/>                            ^<br/> 1 error</p><p>```</p><p> </p><p>### 4. java相关的工具库：vjtools（唯品会出品）</p><p>#### Java开发相关</p><p>- standard    Java开发手册<br/> - code formatter    IDE格式化模板<br/> - sonar rule    Sonar规则定制示例</p><p>- vjkit    关于文本，集合，并发等基础功能的核心类库<br/> - vjstar    关于后端应用的性能、可用性的最佳实践</p><p>#### Java开发相关</p><p>- vjtop    观察JVM进程指标及其繁忙线程<br/> - vjmap    JMAP的分代打印版<br/> - vjdump    线上紧急收集JVM数据脚本<br/> - vjmxcli    JMX 查看工具</p><p>以vjtop为例：找出CPU最繁忙的线程</p><p>```</p><p>// 按时间区间内，线程占用的CPU排序，默认显示前10的线程，默认每10秒打印一次<br/> ./vjtop.sh &lt;PID&gt;<br/> // 按线程从启动以来的总占用CPU来排序<br/> ./vjtop.sh --totalcpu &lt;PID&gt;<br/> // 按时间区间内，线程占用的SYS CPU排序<br/> ./vjtop.sh --syscpu &lt;PID&gt;<br/> // 按线程从启动以来的总SYS CPU排序<br/> ./vjtop.sh --totalsyscpu &lt;PID&gt;</p><p>```<br/> 输出示例：</p><p>```<br/>  PID: 191082 - 17:43:12 JVM: 1.7.0_79 USER: calvin UPTIME: 2d02h<br/>  PROCESS: 685.00% cpu(28.54% of 24 core), 787 thread<br/>  MEMORY: 6626m rss, 6711m peak, 0m swap | DISK: 0B read, 13mB write<br/>  THREAD: 756 live, 749 daemon, 1212 peak, 0 new | CLASS: 15176 loaded, 161 unloaded, 0 new<br/>  HEAP: 630m/1638m eden, 5m/204m sur, 339m/2048m old<br/>  NON-HEAP: 80m/256m/512m perm, 13m/13m/240m codeCache<br/>  OFF-HEAP: 0m/0m direct(max=2048m), 0m/0m map(count=0), 756m threadStack<br/>  GC: 6/66ms/11ms ygc, 0/0ms fgc | SAFE-POINT: 6 count, 66ms time, 5ms syncTime<br/>     TID NAME STATE CPU SYSCPU TOTAL TOLSYS<br/>      23 AsyncAppender-Worker-ACCESSFILE-ASYNC WAITING 23.56% 6.68% 2.73% 0.72%<br/>     560 OSP-Server-Worker-4-5 RUNNABLE 22.58% 10.67% 1.08% 0.48%<br/>    9218 OSP-Server-Worker-4-14 RUNNABLE 22.37% 11.45% 0.84% 0.40%<br/>    8290 OSP-Server-Worker-4-10 RUNNABLE 22.36% 11.24% 0.88% 0.41%<br/>    8425 OSP-Server-Worker-4-12 RUNNABLE 22.24% 10.72% 0.98% 0.47%<br/>    8132 OSP-Server-Worker-4-9 RUNNABLE 22.00% 10.68% 0.90% 0.42%<br/>    8291 OSP-Server-Worker-4-11 RUNNABLE 21.80% 10.09% 0.89% 0.41%<br/>    8131 OSP-Server-Worker-4-8 RUNNABLE 21.68% 9.77% 0.93% 0.44%<br/>    9219 OSP-Server-Worker-4-15 RUNNABLE 21.56% 10.43% 0.90% 0.41%<br/>    8426 OSP-Server-Worker-4-13 RUNNABLE 21.35% 10.42% 0.66% 0.31%<br/>  Total : 668.56% cpu(user=473.25%, sys=195.31%) by 526 atcive threads(which cpu&gt;0.05%)<br/>  Setting: top 10 threads order by CPU, flush every 10s<br/>  Input command (h for help):</p><p>```<br/> 进程区数据解释:</p><p>```<br/> PROCESS: thread: 进程的操作系统线程数, cxtsw为主动与被动的线程上下文切换数<br/> MEMORY: rss 为 Resident Set Size, 进程实际占用的物理内存; peak为最峰值的rss; swap为进程被交换到磁盘的虚拟内存。<br/> DISK: 真正达到物理存储层的读/写的速度。<br/> THREAD: Java线程数, active为当前线程数, daemon为active线程中的daemon线程数, new为刷新周期内新创建的线程数。<br/> CLASS: loaded为当前加载的类数量，unloaded为总卸载掉的类数量，new为刷新周期内新加载的类数量。<br/> HEAP: 1.0.3版开始每一项有三个数字, 分别为1.当前使用内存, 2.当前已申请内存, 3.最大内存; 如果后两个数字相同时则合并。<br/> sur: 当前存活区的大小，注意实际有from, to 两个存活区。<br/> NON-HEAP: 数字含义同HEAP<br/> codeCache: JIT编译的二进制代码的存放区，满后将不能编译新的代码。<br/> direct: 堆外内存，三个数字含义同HEAP, 未显式设置最大内存时，约等于堆内存大小。注意新版Netty不经过JDK API所分配的堆外内存未在此统计。<br/> map: 映射文件内存，三个数字分别为1. map数量，2.当前使用内存，3.当前已申请内存，没有最大值数据。<br/> threadStack: Java线程所占的栈内存总和，但不包含VM线程。(since 1.0.3)<br/> ygc: YoungGC, 三个数字分别为次数／总停顿时间／平均停顿时间<br/> fgc: OldGC ＋ FullGC， 两个数字分别为次数／总执行时间，注意此时间仅为执行时间，非JVM停顿时间。<br/> SAFE-POINT: PerfData开启时可用，JVM真正的停顿次数及停顿时间，以及等待所有线程进入安全点所消耗的时间。<br/> ```</p><p>线程区数据解释:<br/> ```</p><p>CPU: 线程在打印间隔内使用的CPU百分比(按单个核计算)<br/> SYSCPU: 线程在打印间隔内使用的SYS CPU百分比(按单个核计算)<br/> TOTAL: 从进程启动到现在，线程的总CPU时间/进程的总CPU时间的百分比<br/> TOLSYS: 从进程启动到现在，线程的总SYS CPU时间/进程的总CPU时间的百分比</p><p>```<br/> 底部数据解释:</p><p>```<br/> 如果该线程的平均使用CPU少于单核的0.1%，这条线程将不参与排序显示，减少消耗。</p><p>```</p><p> </p><p>#### JVM优化参数</p><p>JVM参数的精髓都在这里，而且是以实例脚本的形式实现的，直接可以拿来用：</p><p><a href="https://github.com/vipshop/vjtools/blob/master/vjstar/src/main/script/jvm-options/jvm-options.sh" rel="nofollow">https://github.com/vipshop/vjtools/blob/master/vjstar/src/main/script/jvm-options/jvm-options.sh</a></p><p>脚本片段如下：</p><p>```</p><p># 启动时预申请内存<br/> MEM_OPTS=&quot;$MEM_OPTS -XX:+AlwaysPreTouch&quot;<br/> # 如果线程数较多，函数的递归较少，线程栈内存可以调小节约内存，默认1M。<br/> #MEM_OPTS=&quot;$MEM_OPTS -Xss256k&quot;<br/> # 堆外内存的最大值默认约等于堆大小，可以显式将其设小，获得一个比较清晰的内存总量预估<br/> #MEM_OPTS=&quot;$MEM_OPTS -XX:MaxDirectMemorySize=2g&quot;<br/> # 根据JMX/VJTop的观察，调整二进制代码区大小避免满了之后不能再JIT，JDK7/8，是否打开多层编译的默认值都不一样<br/> #MEM_OPTS=&quot;$MEM_OPTS -XX:ReservedCodeCacheSize=240M&quot;<br/> ## GC Options##<br/> GC_OPTS=&quot;-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly&quot;<br/> # System.gc() 使用CMS算法<br/> GC_OPTS=&quot;$GC_OPTS -XX:+ExplicitGCInvokesConcurrent&quot;<br/> # CMS中的下列阶段并发执行<br/> GC_OPTS=&quot;$GC_OPTS -XX:+ParallelRefProcEnabled -XX:+CMSParallelInitialMarkEnabled&quot;<br/> # 根据应用的对象生命周期设定，减少事实上的老生代对象在新生代停留时间，加快YGC速度<br/> GC_OPTS=&quot;$GC_OPTS -XX:MaxTenuringThreshold=3&quot;<br/> # 如果OldGen较大，加大YGC时扫描OldGen关联的卡片，加快YGC速度，默认值256较低<br/> GC_OPTS=&quot;$GC_OPTS -XX:+UnlockDiagnosticVMOptions -XX:ParGCCardsPerStrideChunk=1024&quot;<br/> # 如果JVM并不独占机器，机器上有其他较繁忙的进程在运行，将GC线程数设置得比默认值(CPU核数＊5/8 )更低以减少竞争，反而会大大加快YGC速度。<br/> # 另建议CMS GC线程数简单改为YGC线程数一半.<br/> #GC_OPTS=&quot;$GC_OPTS -XX:ParallelGCThreads=12 -XX:ConcGCThreads=6&quot;<br/> # 如果CMS GC时间很长，并且明显受新生代存活对象数量影响时打开，但会导致每次CMS GC与一次YGC连在一起执行，加大了事实上JVM停顿的时间。<br/> #GC_OPTS=&quot;$GC_OPTS -XX:+CMSScavengeBeforeRemark&quot;<br/> # 如果永久代使用不会增长，关闭CMS时ClassUnloading，降低CMS GC时出现缓慢的几率<br/> #if [[ &quot;$JAVA_VERSION&quot; &gt; &quot;1.8&quot; ]]; then     <br/> # GC_OPTS=&quot;$GC_OPTS -XX:-CMSClassUnloadingEnabled&quot;<br/> #fi</p><p>```</p></div></div><div><div><a target="_self">阅读全文</a></div></div></div><div><div><dl><a href="https://blog.csdn.net/fanxiaobin577328725/article/details/78688482" target="_self" title="Checker Framework - Eclipse插件"><h4><em>Checker</em><em>Framework</em> - Eclipse插件</h4><div><span>fanxiaobin577328725</span><span>151次阅读</span><span>12-01</span></div></a></dl><dl><a href="https://blog.csdn.net/ShareUs/article/details/50397248" target="_self" title="Android-Spelling Checker Framework"><h4>Android-Spelling <em>Checker</em><em>Framework</em></h4><div><span>ShareUs</span><span>386次阅读</span><span>12-24</span></div></a></dl><dl><a href="https://blog.csdn.net/u014175005/article/details/72792839" target="_self" title="使用Mapstruct来进行PO与VO之间的映射"><h4>使用<em>Mapstruct</em>来进行PO与VO之间的映射</h4><div><span>u014175005</span><span>5123次阅读</span><span>05-28</span></div></a></dl><dl><a href="https://blog.csdn.net/vtnews/article/details/80678533" target="_self" title="MapStruct学习笔记"><h4><em>MapStruct</em>学习笔记</h4><div><span>vtnews</span><span>414次阅读</span><span>06-14</span></div></a></dl><dl><a href="https://blog.csdn.net/chl191623691/article/details/79352339" target="_self" title="实用的Chrome插件推荐"><h4>实用的Chrome插件<em>推荐</em></h4><div><span>chl191623691</span><span>1126次阅读</span><span>02-23</span></div></a></dl><dl><a href="https://blog.csdn.net/jiangchao858/article/details/77658725" target="_self" title="MapStruct处理Java实体的高级进阶使用"><h4><em>MapStruct</em>处理Java实体的高级进阶使用</h4><div><span>jiangchao858</span><span>1909次阅读</span><span>08-28</span></div></a></dl><dl><a href="https://blog.csdn.net/lx_yoyo/article/details/75061614" target="_self" title="MapStruct实体间转换快速入门"><h4><em>MapStruct</em>实体间转换快速入门</h4><div><span>lx_yoyo</span><span>7328次阅读</span><span>07-13</span></div></a></dl><dl><a href="https://blog.csdn.net/jtf8525140/article/details/78130601" target="_self" title="MapStruct使用"><h4><em>MapStruct</em>使用</h4><div><span>jtf8525140</span><span>1541次阅读</span><span>09-29</span></div></a></dl><dl><a href="https://blog.csdn.net/u014519194/article/details/54571240" target="_self" title="关于mapstruct转换list的问题"><h4>关于<em>mapstruct</em>转换list的问题</h4><div><span>u014519194</span><span>1217次阅读</span><span>01-16</span></div></a></dl><dl><a href="https://blog.csdn.net/lu_ckid/article/details/54602057" target="_self" title="使用Mapstruct来进行实体与模型之间的映射操作"><h4>使用<em>Mapstruct</em>来进行实体与模型之间的映射操作</h4><div><span>lu_ckid</span><span>1.1万次阅读</span><span>01-18</span></div></a></dl></div></div><div><div><a href="https://blog.csdn.net/KimmKing/article/details/82391835###"><span><span></span></span><span>点赞</span><span></span></a></div><div><a href="https://blog.csdn.net/KimmKing/article/details/82391835###"><span><span></span></span><span>评论</span><span></span></a></div><div><a href="https://blog.csdn.net/KimmKing/article/details/82391835###"><span><span></span></span><span>收藏</span></a></div></div></div><div><span><span></span></span><span>文章收藏成功</span></div></div></span>
</div></body></html> 