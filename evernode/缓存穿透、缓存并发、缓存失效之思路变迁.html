<html>
<head>
  <title>缓存穿透、缓存并发、缓存失效之思路变迁</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2844"/>
<h1>缓存穿透、缓存并发、缓存失效之思路变迁</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2018/12/13 10:35</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&mid=2247484720&idx=2&sn=1bf6609004171d2e69e8f21cca154074&chksm=96cd457ca1bacc6a1fe95e1bda3818111e82066a9174dd940b6fdf9a5a96221bb0dbeb9ba6d5&scene=21#wechat_redirect"><i>https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&amp;mid=2247484720&amp;idx=2&amp;sn=1bf6609004171d2e69e8f21cca154074&amp;chksm=96cd457ca1bacc6a1fe95e1bda3818111e82066a9174dd940b6fdf9a5a96221bb0dbeb9ba6d5&amp;scene=21#wechat_redirect</i></a></td></tr>
</table>
</div>
<br/>

<div><span>
  <div>
<div style="font-size: 16px; display: inline-block; min-width: 100%;"><div style="text-size-adjust:100%;line-height:1.6;"><div style="font-family:-apple-system-font, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;color:rgb(51, 51, 51);letter-spacing:0.034em;background-color:rgb(255, 255, 255);"><div><div style="word-wrap:break-word;"><div style="background-color:rgb(255, 255, 255);"><div><div>

                
                <h2 style="margin:0px;padding:0px;font-weight:400;font-size:22px;line-height:1.4;margin-bottom:14px;">
                    
                    
                    缓存穿透、缓存并发、缓存失效之思路变迁

                                                                                </h2>
                <div style="margin:0px;padding:0px;margin-bottom:22px;line-height:20px;font-size:0px;word-wrap:break-word;word-break:break-all;position:relative;z-index:1;">
                                                                                <span style="padding:0px;margin:0px 10px 10px 0px;display:inline-block;vertical-align:middle;font-size:15px;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);color:rgba(0, 0, 0, 0.3);">
                                                小程故事多
                                            </span>
                                        
                                        <span style="padding:0px;margin:0px 10px 10px 0px;display:inline-block;vertical-align:middle;font-size:15px;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);position:relative;">
                      <a href="#" style="margin:0px;padding:0px;color:rgb(87, 107, 149);text-decoration:none;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);">
                        占小狼的博客                      </a>
                      
                    </span>


                    <em style="padding:0px;margin:0px 10px 10px 0px;display:inline-block;vertical-align:middle;font-size:15px;-webkit-tap-highlight-color:rgba(0, 0, 0, 0);color:rgba(0, 0, 0, 0.3);font-style:normal;">10月26日</em>





                </div>
                
                
                
                
                                                
                                                                
                                
                
                <div style="margin:0px;padding:0px;overflow:hidden;color:rgb(51, 51, 51);font-size:17px;word-wrap:break-word;text-align:justify;position:relative;">
                    

                    

                    
                    
                    <div style="font-family:-apple-system-font, system-ui, 'Helvetica Neue', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei UI', 'Microsoft YaHei', Arial, sans-serif;margin:0px;white-space:normal;text-align:justify;letter-spacing:0.544px;color:rgb(51, 51, 51);padding:0px;font-size:17px;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);font-size:16px;text-align:left;"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-family:&quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif;">在用缓存的时候，基本上会通用遇到以下三个问题：</strong></span><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(136, 136, 136);font-size:10px;letter-spacing:0.544px;text-align:right;"></span></p></div><ul style="margin:0px;padding:0px;padding-left:2.2em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><li style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:14px;">缓存穿透</span></p></li><li style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:14px;">缓存并发</span></p></li><li style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:14px;">缓存失效</span></p></li></ul><blockquote style="padding-top:10px;margin:0px;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;background-color:rgba(66, 185, 131, 0.1);padding-left:15px;border-left:3px solid rgb(219, 219, 219);margin-top:0.8em;margin-bottom:0.8em;padding:0px;padding-bottom:10px;color:rgb(119, 119, 119);border-left-width:4px;border-left-color:rgb(66, 185, 131);word-wrap:break-word;box-sizing:border-box;max-width:100%;white-space:normal;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">一、缓存穿透</strong></p></blockquote><div style="color:rgb(52, 73, 94);margin:0px;background-color:rgb(255, 255, 255);white-space:normal;font-size:16px;padding:0px;font-family:&quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif;word-wrap:break-word;box-sizing:border-box;max-width:100%;text-align:center;"><img src="缓存穿透、缓存并发、缓存失效之思路变迁_files/640" type="image/webp" data-filename="640" height="362" style="border-width:2px;margin:0px;width:549px !important;border-radius:6px;border-color:rgb(238, 238, 238);height:auto !important;padding:0px;border-style:solid;word-wrap:break-word;box-sizing:border-box;max-width:100%;visibility:visible !important;" title="img" width="545"/><div style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;margin-top:10px;font-size:0.7em;color:rgb(153, 153, 153);text-align:center;"><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/></div></div><div style="color:rgb(52, 73, 94);margin:0px;background-color:rgb(255, 255, 255);white-space:normal;font-size:16px;padding:0px;font-family:&quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif;word-wrap:break-word;box-sizing:border-box;max-width:100%;text-align:center;"><img src="缓存穿透、缓存并发、缓存失效之思路变迁_files/640 [1]" type="image/webp" data-filename="640" height="421" style="border-width:2px;margin:0px;width:486px !important;border-radius:6px;border-color:rgb(238, 238, 238);height:auto !important;padding:0px;border-style:solid;word-wrap:break-word;box-sizing:border-box;max-width:100%;visibility:visible !important;" title="img" width="482"/><div style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;margin-top:10px;font-size:0.7em;color:rgb(153, 153, 153);text-align:center;"><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/></div></div><div style="color:rgb(52, 73, 94);margin:0px;background-color:rgb(255, 255, 255);white-space:normal;font-size:16px;padding:0px;font-family:&quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif;word-wrap:break-word;box-sizing:border-box;max-width:100%;text-align:center;"><img src="缓存穿透、缓存并发、缓存失效之思路变迁_files/640 [2]" type="image/webp" data-filename="640" height="421" style="border-width:2px;margin:0px;width:512px !important;border-radius:6px;border-color:rgb(238, 238, 238);height:auto !important;padding:0px;border-style:solid;word-wrap:break-word;box-sizing:border-box;max-width:100%;visibility:visible !important;" title="img" width="508"/><div style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;margin-top:10px;font-size:0.7em;color:rgb(153, 153, 153);text-align:center;"><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/></div></div><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);">上面三个图会有什么问题呢？</p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">那这种问题有什么好办法解决呢？</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/>有一个比较巧妙的作法是，可以将这个不存在的key预先设定一个值。<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/>比如，&quot;key&quot; , “&amp;&amp;”。<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/>在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</span></p><blockquote style="padding-top:10px;margin:0px;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;background-color:rgba(66, 185, 131, 0.1);padding-left:15px;border-left:3px solid rgb(219, 219, 219);margin-top:0.8em;margin-bottom:0.8em;padding:0px;padding-bottom:10px;color:rgb(119, 119, 119);border-left-width:4px;border-left-color:rgb(66, 185, 131);word-wrap:break-word;box-sizing:border-box;max-width:100%;white-space:normal;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">二、缓存并发</strong></p></blockquote><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">我现在的想法是对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">这种情况和刚才说的预先设定值问题有些类似，只不过利用锁的方式，会造成部分请求等待。</span></p><blockquote style="padding-top:10px;margin:0px;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;background-color:rgba(66, 185, 131, 0.1);padding-left:15px;border-left:3px solid rgb(219, 219, 219);margin-top:0.8em;margin-bottom:0.8em;padding:0px;padding-bottom:10px;color:rgb(119, 119, 119);border-left-width:4px;border-left-color:rgb(66, 185, 131);word-wrap:break-word;box-sizing:border-box;max-width:100%;white-space:normal;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">三、缓存失效</strong></p></blockquote><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">引起这个问题的主要原因还是高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">那如何解决这些问题呢？<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/>其中的一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">我们讨论的第二个问题时针对同一个缓存，第三个问题时针对很多缓存。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">总结来看：</strong></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">1、缓存穿透：查询一个必然不存在的数据。比如文章表，查询一个不存在的id，每次都会访问DB，如果有人恶意破坏，很可能直接对DB造成影响。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">2、缓存失效：如果缓存集中在一段时间内失效，DB的压力凸显。这个没有完美解决办法，但可以分析用户行为，尽量让失效时间点均匀分布。<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/>当发生大量的缓存穿透，例如对某个失效的缓存的大并发访问就造成了缓存雪崩。</span></p><blockquote style="padding-top:10px;margin:0px;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;background-color:rgba(66, 185, 131, 0.1);padding-left:15px;border-left:3px solid rgb(219, 219, 219);margin-top:0.8em;margin-bottom:0.8em;padding:0px;padding-bottom:10px;color:rgb(119, 119, 119);border-left-width:4px;border-left-color:rgb(66, 185, 131);word-wrap:break-word;box-sizing:border-box;max-width:100%;white-space:normal;"><p style="margin:0px;padding:0px;clear:both;min-height:1em;max-width:100%;box-sizing:border-box;word-wrap:break-word;"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">四、提问汇总</strong></p></blockquote><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">1、问题1：</strong><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">如何解决DB和缓存一致性问题？<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/>答：当修改了数据库后，有没有及时修改缓存。这种问题，以前有过实践，修改数据库成功，而修改缓存失败的情况，最主要就是缓存服务器挂了。而因为网络问题引起的没有及时更新，可以通过重试机制来解决。而缓存服务器挂了，请求首先自然也就无法到达，从而直接访问到数据库。那么我们在修改数据库后，无法修改缓存，这时候可以将这条数据放到数据库中，同时启动一个异步任务定时去检测缓存服务器是否连接成功，一旦连接成功则从数据库中按顺序取出修改数据，依次进行缓存最新值的修改。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">2、问题2：</strong><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">问下缓存穿透那块！例如，一个用户查询文章，通过ID查询，按照之前说的，是将缓存的KEY预先设置一个值，，如果通过ID插过来，发现是预先设定的一个值，比如说是“&amp;&amp;”，那之后的继续等待访问是什么意思，这个ID什么时候会真正被附上用户所需要的值呢？<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">答：</strong>我刚说的主要是咱们常用的后面配置，前台获取的场景。前台无法获取相应的key，则等待，或者放弃。当在后台配置界面上配置了相关key和value之后，那么以前的key &amp;&amp;也自然会被替换掉。你说的那种情况，自然也应该会有一个进程会在某一个时刻，在缓存中设置这个ID，再有新的请求到达的时候，就会获取到最新的ID和value。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">3、问题3：</strong><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">其实用redis的话，那天看到一个不错的例子，双key，有一个当时生成的一个附属key来标识数据修改到期时间，然后快到的时候去重新加载数据，如果觉得key多可以把结束时间放到主key中，附属key起到锁的功能。<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">答：</strong>这种方案，之前我们实践过。这种方案会产生双份数据，而且需要同时控制附属key与key之间的关系，操作上有一定复杂度。</span></p><p style="margin-top:0.8em;margin:0px;white-space:normal;font-size:16px;font-family:'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;color:rgb(52, 73, 94);margin-bottom:0.8em;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">4、问题4：</strong><br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><span style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;font-size:15px;">多级缓存是什么概念呢？<br style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;"/><strong style="margin:0px;padding:0px;max-width:100%;box-sizing:border-box;word-wrap:break-word;color:rgb(0, 0, 0);">答：</strong>多级缓存就像我今天之前给大家发的文章里面提到了，将ehcache与redis做二级缓存，但同样会存在一致性问题，如果我们需要强一致性的话，缓存与数据库同步是会存在时间差的，所以我们在具体开发的过程中，一定要根据场景来具体分析，二级缓存更多的解决是，缓存穿透与程序的健壮性，当集中式缓存出现问题的时候，我们的应用能够继续运行。</span></p><p style="color:rgb(51, 51, 51);margin:0px;white-space:normal;text-align:justify;letter-spacing:0.544px;font-size:17px;font-family:-apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;padding:0px;min-height:1em;clear:both;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);"><span style="color:rgb(136, 136, 136);margin:0px;text-align:right;letter-spacing:0.544px;font-size:10px;padding:0px;font-family:-apple-system-font, system-ui, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, Arial, sans-serif;word-wrap:break-word;box-sizing:border-box;max-width:100%;background-color:rgb(255, 255, 255);">来源：https://www.jianshu.com/p/d96906140199</span></p>
                </div>
                

                
                
                
                
                

                
                                

                
                                
                
                            </div></div></div></div></div></div></div></div>
</div>
</span>
</div></body></html> 