<html>
<head>
  <title>RSS-CSDN博客推荐文章</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="9724"/>
<h1>RSS-CSDN博客推荐文章</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2016/5/26 10:56</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://blog.csdn.net/rss.html?type=column&column=chenssy-javaimpr"><i>http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimpr</i></a></td></tr>
</table>
</div>
<br/>

<div><span><div style="-evernote-webclip:true"><br/><div style="font-size: 16px"><div><div style="font-size:13px;font-family:Verdana, 宋体;">
<center>
<table cellpadding="0" cellspacing="0" style="margin-bottom:20px;" width="90%"><tbody><tr>
<td align="left" style="font-size:13px;font-family:Verdana, 宋体;">
<span style="font-size:24px;font-weight:bold;"><a href="http://blog.csdn.net/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">CSDN博客推荐文章</a></span><span style="font-size:14px;padding-left:20px;">CSDN博客内容聚合服务</span>
</td>
<td align="right" style="font-size:13px;font-family:Verdana, 宋体;"><a href="http://blog.csdn.net/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><img src="RSS-CSDN博客推荐文章_files/logo.gif" type="image/gif" data-filename="logo.gif" border="0" height="32" width="144"/></a></td>
</tr></tbody></table>
<table cellpadding="4" cellspacing="0" width="90%">
<tbody><tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/44102915" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高配（三七）—–Java集合细节（三）：subList的缺陷</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"></span></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">         我们经常使用subString方法来对String对象进行分割处理，同时我们也可以使用subList、subMap、subSet来对List、Map、Set进行分割处理，但是这个分割存在某些瑕疵。</span></p><h2 style="border-top-left-radius:6px;margin:15px 0px;line-height:35px;color:white;text-rendering:optimizelegibility;font-size:20px;font-family:'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif;border-top-right-radius:6px;padding:5px;box-shadow:rgb(51, 153, 204) 0px 0px 0px 1px, rgba(10, 10, 0, 0.498039) 1px 1px 6px 1px;text-shadow:rgb(34, 34, 34) 2px 2px 3px;background-color:rgb(51, 153, 204);">一、subList返回仅仅只是一个视图</h2><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        首先我们先看如下实例：</span></p><pre>public static void main(String[] args) {
        List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
        list1.add(1);
        list1.add(2);
        
        //通过构造函数新建一个包含list1的列表 list2
        List&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;(list1);
        
        //通过subList生成一个与list1一样的列表 list3
        List&lt;Integer&gt; list3 = list1.subList(0, list1.size());
        
        //修改list3
        list3.add(3);
        
        System.out.println(&quot;list1 == list2：&quot; + list1.equals(list2));
        System.out.println(&quot;list1 == list3：&quot; + list1.equals(list3));
    }</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        这个例子非常简单，无非就是通过构造函数、subList重新生成一个与list1一样的list，然后修改list3，最后比较list1 == list2?、list1 == list3?。按照我们常规的思路应该是这样的：因为list3通过add新增了一个元素，那么它肯定与list1不等，而list2是通过list1构造出来的，所以应该相等，所以结果应该是：</span></p><pre>list1 == list2：true
list1 == list3: false</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        首先我们先不论结果的正确与否，我们先看subList的源码：</span></p><pre>public List&lt;E&gt; subList(int fromIndex, int toIndex) {
        subListRangeCheck(fromIndex, toIndex, size);
        return new SubList(this, 0, fromIndex, toIndex);
    }</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>subListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，<strong>注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。</strong></span></p><p style="margin-top:0px;margin-bottom:15px;"></p><pre>/**
     * 继承AbstractList类，实现RandomAccess接口
     */
    private class SubList extends AbstractList&lt;E&gt; implements RandomAccess {
        private final AbstractList&lt;E&gt; parent;    //列表
        private final int parentOffset;   
        private final int offset;
        int size;

        //构造函数
        SubList(AbstractList&lt;E&gt; parent,
                int offset, int fromIndex, int toIndex) {
            this.parent = parent;
            this.parentOffset = fromIndex;
            this.offset = offset + fromIndex;
            this.size = toIndex - fromIndex;
            this.modCount = ArrayList.this.modCount;
        }

        //set方法
        public E set(int index, E e) {
            rangeCheck(index);
            checkForComodification();
            E oldValue = ArrayList.this.elementData(offset + index);
            ArrayList.this.elementData[offset + index] = e;
            return oldValue;
        }

        //get方法
        public E get(int index) {
            rangeCheck(index);
            checkForComodification();
            return ArrayList.this.elementData(offset + index);
        }

        //add方法
        public void add(int index, E e) {
            rangeCheckForAdd(index);
            checkForComodification();
            parent.add(parentOffset + index, e);
            this.modCount = parent.modCount;
            this.size++;
        }

        //remove方法
        public E remove(int index) {
            rangeCheck(index);
            checkForComodification();
            E result = parent.remove(parentOffset + index);
            this.modCount = parent.modCount;
            this.size--;
            return result;
        }
    }</pre><br/><span style="font-size:14px;">        </span><span style="font-size:14px;">该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：</span><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。</span></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。</span></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：</span></p><pre>parent.add(parentOffset + index, e);
this.modCount = parent.modCount;</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        remove方法里面的</span></p><pre>E result = parent.remove(parentOffset + index);
this.modCount = parent.modCount;</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。</span></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>那么从这里的分析我们可以得出上面的结果应该恰恰与我们上面的答案相反：</span></p><pre>list1 == list2：false
list1 == list3：true</pre><p></p><blockquote style="padding:0px;margin:10px 5px;border:2px solid rgb(239, 239, 239);box-shadow:rgb(170, 170, 170) 0px 0px 8px;font-family:verdana, Arial, Helvetica, sans-serif;clear:both;font-size:14px;color:rgb(247, 150, 70);line-height:25px;background-color:rgb(255, 255, 163);"><p style="margin-top:10px;margin-bottom:10px;font-weight:bold;line-height:20px;text-indent:2em;padding-top:0px;padding-bottom:0px;">Java细节（3.1）：subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上</p></blockquote><h2 style="text-shadow:rgb(34, 34, 34) 2px 2px 3px;margin:15px 0px;border-top-left-radius:6px;border-top-right-radius:6px;padding:5px;box-shadow:rgb(51, 153, 204) 0px 0px 0px 1px, rgba(10, 10, 0, 0.498039) 1px 1px 6px 1px;text-rendering:optimizelegibility;line-height:35px;font-size:20px;font-family:'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif;color:white;background-color:rgb(51, 153, 204);">二、subList生成子列表后，不要试图去操作原列表</h2><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;">        从上面我们知道subList生成的子列表只是原列表的一个视图而已，如果我们操作子列表它产生的作用都会在原列表上面表现，但是如果我们操作原列表会产生什么情况呢？</span></p><pre>public static void main(String[] args) {
        List&lt;Integer&gt; list1 = new ArrayList&lt;Integer&gt;();
        list1.add(1);
        list1.add(2);
        
        //通过subList生成一个与list1一样的列表 list3
        List&lt;Integer&gt; list3 = list1.subList(0, list1.size());
        //修改list3
        list1.add(3);
        
        System.out.println(&quot;list1'size：&quot; + list1.size());
        System.out.println(&quot;list3'size：&quot; + list3.size());
    }</pre><br/><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>该实例如果不产生意外，那么他们两个list的大小都应该都是3，但是偏偏事与愿违，事实上我们得到的结果是这样的：</span></p><pre>list1'size：3
Exception in thread &quot;main&quot; java.util.ConcurrentModificationException
    at java.util.ArrayList$SubList.checkForComodification(Unknown Source)
    at java.util.ArrayList$SubList.size(Unknown Source)
    at com.chenssy.test.arrayList.SubListTest.main(SubListTest.java:17)</pre><br/><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>list1正常输出，但是list3就抛出ConcurrentModificationException异常，看过我另一篇博客的同仁肯定对这个异常非常，fail-fast？不错就是fail-fast机制，在fail-fast机制中，LZ花了很多力气来讲述这个异常，所以这里LZ就不对这个异常多讲了（更多请点这里：<a href="http://cmsblogs.com/?p=1220" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="">Java提高篇（三四）—–fail-fast机制</a>）。我们再看size方法：</span></p><pre>public int size() {
            checkForComodification();
            return this.size;
        }</pre><br/><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>size方法首先会通过checkForComodification验证，然后再返回this.size。</span></p><pre>private void checkForComodification() {
            if (ArrayList.this.modCount != this.modCount)
                throw new ConcurrentModificationException();
        }</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。</span></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表：</span></p><pre>//通过subList生成一个与list1一样的列表 list3
List&lt;Integer&gt; list3 = list1.subList(0, list1.size());
        
//对list1设置为只读状态
list1 = Collections.unmodifiableList(list1);</pre><p></p><blockquote style="padding:0px;margin:10px 5px;border:2px solid rgb(239, 239, 239);box-shadow:rgb(170, 170, 170) 0px 0px 8px;font-family:verdana, Arial, Helvetica, sans-serif;clear:both;font-size:14px;color:rgb(247, 150, 70);line-height:25px;background-color:rgb(255, 255, 163);"><p style="margin-top:10px;margin-bottom:10px;font-weight:bold;line-height:20px;text-indent:2em;padding-top:0px;padding-bottom:0px;">Java细节（3.2）：生成子列表后，不要试图去操作原列表，否则会造成子列表的不稳定而产生异常</p></blockquote><h2 style="border-top-left-radius:6px;margin:15px 0px;line-height:35px;color:white;text-rendering:optimizelegibility;font-size:20px;font-family:'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif;border-top-right-radius:6px;padding:5px;box-shadow:rgb(51, 153, 204) 0px 0px 0px 1px, rgba(10, 10, 0, 0.498039) 1px 1px 6px 1px;text-shadow:rgb(34, 34, 34) 2px 2px 3px;background-color:rgb(51, 153, 204);">三、推荐使用subList处理局部列表</h2><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理：</span></p><pre>for(int i = 0 ; i &lt; list1.size() ; i++){
   if(i &gt;= 100 &amp;&amp; i &lt;= 200){
       list1.remove(i);
       /*
        * 当然这段代码存在问题，list remove之后后面的元素会填充上来，
         * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。
         */
   }
}</pre><p></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"><span style="font-size:14px;">        </span>这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定：</span></p><pre>list1.subList(100, 200).clear();</pre><p></p><p style="margin-top:0px;margin-bottom:15px;text-indent:2em;color:rgb(85, 85, 85);font-family:'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:25px;">简单而不失华丽！！！！！</p><p style="margin-top:0px;margin-bottom:15px;text-indent:2em;color:rgb(85, 85, 85);font-family:'Microsoft Yahei', 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:14px;line-height:25px;"><strong>参考资料：编写高质量代码：改善Java程序的151个建议</strong></p><p style="margin-top:0px;margin-bottom:15px;"><span style="font-size:14px;"></span></p>
<div>
    作者：chenssy 发表于2015/3/6 18:20:06 <a href="http://blog.csdn.net/chenssy/article/details/44102915" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：3040 评论：7 <a href="http://blog.csdn.net/chenssy/article/details/44102915#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/38373877" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三六）-----java集合细节（二）：asList的缺陷</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;">        在实际开发过程中我们经常使用asList讲数组转换为List，这个方法使用起来非常方便，但是asList方法存在几个缺陷：</span></p><h1><span style="font-size:18px;color:#ff0000;">一、避免使用基本数据类型数组转换为列表</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>使用8个基本类型数组转换为列表时会存在一个比较有味的缺陷。先看如下程序：</span></p><p><span style="font-size:14px;"></span></p><pre>public static void main(String[] args) {
        int[] ints = {1,2,3,4,5};
        List list = Arrays.asList(ints);
        System.out.println(&quot;list'size：&quot; + list.size());
    }
    ------------------------------------
    outPut：
    list'size：1</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码：</span></p><p><span style="font-size:14px;"></span></p><pre>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
        return new ArrayList&lt;&gt;(a);
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>asList接受的参数是一个泛型的变长参数，我们知道基本数据类型是无法发型化的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。但是这个这个实例中为什么没有出错呢？因为该实例是将int 类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。所以该例子是不会产生错误的。既然例子是将整个int 类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下：</span></p><p><span style="font-size:14px;"></span></p><pre>public static void main(String[] args) {
    int[] ints = {1,2,3,4,5};
    List list = Arrays.asList(ints);
    System.out.println(&quot;list 的类型:&quot; + list.get(0).getClass());
    System.out.println(&quot;list.get(0) == ints：&quot; + list.get(0).equals(ints));
}
--------------------------------------------
outPut:
list 的类型:class [I
list.get(0) == ints：true</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>从这个运行结果我们可以充分证明list里面的元素就是int数组。弄清楚这点了，那么修改方法也就一目了然了：将int 改变为Integer。</span></p><p><span style="font-size:14px;"></span></p><pre>public static void main(String[] args) {
        Integer[] ints = {1,2,3,4,5};
        List list = Arrays.asList(ints);
        System.out.println(&quot;list'size：&quot; + list.size());
        System.out.println(&quot;list.get(0) 的类型:&quot; + list.get(0).getClass());
        System.out.println(&quot;list.get(0) == ints[0]：&quot; + list.get(0).equals(ints[0]));
    }
    ----------------------------------------
    outPut:
    list'size：5
    list.get(0) 的类型:class java.lang.Integer
    list.get(0) == ints[0]：true</pre><p></p><p><span style="font-size:18px;color:#ff0000;"><strong>&gt;&gt;&gt;&gt;&gt;&gt;Java细节（2.1）：在使用asList时不要将基本数据类型当做参数。</strong></span></p><h1><span style="font-size:18px;color:#ff0000;">二、asList产生的列表不可操作</span></h1><p><span style="font-size:14px;">        对于上面的实例我们再做一个小小的修改：</span></p><p><span style="font-size:14px;"></span></p><pre>public static void main(String[] args) {
        Integer[] ints = {1,2,3,4,5};
        List list = Arrays.asList(ints);
        list.add(6);
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>该实例就是讲ints通过asList转换为list 类别，然后再通过add方法加一个元素，这个实例简单的不能再简单了，但是运行结果呢？打出我们所料：</span></p><p><span style="font-size:14px;"></span></p><pre>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.AbstractList.add(Unknown Source)
    at java.util.AbstractList.add(Unknown Source)
    at com.chenssy.test.arrayList.AsListTest.main(AsListTest.java:10)</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>运行结果尽然抛出UnsupportedOperationException异常，该异常表示list不支持add方法。这就让我们郁闷了，list怎么可能不支持add方法呢？难道jdk脑袋堵塞了？我们再看asList的源码：</span></p><p><span style="font-size:14px;"></span></p><pre>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
        return new ArrayList&lt;&gt;(a);
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>asList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？别急，再往下看:</span></p><p><span style="font-size:14px;"></span></p><pre>private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
    implements RandomAccess, java.io.Serializable{
        private static final long serialVersionUID = -2764017481108945198L;
        private final E[] a;

        ArrayList(E[] array) {
            if (array==null)
                throw new NullPointerException();
            a = array;
        }
        //.................
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>这是ArrayList的源码,从这里我们可以看出,此ArrayList不是java.util.ArrayList，他是Arrays的内部类。该内部类提供了size、toArray、get、set、indexOf、contains方法，而像add、remove等改变list结果的方法从AbstractList父类继承过来，同时这些方法也比较奇葩，它直接抛出UnsupportedOperationException异常：</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean add(E e) {
        add(size(), e);
        return true;
    }
    
    public E set(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }
    
    public E remove(int index) {
        throw new UnsupportedOperationException();
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。所以：</span></p><p><span style="font-size:18px;color:#ff6666;"><strong>&gt;&gt;&gt;&gt;&gt;&gt;Java细节（2.2）：不要试图改变asList返回的列表，否则你会自食苦果。</strong></span></p>
<div>
    作者：chenssy 发表于2014/8/4 19:24:29 <a href="http://blog.csdn.net/chenssy/article/details/38373877" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：2775 评论：0 <a href="http://blog.csdn.net/chenssy/article/details/38373877#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/38373833" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三五）-----Java集合细节（一）：请为集合指定初始容量</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-size:10.5pt;">        集合是我们在Java编程中使用非常广泛的，它就像大海，海纳百川，像万能容器，盛装万物，而且这个大海，万能容器还可以无限变大（如果条件允许）。当这个海、容器的量变得非常大的时候，它的初始容量就会显得很重要了，因为挖海、扩容是需要消耗大量的人力物力财力的。同样的道理，Collection的初始容量也显得异常重要。所以：</span><span style="font-size:10.5pt;margin:0px;padding:0px;">对于已知的情景，请为集合指定初始容量。</span></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-size:10.5pt;margin:0px;padding:0px;"></span></p><pre>public static void main(String[] args) {
        StudentVO student = null;
        long begin1 = System.currentTimeMillis();
        List&lt;StudentVO&gt; list1 = new ArrayList&lt;&gt;();
        for(int i = 0 ; i &lt; 1000000; i++){
            student = new StudentVO(i,&quot;chenssy_&quot;+i,i);
            list1.add(student);
        }
        long end1 = System.currentTimeMillis();
        System.out.println(&quot;list1 time：&quot; + (end1 - begin1));
        
        long begin2 = System.currentTimeMillis();
        List&lt;StudentVO&gt; list2 = new ArrayList&lt;&gt;(1000000);
        for(int i = 0 ; i &lt; 1000000; i++){
            student = new StudentVO(i,&quot;chenssy_&quot;+i,i);
            list2.add(student);
        }
        long end2 = System.currentTimeMillis();
        System.out.println(&quot;list2 time：&quot; + (end2 - begin2));
    }</pre><p></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-family:verdana;font-size:10.5pt;line-height:1.5;"></span><span style="color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25px;">        </span><span style="font-family:verdana;font-size:10.5pt;line-height:1.5;"></span><span style="font-size:10.5pt;">上面代码两个list都是插入1000000条数据，只不过list1没有没有申请初始化容量，而list2初始化容量1000000。那运行结果如下：</span></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-size:10.5pt;"></span></p><pre>list1 time：1638
list2 time：921</pre><p></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-family:verdana;font-size:10.5pt;line-height:1.5;">    </span><span style="font-family:verdana;font-size:10.5pt;line-height:1.5;">    </span><span style="font-size:10.5pt;">从上面的运行结果我们可以看出list2的速度是list1的两倍左右。在前面LZ就提过，ArrayList的扩容机制是比较消耗资源的。我们先看ArrayList的add方法：</span></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-size:10.5pt;"></span></p><pre>public boolean add(E e) {  
        ensureCapacity(size + 1);   
        elementData[size++] = e;  
        return true;  
    }  
    
    public void ensureCapacity(int minCapacity) {  
        modCount++;         //修改计数器
        int oldCapacity = elementData.length;    
        //当前需要的长度超过了数组长度，进行扩容处理
        if (minCapacity &gt; oldCapacity) {  
            Object oldData[] = elementData;  
            //新的容量 = 旧容量 * 1.5 + 1
            int newCapacity = (oldCapacity * 3)/2 + 1;  
                if (newCapacity &lt; minCapacity)  
                    newCapacity = minCapacity;  
          //数组拷贝，生成新的数组 
          elementData = Arrays.copyOf(elementData, newCapacity);  
        }  
    }</pre><p></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-family:verdana;font-size:10.5pt;line-height:1.5;">    </span><span style="font-family:verdana;font-size:10.5pt;line-height:1.5;">    </span><span style="font-size:10.5pt;">ArrayList每次新增一个元素，就会检测ArrayList的当前容量是否已经到达临界点，如果到达临界点则会扩容1.5倍。然而ArrayList的扩容以及数组的拷贝生成新的数组是相当耗资源的。所以若我们事先已知集合的使用场景，知道集合的大概范围，我们最好是指定初始化容量，这样对资源的利用会更加好，尤其是大数据量的前提下，效率的提升和资源的利用会显得更加具有优势。</span></p><p style="margin:10px auto;padding-top:0px;padding-bottom:0px;font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-family:verdana, Arial, Helvetica, sans-serif;line-height:22px;background-color:rgb(255, 255, 255);"><span style="font-size:18px;color:#ff6666;"><strong>&gt;&gt;&gt;&gt;&gt;&gt;java集合细节一：请为集合指定初始容量</strong></span></span><br/></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:15px;line-height:22px;background-color:rgb(255, 255, 255);"><span style="color:#ffcc33;"><strong><br/></strong></span></span></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"></p><p style="font-size:14px;margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;line-height:25px;"><span style="font-size:10.5pt;"></span></p><p style="margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25px;"><span style="margin:0px;padding:0px;">-----原文出自:<a href="http://cmsblogs.com/?p=1233" style="color:rgb(0, 0, 0);text-decoration:none;margin:0px;padding:0px;border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51, 51, 51);" target="_blank" title="http://cmsblogs.com/?p=1233"><span style="color:#ffc000;margin:0px;padding:0px;">http://cmsblogs.com/?p=1233</span></a></span><a href="http://cmsblogs.com/?p=1201" style="color:rgb(0, 0, 0);text-decoration:none;margin:0px;padding:0px;border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51, 51, 51);" target="_blank"><span style="margin:0px;padding:0px;"></span></a><span style="margin:0px;padding:0px;">,请尊重作者辛勤劳动成果,转载说明出处.</span></p><p style="margin:10px auto;padding-top:0px;padding-bottom:0px;color:rgb(51, 51, 51);font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;line-height:25px;"><span style="margin:0px;padding:0px;">-----个人站点:</span><a href="http://cmsblogs.com/" style="color:rgb(0, 0, 0);text-decoration:none;margin:0px;padding:0px;border-bottom-width:1px;border-bottom-style:dotted;border-bottom-color:rgb(51, 51, 51);" target="_blank"><span style="margin:0px;padding:0px;"><span style="color:#ffc000;margin:0px;padding:0px;">http://cmsblogs.com</span></span></a></p><br/>
<div>
    作者：chenssy 发表于2014/8/4 19:19:20 <a href="http://blog.csdn.net/chenssy/article/details/38373833" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：4372 评论：0 <a href="http://blog.csdn.net/chenssy/article/details/38373833#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/38151189" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三四）-----fail-fast机制</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;">        在JDK的Collection中我们时常会看到类似于这样的话：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>例如，ArrayList:</span></p><blockquote><p><span style="font-size:14px;">注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</span></p></blockquote><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>HashMap中：</span></p><blockquote><p><span style="font-size:14px;">注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</span></p></blockquote><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>“快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</span></p><h1><span style="font-size:24px;color:#ff0000;">一、fail-fast示例</span></h1><div><span style="font-size:14px;"></span><pre>public class FailFastTest {
    private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    
    /**
     * @desc:线程one迭代list
     * @Project:test
     * @file:FailFastTest.java
     * @Authro:chenssy
     * @data:2014年7月26日
     */
    private static class threadOne extends Thread{
        public void run() {
            Iterator&lt;Integer&gt; iterator = list.iterator();
            while(iterator.hasNext()){
                int i = iterator.next();
                System.out.println(&quot;ThreadOne 遍历:&quot; + i);
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    /**
     * @desc:当i == 3时，修改list
     * @Project:test
     * @file:FailFastTest.java
     * @Authro:chenssy
     * @data:2014年7月26日
     */
    private static class threadTwo extends Thread{
        public void run(){
            int i = 0 ; 
            while(i &lt; 6){
                System.out.println(&quot;ThreadTwo run：&quot; + i);
                if(i == 3){
                    list.remove(i);
                }
                i++;
            }
        }
    }
    
    public static void main(String[] args) {
        for(int i = 0 ; i &lt; 10;i++){
            list.add(i);
        }
        new threadOne().start();
        new threadTwo().start();
    }
}</pre></div><div><span style="font-size:14px;"><span style="white-space:pre;">	</span> </span><span style="font-size:14px;">运行结果：</span></div><p><span style="font-size:14px;"></span></p><pre>ThreadOne 遍历:0
ThreadTwo run：0
ThreadTwo run：1
ThreadTwo run：2
ThreadTwo run：3
ThreadTwo run：4
ThreadTwo run：5
Exception in thread &quot;Thread-0&quot; java.util.ConcurrentModificationException
    at java.util.ArrayList$Itr.checkForComodification(Unknown Source)
    at java.util.ArrayList$Itr.next(Unknown Source)
    at test.ArrayListTest$threadOne.run(ArrayListTest.java:23)</pre><p></p><h1><span style="font-size:24px;color:#ff0000;">二、fail-fast产生原因</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。</span></p><p><span style="font-size:14px;">从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码：</span></p><p><span style="font-size:14px;"></span></p><pre>private class Itr implements Iterator&lt;E&gt; {
        int cursor;
        int lastRet = -1;
        int expectedModCount = ArrayList.this.modCount;

        public boolean hasNext() {
            return (this.cursor != ArrayList.this.size);
        }

        public E next() {
            checkForComodification();
            /** 省略此处代码 */
        }

        public void remove() {
            if (this.lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();
            /** 省略此处代码 */
        }

        final void checkForComodification() {
            if (ArrayList.this.modCount == this.expectedModCount)
                return;
            throw new ConcurrentModificationException();
        }
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量：</span></p><p><span style="font-size:14px;"></span></p><pre>protected transient int modCount = 0;</pre><p></p><p><span style="font-size:14px;">那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码：</span></p><p><span style="font-size:14px;"></span></p><pre>    public boolean add(E paramE) {
        ensureCapacityInternal(this.size + 1);
        /** 省略此处代码 */
    }

    private void ensureCapacityInternal(int paramInt) {
        if (this.elementData == EMPTY_ELEMENTDATA)
            paramInt = Math.max(10, paramInt);
        ensureExplicitCapacity(paramInt);
    }
    
    private void ensureExplicitCapacity(int paramInt) {
        this.modCount += 1;    //修改modCount
        /** 省略此处代码 */
    }
    
   public boolean remove(Object paramObject) {
        int i;
        if (paramObject == null)
            for (i = 0; i &lt; this.size; ++i) {
                if (this.elementData[i] != null)
                    continue;
                fastRemove(i);
                return true;
            }
        else
            for (i = 0; i &lt; this.size; ++i) {
                if (!(paramObject.equals(this.elementData[i])))
                    continue;
                fastRemove(i);
                return true;
            }
        return false;
    }

    private void fastRemove(int paramInt) {
        this.modCount += 1;   //修改modCount
        /** 省略此处代码 */
    }

    public void clear() {
        this.modCount += 1;    //修改modCount
        /** 省略此处代码 */
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount  = N  ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。</span></p><h1><span style="font-size:24px;color:#ff0000;">三、fail-fast解决办法</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案：</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>方案一：</span></strong>在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>方案二：</span></strong>使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。 该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看：</span></p><p><span style="font-size:14px;"></span></p><pre>private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {
        /** 省略此处代码 */
        public E next() {
            if (!(hasNext()))
                throw new NoSuchElementException();
            return this.snapshot[(this.cursor++)];
        }

        /** 省略此处代码 */
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例：</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean add(E paramE) {
        ReentrantLock localReentrantLock = this.lock;
        localReentrantLock.lock();
        try {
            Object[] arrayOfObject1 = getArray();
            int i = arrayOfObject1.length;
            Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);
            arrayOfObject2[i] = paramE;
            setArray(arrayOfObject2);
            int j = 1;
            return j;
        } finally {
            localReentrantLock.unlock();
        }
    }

    
    final void setArray(Object[] paramArrayOfObject) {
        this.array = paramArrayOfObject;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码：</span></p><p><span style="font-size:14px;"></span></p><pre>Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);
arrayOfObject2[i] = paramE;
setArray(arrayOfObject2);</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>所以<strong>CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。</strong></span></p><p><span style="font-size:14px;"><strong></strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>参考文档：<a href="http://www.cnblogs.com/skywang12345/p/3308762.html#a3" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/skywang12345/p/3308762.html#a3">http://www.cnblogs.com/skywang12345/p/3308762.html#a3</a></span></p><p><span style="font-size:14px;"> </span></p><hr/><p><span style="font-size:14px;"><strong>-----原文出自:<a href="http://cmsblogs.com/?p=1220" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://cmsblogs.com/?p=1220"><span style="color:#ffc000;">http://cmsblogs.com/?p=1220</span></a></strong><a href="http://cmsblogs.com/?p=1201" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong></strong></a><strong>,请尊重作者辛勤劳动成果,转载说明出处.</strong></span></p><p><span style="font-size:14px;"><strong>-----个人站点:</strong><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong><span style="color:#ffc000;">http://cmsblogs.com</span></strong></a></span></p>
<div>
    作者：chenssy 发表于2014/7/26 22:40:44 <a href="http://blog.csdn.net/chenssy/article/details/38151189" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：10927 评论：23 <a href="http://blog.csdn.net/chenssy/article/details/38151189#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/37909815" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三三）-----Map总结</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;">        在前面LZ详细介绍了<a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">HashMap</a>、<a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">HashTable</a>、<a href="http://www.cnblogs.com/chenssy/p/3746600.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">TreeMap</a>的实现方法，从数据结构、实现原理、源码分析三个方面进行阐述，对这个三个类应该有了比较清晰的了解,下面LZ就Map做一个简单的总结。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>推荐阅读：</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><a href="http://www.cnblogs.com/chenssy/p/3521565.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二三）—–HashMap</a></span></strong></span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><a href="http://www.cnblogs.com/chenssy/p/3643886.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二五）—–HashTable</a></span></strong></span></p><p><span style="font-size:14px;"><a href="http://www.cnblogs.com/chenssy/p/3651218.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong></strong></a><strong><span style="font-size:14px;">        </span></strong><a href="http://blog.csdn.net/chenssy/article/details/23299963" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong>Java提高篇（二六）-----hashCode</strong></a></span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><a href="http://www.cnblogs.com/chenssy/p/3746600.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/26668941" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（二七）—–TreeMap</a></span></strong></span></p><h1><span style="font-size:18px;color:#FF0000;">一、Map概述</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>首先先看Map的结构示意图</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast.png" type="image/png" data-filename="SouthEast.png" alt="" height="326" width="599"/><br/></span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>Map：</span></strong>“键值”对映射的抽象接口。该映射不包括重复的键，一个键对应一个值。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>SortedMap：</span></strong>有序的键值对接口，继承Map接口。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>NavigableMap：</span></strong>继承SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法的接口。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>AbstractMap：</span></strong>实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>Dictionary：</span></strong>任何可将键映射到相应值的类的抽象父类。目前被Map接口取代。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>TreeMap：</span></strong>有序散列表，实现SortedMap 接口，底层通过红黑树实现。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>HashMap：</span></strong>是基于“拉链法”实现的散列表。底层采用“数组+链表”实现。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>WeakHashMap：</span></strong>基于“拉链法”实现的散列表。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>HashTable：</span></strong>基于“拉链法”实现的散列表。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>总结如下：</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [1].png" type="image/png" data-filename="SouthEast.png" alt="" height="556" width="700"/><br/></span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>他们之间的区别：</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [2].png" type="image/png" data-filename="SouthEast.png" alt="" height="563" width="902"/><br/></span></p><h1><span style="font-size:18px;color:#FF0000;">二、内部哈希： 哈希映射技术</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>几乎所有通用Map都使用哈希映射技术。对于我们程序员来说我们必须要对其有所了解。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>哈希映射技术是一种就元素映射到数组的非常简单的技术。由于哈希映射采用的是数组结果，那么必然存在一中用于确定任意键访问数组的索引机制，该机制能够提供一个小于数组大小的整数，我们将该机制称之为哈希函数。在Java中我们不必为寻找这样的整数而大伤脑筋，因为每个对象都必定存在一个返回整数值的hashCode方法，而我们需要做的就是将其转换为整数，然后再将该值除以数组大小取余即可。如下：</span></p><p><span style="font-size:14px;"></span></p><pre>int hashValue = Maths.abs(obj.hashCode()) % size;</pre>下面是HashMap、HashTable的：<p></p><p><span style="font-size:14px;"></span></p><pre>----------HashMap------------
//计算hash值
static int hash(int h) {
    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
}
//计算key的索引位置
static int indexFor(int h, int length) {
        return h &amp; (length-1);
}
-----HashTable--------------
int index = (hash &amp; 0x7FFFFFFF) % tab.length;     //确认该key的索引位置</pre><p></p><p><span style="font-size:14px;"> 位置的索引就代表了该节点在数组中的位置。下图是哈希映射的基本原理图：</span></p><p><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast.gif" type="image/gif" data-filename="SouthEast.gif" alt="" height="446" width="260"/></span><br/><span style="font-size:14px;">         在该图中1-4步骤是找到该元素在数组中位置，5-8步骤是将该元素插入数组中。在插入的过程中会遇到一点点小挫折。在众多肯能存在多个元素他们的hash值是一样的，这样就会得到相同的索引位置，也就说多个元素会映射到相同的位置，这个过程我们称之为“冲突”。解决冲突的办法就是在索引位置处插入一个链接列表，并简单地将元素添加到此链接列表。当然也不是简单的插入，在HashMap中的处理过程如下：获取索引位置的链表，如果该链表为null，则将该元素直接插入，否则通过比较是否存在与该key相同的key，若存在则覆盖原来key的value并返回旧值，否则将该元素保存在链头（最先保存的元素放在链尾）。下面是HashMap的put方法，该方法详细展示了计算索引位置，将元素插入到适当的位置的全部过程：</span></p><p><span style="font-size:14px;"></span></p><pre>public V put(K key, V value) {
        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因
        if (key == null)
            return putForNullKey(value);
        //计算key的hash值
        int hash = hash(key.hashCode());                 
        //计算key hash 值在 table 数组中的位置
        int i = indexFor(hash, table.length);            
        //从i出开始迭代 e,判断是否存在相同的key
        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            //判断该条链上是否有hash值相同的(key相同)
            //若存在相同，则直接覆盖value，返回旧value
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;    //旧值 = 新值
                e.value = value;
                e.recordAccess(this);
                return oldValue;     //返回旧值
            }
        }
        //修改次数增加1
        modCount++;
        //将key、value添加至i位置处
        addEntry(hash, key, value, i);
        return null;
    }

</pre><p></p><p><span style="font-size:14px;">         HashMap的put方法展示了哈希映射的基本思想，其实如果我们查看其它的Map，发现其原理都差不多！<br/></span></p><h1><span style="font-size:18px;color:#FF0000;">三、Map优化</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">         </span>首先我们这样假设，假设哈希映射的内部数组的大小只有1，所有的元素都将映射该位置（0），从而构成一条较长的链表。由于我们更新、访问都要对这条链表进行线性搜索，这样势必会降低效率。我们假设，如果存在一个非常大数组，每个位置链表处都只有一个元素，在进行访问时计算其 index 值就会获得该对象，这样做虽然会提高我们搜索的效率，但是它浪费了控件。诚然，虽然这两种方式都是极端的，但是它给我们提供了一种优化思路：<strong>使用一个较大的数组让元素能够均匀分布。</strong>在Map有两个会影响到其效率，一是容器的初始化大小、二是负载因子。</span></p><h2><span style="font-size:14px;color:#3333FF;">3.1、调整实现大小</span></h2><p><span style="font-size:14px;"><span style="font-size:14px;">         </span>在哈希映射表中，内部数组中的每个位置称作“存储桶”(bucket)，而可用的存储桶数（即内部数组的大小）称作容量 (capacity)，我们为了使Map对象能够有效地处理任意数的元素，将Map设计成可以调整自身的大小。我们知道当Map中的元素达到一定量的时候就会调整容器自身的大小，但是这个调整大小的过程其开销是非常大的。调整大小需要将原来所有的元素插入到新数组中。我们知道index = hash(key) % length。这样可能会导致原先冲突的键不在冲突，不冲突的键现在冲突的，重新计算、调整、插入的过程开销是非常大的，效率也比较低下。所以，<strong>如果我们开始知道Map的预期大小值，将Map调整的足够大，则可以大大减少甚至不需要重新调整大小，这很有可能会提高速度。</strong>下面是HashMap调整容器大小的过程，通过下面的代码我们可以看到其扩容过程的复杂性：</span></p><p><span style="font-size:14px;"></span></p><pre>void resize(int newCapacity) {
            Entry[] oldTable = table;    //原始容器
            int oldCapacity = oldTable.length;    //原始容器大小
            if (oldCapacity == MAXIMUM_CAPACITY) {     //是否超过最大值：1073741824
                threshold = Integer.MAX_VALUE;
                return;
            }

            //新的数组：大小为 oldCapacity * 2
            Entry[] newTable = new Entry[newCapacity];    
            transfer(newTable, initHashSeedAsNeeded(newCapacity));
            table = newTable;
           /*
            * 重新计算阀值 =  newCapacity * loadFactor &gt;  MAXIMUM_CAPACITY + 1 ? 
            *                         newCapacity * loadFactor :MAXIMUM_CAPACITY + 1
            */
            threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);   
        }
        
        //将元素插入到新数组中
        void transfer(Entry[] newTable, boolean rehash) {
            int newCapacity = newTable.length;
            for (Entry&lt;K,V&gt; e : table) {
                while(null != e) {
                    Entry&lt;K,V&gt; next = e.next;
                    if (rehash) {
                        e.hash = null == e.key ? 0 : hash(e.key);
                    }
                    int i = indexFor(e.hash, newCapacity);
                    e.next = newTable[i];
                    newTable[i] = e;
                    e = next;
                }
            }
        }</pre><p></p><h2><span style="font-size:14px;color:#3333FF;">3.2、负载因子</span></h2><p><span style="font-size:14px;"><span style="font-size:14px;">         </span>为了确认何时需要调整Map容器，Map使用了一个额外的参数并且粗略计算存储容器的密度。在Map调整大小之前，使用”负载因子”来指示Map将会承担的“负载量”，也就是它的负载程度，当容器中元素的数量达到了这个“负载量”，则Map将会进行扩容操作。负载因子、容量、Map大小之间的关系如下：负载因子 * 容量 &gt; map大小  -----&gt;调整Map大小。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">         </span>例如：如果负载因子大小为0.75（HashMap的默认值），默认容量为11，则 11 * 0.75 = 8.25 = 8，所以当我们容器中插入第八个元素的时候，Map就会调整大小。</span></p><p><span style="font-size:14px;">        <u>负载因子本身就是在控件和时间之间的折衷。当我使用较小的负载因子时，虽然降低了冲突的可能性，使得单个链表的长度减小了，加快了访问和更新的速度，但是它占用了更多的控件，使得数组中的大部分控件没有得到利用，元素分布比较稀疏，同时由于Map频繁的调整大小，可能会降低性能。但是如果负载因子过大，会使得元素分布比较紧凑，导致产生冲突的可能性加大，从而访问、更新速度较慢。所以我们一般推荐不更改负载因子的值，采用默认值0.75.</u></span></p><h1><span style="font-size:18px;color:#FF0000;">最后</span></h1><p><span style="font-size:14px;">        推荐阅读：</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><a href="http://www.cnblogs.com/chenssy/p/3521565.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a></span></strong></span></p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二三）—–HashMap</a></span></strong></span><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二五）—–HashTable</a></span></strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;">        </span></strong><a href="http://blog.csdn.net/chenssy/article/details/23299963" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong>Java提高篇（二六）-----hashCode</strong></a></span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/26668941" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（二七）—–TreeMap</a></span></strong></span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><a href="http://www.cnblogs.com/chenssy/p/3746600.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a></span></strong></span></p><p><span style="font-size:14px;"> </span></p><hr/><p><span style="font-size:14px;"><strong>-----原文出自:<a href="http://cmsblogs.com/?p=1212" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://cmsblogs.com/?p=1212"><span style="color:#ffc000;">http://cmsblogs.com/?p=1212</span></a>,请尊重作者辛勤劳动成果,转载说明出处.</strong></span> </p><p><span style="font-size:14px;"><strong>-----个人站点:</strong><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong><span style="color:#ffc000;">http://cmsblogs.com</span></strong></a></span></p>
<div>
    作者：chenssy 发表于2014/7/17 16:39:46 <a href="http://blog.csdn.net/chenssy/article/details/37909815" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：4748 评论：3 <a href="http://blog.csdn.net/chenssy/article/details/37909815#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/37756599" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三二）-----List总结</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;">        前面LZ已经充分介绍了有关于List接口的大部分知识，如ArrayList、LinkedList、Vector、Stack，通过这几个知识点可以对List接口有了比较深的了解了。只有通过归纳总结的知识才是你的知识。所以下面LZ就List接口做一个总结。推荐阅读： </span></p><p><span style="font-size:14px;color:#ffc000;"><a href="http://www.cnblogs.com/chenssy/p/3498468.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;"></span></span></p><span style="font-size:14px;color:#ffc000;"><span style="font-size:14px;">        </span><a href="http://www.cnblogs.com/chenssy/p/3498468.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二一）-----ArrayList</a></span><span style="font-size:14px;color:#ffc000;"> </span><p><span style="font-size:14px;color:#ffc000;"><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/18099417" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二二）-----LinkedList</a></span><span style="font-size:14px;color:#ffc000;"> </span></p><p><span style="font-size:14px;color:#ffc000;"><span style="font-size:14px;">       <a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"> </a></span><a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二九）-----Vector</a></span><span style="font-size:14px;color:#ffc000;"> </span></p><p><span style="font-size:14px;color:#ffc000;"><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/37756539" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三一）-----Stack</a></span></p><p><span style="font-size:14px;color:#ffc000;"><a href="http://www.cnblogs.com/chenssy/p/3833341.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a></span></p><h2><span style="font-size:14px;">一、List接口概述</span></h2><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>List接口，成为有序的Collection也就是序列。该接口可以对列表中的每一个元素的插入位置进行精确的控制，同时用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 下图是List接口的框架图： <br/></span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [3].png" type="image/png" data-filename="SouthEast.png" alt="" height="572" width="676"/><br/></span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>通过上面的框架图，可以对List的结构了然于心，其各个类、接口如下： </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>Collection：</span></strong>Collection 层次结构 中的根接口。它表示一组对象，这些对象也称为 collection 的元素。对于Collection而言，它不提供任何直接的实现，所有的实现全部由它的子类负责。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>AbstractCollection：</span></strong>提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。对于我们而言要实现一个不可修改的 collection，只需扩展此类，并提供 iterator 和 size 方法的实现。但要实现可修改的 collection，就必须另外重写此类的 add 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 remove 方法。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>terator：</span></strong>迭代器。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>ListIterator：</span></strong>系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>List：</span></strong>继承于Collection的接口。它代表着有序的队列。 </span></p><p><span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>AbstractList：</strong></span><span style="font-size:14px;">List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>Queue：</span></strong>队列。提供队列基本的插入、获取、检查操作。 </span></p><p><span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>Deque：</strong></span><span style="font-size:14px;">一个线性 collection，支持在两端插入和移除元素。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>AbstractSequentialList：</span></strong>提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。从某种意义上说，此类与在列表的列表迭代器上实现“随机访问”方法。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>LinkedList：</span></strong>List 接口的链接列表实现。它实现所有可选的列表操作。 </span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>ArrayList：</span></strong>List 接口的大小可变数组的实现。它实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>Vector：</span></strong>实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>Stack：</span></strong>后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。</span></p><p><span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>Enumeration：</strong></span><span style="font-size:14px;">枚举，实现了该接口的对象，它生成一系列元素，一次生成一个。连续调用 nextElement 方法将返回一系列的连续元素。</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [4].png" type="image/png" data-filename="SouthEast.png" alt="" height="422" width="825"/><br/></span></p><h2><span style="font-size:14px;">二、使用场景</span></h2><p><span style="font-size:14px;"><strong><span style="font-size:14px;">        </span>学习知识的根本目的就是使用它。</strong>每个知识点都有它的使用范围。集合也是如此，在Java中集合的家族非常庞大，每个成员都有最适合的使用场景。在刚刚接触List时，LZ就说过<strong>如果涉及到“栈”、“队列”、“链表”等操作，请优先考虑用List。</strong>至于是那个List则分如下：</span></p><p><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">        </span>1、对于需要快速插入、删除元素，则需使用LinkedList。</span> </p><p><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">        </span>2、对于需要快速访问元素，则需使用ArrayList。</span> </p><p><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">        </span>3、对于“单线程环境”或者“多线程环境，但是List仅被一个线程操作”，需要考虑使用非同步的类，如果是“多线程环境，切List可能同时被多个线程操作”，考虑使用同步的类（如Vector）。</span> </p><h3><span style="font-size:14px;">2.1ArrayList、LinkedList性能分析</span></h3><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>在List中我们使用最普遍的就是LinkedList和ArrayList，同时我们也了解了他们两者之间的使用场景和区别。</span></p><p><span style="font-size:14px;"></span></p><pre>public class ListTest {
    private static final int COUNT = 100000;
    
    private static ArrayList arrayList = new ArrayList&lt;&gt;();
    private static LinkedList linkedList = new LinkedList&lt;&gt;();
    private static Vector vector = new Vector&lt;&gt;();
    
    public static void insertToList(List list){
        long startTime = System.currentTimeMillis();

        for(int i = 0 ; i &lt; COUNT ; i++){
            list.add(0,i);
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;插入 &quot; + COUNT + &quot;元素&quot; + getName(list) + &quot;花费 &quot; + (endTime - startTime) + &quot; 毫秒&quot;);
    }
    
    public static void deleteFromList(List list){
        long startTime = System.currentTimeMillis();
        
        for(int i = 0 ; i &lt; COUNT ; i++){
            list.remove(0);
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;删除&quot; + COUNT + &quot;元素&quot; + getName(list) + &quot;花费 &quot; + (endTime - startTime) + &quot; 毫秒&quot;);
    }
    
    public static void readList(List list){
        long startTime = System.currentTimeMillis();
        
        for(int i = 0 ; i &lt; COUNT ; i++){
            list.get(i);
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;读取&quot; + COUNT + &quot;元素&quot; + getName(list) + &quot;花费 &quot; + (endTime - startTime) + &quot; 毫秒&quot;);
    }

    private static String getName(List list) {
        String name = &quot;&quot;;
        if(list instanceof ArrayList){
            name = &quot;ArrayList&quot;;
        }
        else if(list instanceof LinkedList){
            name = &quot;LinkedList&quot;;
        }
        else if(list instanceof Vector){
            name = &quot;Vector&quot;;
        }
        return name;
    }
    
    public static void main(String[] args) {
        insertToList(arrayList);
        insertToList(linkedList);
        insertToList(vector);
        
        System.out.println(&quot;--------------------------------------&quot;);
        
        readList(arrayList);
        readList(linkedList);
        readList(vector);
        
        System.out.println(&quot;--------------------------------------&quot;);
        
        deleteFromList(arrayList);
        deleteFromList(linkedList);
        deleteFromList(vector);
    }
}</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>运行结果:</span></p><p><span style="font-size:14px;"></span></p><pre>插入 100000元素ArrayList花费 3900 毫秒
插入 100000元素LinkedList花费 15 毫秒
插入 100000元素Vector花费 3933 毫秒
--------------------------------------
读取100000元素ArrayList花费 0 毫秒
读取100000元素LinkedList花费 8877 毫秒
读取100000元素Vector花费 16 毫秒
--------------------------------------
删除100000元素ArrayList花费 4618 毫秒
删除100000元素LinkedList花费 16 毫秒
删除100000元素Vector花费 4759 毫秒</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>从上面的运行结果我们可以清晰的看出ArrayList、LinkedList、Vector增加、删除、遍历的效率问题。下面我就插入方法add(int index, E element),delete、get方法各位如有兴趣可以研究研究。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>首先我们先看三者之间的源码：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>ArrayList</span></p><p><span style="font-size:14px;"></span></p><pre>public void add(int index, E element) {
        rangeCheckForAdd(index);   //检查是否index是否合法

        ensureCapacityInternal(size + 1);  //扩容操作
        System.arraycopy(elementData, index, elementData, index + 1, size - index);    //数组拷贝
        elementData[index] = element;   //插入
        size++;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>rangeCheckForAdd、ensureCapacityInternal两个方法没有什么影响，真正产生影响的是System.arraycopy方法，该方法是个JNI函数，是在JVM中实现的。声明如下：</span></p><p><span style="font-size:14px;"></span></p><pre>public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length);</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>目前LZ无法看到源码，具体的实现不是很清楚，不过<a href="http://gutspot.com/2011/11/16/system-arraycopy%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">System.arraycopy源码分析</a>对其进行了比较清晰的分析。但事实上我们只需要了解该方法会移动index后面的所有元素即可，这就意味着ArrayList的add(int index, E element)方法会引起index位置之后所有元素的改变，这真是牵一处而动全身。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>LinkedList  <br/></span></p><p><span style="font-size:14px;"></span></p><pre>public void add(int index, E element) {
        checkPositionIndex(index);

        if (index == size)     //插入位置在末尾
            linkLast(element);
        else                   
            linkBefore(element, node(index));
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>该方法比较简单，插入位置在末尾则调用linkLast方法，否则调用linkBefore方法，其实linkLast、linkBefore都是非常简单的实现，就是在index位置插入元素，至于index具体为知则有node方法来解决，同时node对index位置检索还有一个加速作用，如下：</span></p><p></p><pre>Node&lt;E&gt; node(int index) {
        if (index &lt; (size &gt;&gt; 1)) {    //如果index 小于 size/2 则从头开始查找
            Node&lt;E&gt; x = first;
            for (int i = 0; i &lt; index; i++)
                x = x.next;
            return x;
        } else {   //如果index 大于 size/2 则从尾部开始查找
            Node&lt;E&gt; x = last;
            for (int i = size - 1; i &gt; index; i--)
                x = x.prev;
            return x;
        }
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>所以linkedList的插入动作比ArrayList动作快就在于两个方面。1：linkedList不需要执行元素拷贝动作，没有牵一发而动全身的大动作。2:查找插入位置有加速动作即：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 </span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector的实现机制和ArrayList一样，同样是使用动态数组来实现的，所以他们两者之间的效率差不多，add的源码也一样，如下：</span></p><p><span style="font-size:14px;"></span></p><pre>public void add(int index, E element) {
        insertElementAt(element, index);
    }
    
    public synchronized void insertElementAt(E obj, int index) {
        modCount++;
        if (index &gt; elementCount) {
            throw new ArrayIndexOutOfBoundsException(index
                                                     + &quot; &gt; &quot; + elementCount);
        }
        ensureCapacityHelper(elementCount + 1);
        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
        elementData[index] = obj;
        elementCount++;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>上面是针对ArrayList、LinkedList、Vector三者之间的add（int index,E element)方法的解释，解释了LinkedList的插入动作要比ArrayList、Vector的插入动作效率为什么要高出这么多！至于delete、get两个方法LZ就不多解释了。</span></p><p><span style="font-size:14px;"><u><span style="font-size:14px;">        </span>同时LZ在写上面那个例子时发现了一个非常有趣的现象，就是linkedList在某些时候执行add方法时比ArrayList方法会更慢！至于在什么情况？为什么会慢LZ下篇博客解释，当然不知道这个情况各位是否也遇到过？？</u></span></p><h3><span style="font-size:14px;">2.2、Vector和ArrayList的区别</span></h3><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [5].png" type="image/png" data-filename="SouthEast.png" alt="" height="491" width="799"/><br/></p><h2><span style="font-size:14px;"><span style="font-size:14px;">        </span>四、更多</span></h2><p><span style="font-size:14px;color:#ffc000;"><a href="http://www.cnblogs.com/chenssy/p/3498468.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">        </span><a href="http://www.cnblogs.com/chenssy/p/3498468.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二一）-----ArrayList</a></span><span style="font-size:14px;color:#ffc000;"> </span></p><p><span style="font-size:14px;color:#ffc000;"><a href="http://www.cnblogs.com/chenssy/p/3514524.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/18099417" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二二）-----LinkedList</a></span><span style="font-size:14px;color:#ffc000;"> </span></p><p><span style="font-size:14px;color:#ffc000;"><a href="http://www.cnblogs.com/chenssy/p/3802826.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">       <a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"> </a></span><a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二九）-----Vector</a></span><span style="font-size:14px;color:#ffc000;"> </span></p><p><span style="font-size:14px;color:#ffc000;"><a href="http://www.cnblogs.com/chenssy/p/3833341.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a><span style="font-size:14px;">        </span><a href="http://blog.csdn.net/chenssy/article/details/37756539" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三一）-----Stack</a></span></p><hr/><span style="font-size:14px;"><strong>-----原文出自:</strong><a href="http://cmsblogs.com/?p=1201" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://cmsblogs.com/?p=1201"><strong><span style="color:#ffc000;">http://cmsblogs.com/?p=1201</span></strong></a><strong>,请尊重作者辛勤劳动成果,转载说明出处.</strong> </span><p><span style="font-size:14px;"><strong>-----个人站点:</strong><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong><span style="color:#ffc000;">http://cmsblogs.com</span></strong></a></span></p>
<div>
    作者：chenssy 发表于2014/7/14 10:18:13 <a href="http://blog.csdn.net/chenssy/article/details/37756599" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：2913 评论：3 <a href="http://blog.csdn.net/chenssy/article/details/37756599#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/37756539" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（三一）-----Stack</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;">        在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下：</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [6].png" type="image/png" data-filename="SouthEast.png" alt="" height="354" width="857"/><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下：</span></p><table border="1" cellpadding="0" cellspacing="0" width="600"><tbody><tr><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="163"><span style="font-size:14px;">            <strong><span style="color:#0000ff;">操作</span></strong></span></td><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="437"><span style="font-size:14px;">                                        <strong> <span style="color:#0000ff;"> 说明</span></strong></span></td></tr><tr><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="163"><p align="center"><span style="font-size:14px;"><code><strong>empty</strong>()</code></span></p></td><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="437"><p align="left"><span style="font-size:14px;">测试堆栈是否为空。</span></p></td></tr><tr><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="163"><p align="center"><span style="font-size:14px;"><code><strong>peek</strong>()</code></span></p></td><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="437"><p align="left"><span style="font-size:14px;">查看堆栈顶部的对象，但不从堆栈中移除它。</span></p></td></tr><tr><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="163"><p align="center"><span style="font-size:14px;"><code><strong>pop</strong>()</code></span></p></td><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="437"><p align="left"><span style="font-size:14px;">移除堆栈顶部的对象，并作为此函数的值返回该对象。</span></p></td></tr><tr><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="163"><p align="center"><span style="font-size:14px;"><code><strong>push</strong>(E item)</code></span></p></td><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="437"><p align="left"><span style="font-size:14px;">把项压入堆栈顶部。</span></p></td></tr><tr><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="163"><p align="center"><span style="font-size:14px;"><code><strong>search</strong>(Object o)</code></span></p></td><td style="font-size:13px;font-family:Verdana, 宋体;" valign="top" width="437"><p align="left"><span style="font-size:14px;">返回对象在堆栈中的位置，以 1 为基数。</span></p></td></tr></tbody></table><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Stack继承Vector，他对Vector进行了简单的扩展：</span></p><p><span style="font-size:14px;"></span></p><pre>public class Stack&lt;E&gt; extends Vector&lt;E&gt;</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Stack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单</span></p><p><span style="font-size:14px;"></span></p><pre>/**
     * 构造函数
     */
    public Stack() {
    }

    /**
     *  push函数：将元素存入栈顶
     */
    public E push(E item) {
        // 将元素存入栈顶。
        // addElement()的实现在Vector.java中
        addElement(item);

        return item;
    }

    /**
     * pop函数：返回栈顶元素，并将其从栈中删除
     */
    public synchronized E pop() {
        E    obj;
        int    len = size();

        obj = peek();
        // 删除栈顶元素，removeElementAt()的实现在Vector.java中
        removeElementAt(len - 1);

        return obj;
    }

    /**
     * peek函数：返回栈顶元素，不执行删除操作
     */
    public synchronized E peek() {
        int    len = size();

        if (len == 0)
            throw new EmptyStackException();
        // 返回栈顶元素，elementAt()具体实现在Vector.java中
        return elementAt(len - 1);
    }

    /**
     * 栈是否为空
     */
    public boolean empty() {
        return size() == 0;
    }

    /**
     *  查找“元素o”在栈中的位置：由栈底向栈顶方向数
     */
    public synchronized int search(Object o) {
        // 获取元素索引，elementAt()具体实现在Vector.java中
        int i = lastIndexOf(o);

        if (i &gt;= 0) {
            return size() - i;
        }
        return -1;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Stack的源码很多都是基于Vector，所以这里不再累述，更多详情请参考：<a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（二九）-----Vector</a></span></p>
<div>
    作者：chenssy 发表于2014/7/14 10:11:21 <a href="http://blog.csdn.net/chenssy/article/details/37756539" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：3574 评论：1 <a href="http://blog.csdn.net/chenssy/article/details/37756539#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/37521461" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（三十）-----Iterator</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;"><span style="font-size:14px;">        </span>迭代对于我们搞Java的来说绝对不陌生。我们常常使用JDK提供的迭代接口进行Java集合的迭代。</span></p><p><span style="font-size:14px;"></span></p><pre>Iterator iterator = list.iterator();
        while(iterator.hasNext()){
            String string = iterator.next();
            //do something
        }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>迭代其实我们可以简单地理解为遍历，是一个标准化遍历各类容器里面的所有对象的方法类，它是一个很典型的设计模式。Iterator模式是用于遍历集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 在没有迭代器时我们都是这么进行处理的。如下：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于数组我们是使用下标来进行处理的:</span></p><p><span style="font-size:14px;"></span></p><pre>int[] arrays = new int[10];
for(int i = 0 ; i &lt; arrays.length ; i++){
       int a = arrays[i];
       //do something
   }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于ArrayList是这么处理的:</span></p><p><span style="font-size:14px;"></span></p><pre>List&lt;String&gt; list = new ArrayList&lt;String&gt;();
   for(int i = 0 ; i &lt; list.size() ;  i++){
      String string = list.get(i);
      //do something
   }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于这两种方式，我们总是都事先知道集合的内部结构，访问代码和集合本身是紧密耦合的，无法将访问逻辑从集合类和客户端代码中分离出来。同时每一种集合对应一种遍历方法，客户端代码无法复用。 在实际应用中如何需要将上面将两个集合进行整合是相当麻烦的。所以为了解决以上问题，Iterator模式腾空出世，它总是用同一种逻辑来遍历集合。使得客户端自身不需要来维护集合的内部结构，所有的内部状态都由Iterator来维护。客户端从不直接和集合类打交道，它总是控制Iterator，向它发送&quot;向前&quot;，&quot;向后&quot;，&quot;取当前元素&quot;的命令，就可以间接遍历整个集合。 </span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>上面只是对Iterator模式进行简单的说明，下面我们看看Java中Iterator接口，看他是如何来进行实现的。</span></p><h1><span style="font-size:18px;color:#FF0000;">一、java.util.Iterator</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>在Java中Iterator为一个接口，它只提供了迭代了基本规则，在JDK中他是这样定义的：对 collection 进行迭代的迭代器。迭代器取代了 Java Collections Framework 中的 Enumeration。迭代器与枚举有两点不同： </span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>1、迭代器允许调用者利用定义良好的语义在迭代期间从迭代器所指向的 collection 移除元素。 </span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>2、方法名称得到了改进。 </span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>其接口定义如下：</span></p><p><span style="font-size:14px;"></span></p><pre>public interface Iterator {
　　boolean hasNext();
　　Object next();
　　void remove();
}</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>其中：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Object next()：返回迭代器刚越过的元素的引用，返回值是Object，需要强制转换成自己需要的类型</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>boolean hasNext()：判断容器内是否还有可供访问的元素</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>void remove()：删除迭代器刚越过的元素</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于我们而言，我们只一般只需使用next()、hasNext()两个方法即可完成迭代。如下：</span></p><p><span style="font-size:14px;"></span></p><pre>for(Iterator it = c.iterator(); it.hasNext(); ) {
　　Object o = it.next();
　　 //do something
}</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>前面阐述了Iterator有一个很大的优点,就是我们不必知道集合的内部结果,集合的内部结构、状态由Iterator来维持，通过统一的方法hasNext()、next()来判断、获取下一个元素，至于具体的内部实现我们就不用关心了。<strong>但是作为一个合格的程序员我们非常有必要来弄清楚Iterator的实现。</strong>下面就ArrayList的源码进行分析分析。</span></p><h1><span style="font-size:18px;color:#FF0000;">二、各个集合的Iterator的实现</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>下面就ArrayList的Iterator实现来分析，其实如果我们理解了ArrayList、Hashset、TreeSet的数据结构，内部实现，对于他们是如何实现Iterator也会胸有成竹的。因为ArrayList的内部实现采用数组，所以我们只需要记录相应位置的索引即可，其方法的实现比较简单。</span></p><h2><span style="font-size:14px;color:#3366FF;">2.1、ArrayList的Iterator实现</span></h2><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>在ArrayList内部首先是定义一个内部类Itr，该内部类实现Iterator接口，如下：</span></p><p><span style="font-size:14px;"></span></p><pre>private class Itr implements Iterator&lt;E&gt; {
    //do something
}</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>而ArrayList的iterator()方法实现：</span></p><p><span style="font-size:14px;"></span></p><pre>public Iterator&lt;E&gt; iterator() {
        return new Itr();
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>所以通过使用ArrayList.iterator()方法返回的是Itr()内部类，所以现在我们需要关心的就是Itr()内部类的实现：</span></p><p><span style="font-size:14px;">在Itr内部定义了三个int型的变量：cursor、lastRet、expectedModCount。其中cursor表示下一个元素的索引位置，lastRet表示上一个元素的索引位置</span></p><p><span style="font-size:14px;"></span></p><pre>int cursor;             
int lastRet = -1;     
int expectedModCount = modCount;</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>从cursor、lastRet定义可以看出，lastRet一直比cursor少一所以hasNext()实现方法异常简单，只需要判断cursor和lastRet是否相等即可。</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean hasNext() {
    return cursor != size;
}</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于next()实现其实也是比较简单的，只要返回cursor索引位置处的元素即可，然后修改cursor、lastRet即可，</span></p><p><span style="font-size:14px;"></span></p><pre>public E next() {
            checkForComodification();
            int i = cursor;    //记录索引位置
            if (i &gt;= size)    //如果获取元素大于集合元素个数，则抛出异常
                throw new NoSuchElementException();
            Object[] elementData = ArrayList.this.elementData;
            if (i &gt;= elementData.length)
                throw new ConcurrentModificationException();
            cursor = i + 1;      //cursor + 1
            return (E) elementData[lastRet = i];  //lastRet + 1 且返回cursor处元素
        }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>checkForComodification()主要用来判断集合的修改次数是否合法，即用来判断遍历过程中集合是否被修改过。在<a href="http://cmsblogs.com/?p=108" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二一）-----ArrayList</a>中已经阐述了。modCount用于记录ArrayList集合的修改次数，初始化为0，，每当集合被修改一次（结构上面的修改，内部update不算），如add、remove等方法，modCount + 1，所以如果modCount不变，则表示集合内容没有被修改。该机制主要是用于实现ArrayList集合的快速失败机制，在Java的集合中，较大一部分集合是存在快速失败机制的，这里就不多说，后面会讲到。所以要保证在遍历过程中不出错误，我们就应该保证在遍历过程中不会对集合产生结构上的修改（当然remove方法除外），出现了异常错误，我们就应该认真检查程序是否出错而不是catch后不做处理。</span></p><p><span style="font-size:14px;"></span></p><pre>       final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于remove()方法的是实现，它是调用ArrayList本身的remove()方法删除lastRet位置元素，然后修改modCount即可。</span></p><p><span style="font-size:14px;"></span></p><pre>public void remove() {
            if (lastRet &lt; 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }</pre><p></p><p><span style="font-size:14px;">        这里就对ArrayList的Iterator实现讲解到这里，对于Hashset、TreeSet等集合的Iterator实现，各位如果感兴趣可以继续研究，个人认为在研究这些集合的源码之前，有必要对该集合的数据结构有清晰的认识，这样会达到事半功倍的效果！！！！</span></p><p><span style="font-size:14px;"><span style="color:#FF0000;"><strong>—————————————————————————————————————————————————————————</strong></span><br/><span style="font-size:14px;">--      <span style="font-size:18px;">原文出自：<a href="http://cmsblogs.com/?p=1185" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#FF6600;">http://cmsblogs.com/?p=1180</span></a>。尊重作者的成果，转载请注明出处！ </span>                           <br/><br/>--     <span style="font-size:18px;">个人站点：<span style="color:#FF6600;"><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com   </a> </span></span><span style="color:#FF6600;">  <br/></span></span><br/></span></p>
<div>
    作者：chenssy 发表于2014/7/7 17:33:47 <a href="http://blog.csdn.net/chenssy/article/details/37521461" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：18407 评论：6 <a href="http://blog.csdn.net/chenssy/article/details/37521461#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二九）-----Vector</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;"><span style="font-size:14px;">        </span>在<a href="http://www.cnblogs.com/chenssy/p/3498468.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二一）—–ArrayList</a>、<a href="http://blog.csdn.net/chenssy/article/details/18099417" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二二）—LinkedList</a>，详细讲解了ArrayList、linkedList的原理和实现过程，对于List接口这里还介绍一个它的实现类Vector，Vector 类可以实现可增长的对象数组。</span></p><h1><span style="font-size:18px;color:#FF0000;">一、Vector简介</span></h1><p><span style="font-size:14px;">        Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。</span></p><p><span style="font-size:14px;"></span></p><pre>public class Vector&lt;E&gt;
    extends AbstractList&lt;E&gt;
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector提供了四个构造函数：</span></p><p><span style="font-size:14px;"></span></p><pre>/**
     * 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。
     */
     public Vector() {
            this(10);
     }
    
    /**
     * 构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。
     */
    public Vector(Collection&lt;? extends E&gt; c) {
        elementData = c.toArray();
        elementCount = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, elementCount,
                    Object[].class);
    }
    
    /**
     * 使用指定的初始容量和等于零的容量增量构造一个空向量。
     */
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
    
    /**
     *  使用指定的初始容量和容量增量构造一个空的向量。
     */
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }</pre><p></p><p><span style="font-family:Courier New;font-size:14px;"><span style="font-size:14px;">        </span>在成员变量方面，Vector提供了elementData , elementCount， capacityIncrement三个成员变量。其中</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>elementData ：&quot;Object[]类型的数组&quot;，它保存了Vector中的元素。按照Vector的设计elementData为一个动态数组，可以随着元素的增加而动态的增长，其具体的增加方式后面提到（ensureCapacity方法）。如果在初始化Vector时没有指定容器大小，则使用默认大小为10.</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>elementCount：<code>Vector</code> 对象中的有效组件数。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>同时Vector是线程安全的！</span></p><h1><span style="font-size:18px;color:#FF0000;">二、源码解析</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于源码的解析，LZ在这里只就增加（add）删除（remove）两个方法进行讲解。</span></p><h2><span style="font-size:14px;color:#3366FF;">2.1增加：add(E e)</span></h2><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>add(E e)：将指定元素添加到此向量的末尾。</span></p><p><span style="font-size:14px;"></span></p><pre>public synchronized boolean add(E e) {
        modCount++;     
        ensureCapacityHelper(elementCount + 1);    //确认容器大小，如果操作容量则扩容操作
        elementData[elementCount++] = e;   //将e元素添加至末尾
        return true;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>这个方法相对而言比较简单，具体过程就是先确认容器的大小，看是否需要进行扩容操作，然后将E元素添加到此向量的末尾。</span></p><p><span style="font-size:14px;"></span></p><pre>private void ensureCapacityHelper(int minCapacity) {
        //如果
        if (minCapacity - elementData.length &gt; 0)
            grow(minCapacity);
    }
    
    /**
     * 进行扩容操作
     * 如果此向量的当前容量小于minCapacity，则通过将其内部数组替换为一个较大的数组俩增加其容量。
     * 新数据数组的大小姜维原来的大小 + capacityIncrement，
     * 除非 capacityIncrement 的值小于等于零，在后一种情况下，新的容量将为原来容量的两倍，不过，如果此大小仍然小于 minCapacity，则新容量将为 minCapacity。
     */
    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;     //当前容器大小
        /*
         * 新容器大小
         * 若容量增量系数(capacityIncrement) &gt; 0，则将容器大小增加到capacityIncrement
         * 否则将容量增加一倍
         */
        int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?
                                         capacityIncrement : oldCapacity);
        
        if (newCapacity - minCapacity &lt; 0)
            newCapacity = minCapacity;
        
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
    
    /**
     * 判断是否超出最大范围
     * MAX_ARRAY_SIZE：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
     */
    private static int hugeCapacity(int minCapacity) {
        if (minCapacity &lt; 0)
            throw new OutOfMemoryError();
        return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;
    }</pre><br/><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>对于Vector整个的扩容过程，就是根据capacityIncrement确认扩容大小的，若capacityIncrement &lt;= 0 则扩大一倍，否则扩大至capacityIncrement 。当然这个容量的最大范围为Integer.MAX_VALUE即，2^32 - 1，所以Vector并不是可以无限扩充的。</span></p><h2><span style="font-size:18px;color:#3366FF;">2.2、remove(Object o)</span></h2><p></p><pre>/**
     * 从Vector容器中移除指定元素E
     */
    public boolean remove(Object o) {
        return removeElement(o);
    }

    public synchronized boolean removeElement(Object obj) {
        modCount++;
        int i = indexOf(obj);   //计算obj在Vector容器中位置
        if (i &gt;= 0) {
            removeElementAt(i);   //移除
            return true;
        }
        return false;
    }
    
    public synchronized void removeElementAt(int index) {
        modCount++;     //修改次数+1
        if (index &gt;= elementCount) {   //删除位置大于容器有效大小
            throw new ArrayIndexOutOfBoundsException(index + &quot; &gt;= &quot; + elementCount);
        }
        else if (index &lt; 0) {    //位置小于 &lt; 0
            throw new ArrayIndexOutOfBoundsException(index);
        }
        int j = elementCount - index - 1;
        if (j &gt; 0) {   
            //从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。
            //也就是数组元素从j位置往前移
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        elementCount--;   //容器中有效组件个数 - 1
        elementData[elementCount] = null;    //将向量的末尾位置设置为null
    }</pre><br/><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>因为Vector底层是使用数组实现的，所以它的操作都是对数组进行操作，只不过其是可以随着元素的增加而动态的改变容量大小，其实现方法是是使用Arrays.copyOf方法将旧数据拷贝到一个新的大容量数组中。Vector的整个内部实现都比较简单，这里就不在重述了。</span></p><h1><span style="font-size:18px;color:#FF0000;">三、Vector遍历</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>Vector支持4种遍历方式。</span></p><h2><span style="font-size:14px;color:#3366FF;">3.1、<strong>随机访问</strong></span></h2><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>因为Vector实现了RandmoAccess接口，可以通过下标来进行随机访问。</span></p><p><span style="font-size:14px;"></span></p><pre>for(int i = 0 ; i &lt; vec.size() ; i++){
        value = vec.get(i);
    }</pre><br/><p></p><h2><span style="font-size:14px;color:#3366FF;">3.2、迭代器</span></h2><p></p><pre>Iterator it = vec.iterator();
    while(it.hasNext()){
        value = it.next();
        //do something
    }</pre><p></p><h2><span style="font-size:14px;color:#3366FF;">3.2、for循环</span></h2><p></p><pre>for(Integer value:vec){
        //do something
    }</pre><p></p><h2><span style="font-size:14px;color:#3366FF;">3.4、<strong>Enumeration循环</strong></span></h2><p></p><pre>Vector vec = new Vector&lt;&gt;();
    Enumeration enu = vec.elements();
    while (enu.hasMoreElements()) {
        value = (Integer)enu.nextElement();
    }</pre><span style="color:#FF0000;"><strong>——————————————————————————————————————————————————————————————————————————</strong></span><br/><span style="font-size:14px;">--      <span style="font-size:18px;">原文出自：<span style="color:#FF6600;"><a href="http://cmsblogs.com/?p=1180" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=1180</a><a href="http://cmsblogs.com/?p=1031" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a></span>。尊重作者的成果，转载请注明出处！ </span>                           <br/><br/>--     <span style="font-size:18px;">个人站点：<span style="color:#FF6600;"><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com   </a> </span></span><span style="color:#FF6600;">   </span>  <br/></span><br/><p></p>
<div>
    作者：chenssy 发表于2014/7/7 17:08:13 <a href="http://blog.csdn.net/chenssy/article/details/37520981" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：4288 评论：2 <a href="http://blog.csdn.net/chenssy/article/details/37520981#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/29218799" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（二八）------TreeSet</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p>与HashSet是基于HashMap实现一样，TreeSet同样是基于TreeMap实现的。在《Java提高篇（二七）-----TreeMap》中LZ详细讲解了TreeMap实现机制，如果客官详情看了这篇博文或者多TreeMap有比较详细的了解，那么TreeSet的实现对您是喝口水那么简单。</p>  <h2>一、TreeSet定义</h2>  <p>我们知道TreeMap是一个有序的二叉树，那么同理TreeSet同样也是一个有序的，它的作用是提供有序的Set集合。通过源码我们知道TreeSet基础AbstractSet，实现NavigableSet、Cloneable、Serializable接口。其中AbstractSet提供 <tt>Set</tt> 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。NavigableSet是扩展的 <code>SortedSet</code>，具有了为给定搜索目标报告最接近匹配项的导航方法，这就意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。Cloneable支持克隆，Serializable支持序列化。</p>  <div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">   <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">class</span> TreeSet&lt;E&gt; <span style="color:#00ff;">extends</span> AbstractSet&lt;E&gt;
    <span style="color:#00ff;">implements</span> NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable</pre></div><p>同时在TreeSet中定义了如下几个变量。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">private</span> <span style="color:#00ff;">transient</span> NavigableMap&lt;E,Object&gt;<span style="color:#000000;"> m;
        
</span><span style="color:#0800;">//</span><span style="color:#0800;">PRESENT会被当做Map的value与key构建成键值对</span>
 <span style="color:#00ff;">private</span> <span style="color:#00ff;">static</span> <span style="color:#00ff;">final</span> Object PRESENT = <span style="color:#00ff;">new</span> Object();</pre></div><p>其构造方法：</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#0800;">//</span><span style="color:#0800;">默认构造方法，根据其元素的自然顺序进行排序</span>
    <span style="color:#00ff;">public</span><span style="color:#000000;"> TreeSet() {
        </span><span style="color:#00ff;">this</span>(<span style="color:#00ff;">new</span> TreeMap&lt;E,Object&gt;<span style="color:#000000;">());
    }
    
    </span><span style="color:#0800;">//</span><span style="color:#0800;">构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。</span>
    <span style="color:#00ff;">public</span> TreeSet(Comparator&lt;? <span style="color:#00ff;">super</span> E&gt;<span style="color:#000000;"> comparator) {
            </span><span style="color:#00ff;">this</span>(<span style="color:#00ff;">new</span> TreeMap&lt;&gt;<span style="color:#000000;">(comparator));
    }
    
    </span><span style="color:#0800;">//</span><span style="color:#0800;">构造一个新的空 TreeSet，它根据指定比较器进行排序。</span>
    <span style="color:#00ff;">public</span> TreeSet(Collection&lt;? <span style="color:#00ff;">extends</span> E&gt;<span style="color:#000000;"> c) {
        </span><span style="color:#00ff;">this</span><span style="color:#000000;">();
        addAll(c);
    }
    
    </span><span style="color:#0800;">//</span><span style="color:#0800;">构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。</span>
    <span style="color:#00ff;">public</span> TreeSet(SortedSet&lt;E&gt;<span style="color:#000000;"> s) {
        </span><span style="color:#00ff;">this</span><span style="color:#000000;">(s.comparator());
        addAll(s);
    }
    
    TreeSet(NavigableMap</span>&lt;E,Object&gt;<span style="color:#000000;"> m) {
        </span><span style="color:#00ff;">this</span>.m =<span style="color:#000000;"> m;
    }</span></pre></div><h2>二、TreeSet主要方法</h2><p><strong>1、</strong>add：将指定的元素添加到此 set（如果该元素尚未存在于 set 中）。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">boolean</span><span style="color:#000000;"> add(E e) {
        </span><span style="color:#00ff;">return</span> m.put(e, PRESENT)==<span style="color:#00ff;">null</span><span style="color:#000000;">;
    }</span></pre></div><p><strong>2、</strong>addAll：将指定 collection 中的所有元素添加到此 set 中。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span>  <span style="color:#00ff;">boolean</span> addAll(Collection&lt;? <span style="color:#00ff;">extends</span> E&gt;<span style="color:#000000;"> c) {
        </span><span style="color:#0800;">//</span><span style="color:#0800;"> Use linear-time version if applicable</span>
        <span style="color:#00ff;">if</span> (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp;<span style="color:#000000;">
            c </span><span style="color:#00ff;">instanceof</span> SortedSet &amp;&amp;<span style="color:#000000;">
            m </span><span style="color:#00ff;">instanceof</span><span style="color:#000000;"> TreeMap) {
            SortedSet</span>&lt;? <span style="color:#00ff;">extends</span> E&gt; set = (SortedSet&lt;? <span style="color:#00ff;">extends</span> E&gt;<span style="color:#000000;">) c;
            TreeMap</span>&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;<span style="color:#000000;">) m;
            Comparator</span>&lt;? <span style="color:#00ff;">super</span> E&gt; cc = (Comparator&lt;? <span style="color:#00ff;">super</span> E&gt;<span style="color:#000000;">) set.comparator();
            Comparator</span>&lt;? <span style="color:#00ff;">super</span> E&gt; mc =<span style="color:#000000;"> map.comparator();
            </span><span style="color:#00ff;">if</span> (cc==mc || (cc != <span style="color:#00ff;">null</span> &amp;&amp;<span style="color:#000000;"> cc.equals(mc))) {
                map.addAllForTreeSet(set, PRESENT);
                </span><span style="color:#00ff;">return</span> <span style="color:#00ff;">true</span><span style="color:#000000;">;
            }
        }
        </span><span style="color:#00ff;">return</span> <span style="color:#00ff;">super</span><span style="color:#000000;">.addAll(c);
    }</span></pre></div><p><strong>3、</strong>ceiling：返回此 set 中大于等于给定元素的最小元素；如果不存在这样的元素，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E ceiling(E e) {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.ceilingKey(e);
    }</span></pre></div><p><strong>4、</strong>clear：移除此 set 中的所有元素。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">void</span><span style="color:#000000;"> clear() {
        m.clear();
    }</span></pre></div><p>5、clone：返回 TreeSet 实例的浅表副本。属于浅拷贝。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> Object clone() {
        TreeSet</span>&lt;E&gt; clone = <span style="color:#00ff;">null</span><span style="color:#000000;">;
        </span><span style="color:#00ff;">try</span><span style="color:#000000;"> {
            clone </span>= (TreeSet&lt;E&gt;) <span style="color:#00ff;">super</span><span style="color:#000000;">.clone();
        } </span><span style="color:#00ff;">catch</span><span style="color:#000000;"> (CloneNotSupportedException e) {
            </span><span style="color:#00ff;">throw</span> <span style="color:#00ff;">new</span><span style="color:#000000;"> InternalError();
        }

        clone.m </span>= <span style="color:#00ff;">new</span> TreeMap&lt;&gt;<span style="color:#000000;">(m);
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> clone;
    }</span></pre></div><p>6、comparator：返回对此 set 中的元素进行排序的比较器；如果此 set 使用其元素的<a href="http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprmk:@MSITStore:G:%5CmyYunFile%5C????????????%5Cjdk6.ZH_cn.chm::/j2se6/api/java/lang/Comparable.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">自然顺序</a>，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> Comparator&lt;? <span style="color:#00ff;">super</span> E&gt;<span style="color:#000000;"> comparator() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.comparator();
    }</span></pre></div><p>7、contains：如果此 set 包含指定的元素，则返回 true。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">boolean</span><span style="color:#000000;"> contains(Object o) {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.containsKey(o);
    }</span></pre></div><p>8、descendingIterator：返回在此 set 元素上按降序进行迭代的迭代器。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> Iterator&lt;E&gt;<span style="color:#000000;"> descendingIterator() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.descendingKeySet().iterator();
    }</span></pre></div><p>9、descendingSet：返回此 set 中所包含元素的逆序视图。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> NavigableSet&lt;E&gt;<span style="color:#000000;"> descendingSet() {
        </span><span style="color:#00ff;">return</span> <span style="color:#00ff;">new</span> TreeSet&lt;&gt;<span style="color:#000000;">(m.descendingMap());
    }</span></pre></div><p>10、first：返回此 set 中当前第一个（最低）元素。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E first() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.firstKey();
    }</span></pre></div><p>11、floor：返回此 set 中小于等于给定元素的最大元素；如果不存在这样的元素，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E floor(E e) {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.floorKey(e);
    }</span></pre></div><p>12、headSet：返回此 set 的部分视图，其元素严格小于 toElement。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> SortedSet&lt;E&gt;<span style="color:#000000;"> headSet(E toElement) {
        </span><span style="color:#00ff;">return</span> headSet(toElement, <span style="color:#00ff;">false</span><span style="color:#000000;">);
    }</span></pre></div><p>13、higher：返回此 set 中严格大于给定元素的最小元素；如果不存在这样的元素，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E higher(E e) {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.higherKey(e);
    }</span></pre></div><p>14、isEmpty：如果此 set 不包含任何元素，则返回 true。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">boolean</span><span style="color:#000000;"> isEmpty() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.isEmpty();
    }</span></pre></div><p>15、iterator：返回在此 set 中的元素上按升序进行迭代的迭代器。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> Iterator&lt;E&gt;<span style="color:#000000;"> iterator() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.navigableKeySet().iterator();
    }</span></pre></div><p>16、last：返回此 set 中当前最后一个（最高）元素。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E last() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.lastKey();
    }</span></pre></div><p>17、lower：返回此 set 中严格小于给定元素的最大元素；如果不存在这样的元素，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E lower(E e) {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.lowerKey(e);
    }</span></pre></div><p>18、pollFirst：获取并移除第一个（最低）元素；如果此 set 为空，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E pollFirst() {
        Map.Entry</span>&lt;E,?&gt; e =<span style="color:#000000;"> m.pollFirstEntry();
        </span><span style="color:#00ff;">return</span> (e == <span style="color:#00ff;">null</span>) ? <span style="color:#00ff;">null</span><span style="color:#000000;"> : e.getKey();
    }</span></pre></div><p>19、pollLast：获取并移除最后一个（最高）元素；如果此 set 为空，则返回 null。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span><span style="color:#000000;"> E pollLast() {
        Map.Entry</span>&lt;E,?&gt; e =<span style="color:#000000;"> m.pollLastEntry();
        </span><span style="color:#00ff;">return</span> (e == <span style="color:#00ff;">null</span>) ? <span style="color:#00ff;">null</span><span style="color:#000000;"> : e.getKey();
    }</span></pre></div><p>20、remove：将指定的元素从 set 中移除（如果该元素存在于此 set 中）。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">boolean</span><span style="color:#000000;"> remove(Object o) {
        </span><span style="color:#00ff;">return</span> m.remove(o)==<span style="color:#000000;">PRESENT;
    }</span></pre></div><p>21、size：返回 set 中的元素数（set 的容量）。</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#00ff;">public</span> <span style="color:#00ff;">int</span><span style="color:#000000;"> size() {
        </span><span style="color:#00ff;">return</span><span style="color:#000000;"> m.size();
    }</span></pre></div><p>22、subSet：返回此 set 的部分视图</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#0800;">/**</span><span style="color:#0800;">
     * 返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。
     </span><span style="color:#0800;">*/</span>
     <span style="color:#00ff;">public</span> NavigableSet&lt;E&gt; subSet(E fromElement, <span style="color:#00ff;">boolean</span><span style="color:#000000;"> fromInclusive,
             E toElement,   </span><span style="color:#00ff;">boolean</span><span style="color:#000000;"> toInclusive) {
             </span><span style="color:#00ff;">return</span> <span style="color:#00ff;">new</span> TreeSet&lt;&gt;<span style="color:#000000;">(m.subMap(fromElement, fromInclusive,
                  toElement,   toInclusive));
     }
     
     </span><span style="color:#0800;">/**</span><span style="color:#0800;">
      * 返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。
      </span><span style="color:#0800;">*/</span>
     <span style="color:#00ff;">public</span> SortedSet&lt;E&gt;<span style="color:#000000;"> subSet(E fromElement, E toElement) {
         </span><span style="color:#00ff;">return</span> subSet(fromElement, <span style="color:#00ff;">true</span>, toElement, <span style="color:#00ff;">false</span><span style="color:#000000;">);
     }</span></pre></div><p>23、tailSet：返回此 set 的部分视图</p><div style="border-bottom:rgb(204,204,204) 1px solid;border-left:rgb(204,204,204) 1px solid;padding-bottom:5px;background-color:rgb(245,245,245);padding-left:5px;padding-right:5px;border-top:rgb(204,204,204) 1px solid;border-right:rgb(204,204,204) 1px solid;padding-top:5px;">  <pre><span style="color:#0800;">/**</span><span style="color:#0800;">
     * 返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。
     </span><span style="color:#0800;">*/</span>
    <span style="color:#00ff;">public</span> NavigableSet&lt;E&gt; tailSet(E fromElement, <span style="color:#00ff;">boolean</span><span style="color:#000000;"> inclusive) {
        </span><span style="color:#00ff;">return</span> <span style="color:#00ff;">new</span> TreeSet&lt;&gt;<span style="color:#000000;">(m.tailMap(fromElement, inclusive));
    }
    
    </span><span style="color:#0800;">/**</span><span style="color:#0800;">
     * 返回此 set 的部分视图，其元素大于等于 fromElement。
     </span><span style="color:#0800;">*/</span>
    <span style="color:#00ff;">public</span> SortedSet&lt;E&gt;<span style="color:#000000;"> tailSet(E fromElement) {
        </span><span style="color:#00ff;">return</span> tailSet(fromElement, <span style="color:#00ff;">true</span><span style="color:#000000;">);
    }</span></pre></div><h2>三、最后</h2><p>由于TreeSet是基于TreeMap实现的，所以如果我们对treeMap有了一定的了解，对TreeSet那是小菜一碟，我们从TreeSet中的源码可以看出，其实现过程非常简单，几乎所有的方法实现全部都是基于TreeMap的。</p>
<div>
    作者：chenssy 发表于2014/6/7 19:03:01 <a href="http://blog.csdn.net/chenssy/article/details/29218799" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：2052 评论：0 <a href="http://blog.csdn.net/chenssy/article/details/29218799#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/26668941" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（二七）-----TreeMap</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;"></span></p><p><span style="font-size:14px;color:#3366FF;">       原文出自：<a href="http://cmsblogs.com/?p=1013" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=1013</a><a href="http://cmsblogs.com/?p=631" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a>。尊重作者的成果，转载请注明出处！</span><span style="font-size:14px;">   <br/></span></p><p><span style="font-size:14px;color:#3366FF;">       个人站点：<a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com</a></span></p><span style="font-size:14px;"><span style="color:#3333FF;">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- </span></span><br/><p><span style="font-size:14px;"> TreeMap的实现是红黑树算法的实现，所以要了解TreeMap就必须对红黑树有一定的了解,其实这篇博文的名字叫做：根据红黑树的算法来分析TreeMap的实现，但是为了与Java提高篇系列博文保持一致还是叫做TreeMap比较好。通过这篇博文你可以获得如下知识点：</span></p><p><span style="font-size:14px;">       1、红黑树的基本概念。</span></p><p><span style="font-size:14px;">       2、红黑树增加节点、删除节点的实现过程。</span></p><p><span style="font-size:14px;">       3、红黑树左旋转、右旋转的复杂过程。</span></p><p><span style="font-size:14px;">       4、Java 中TreeMap是如何通过put、deleteEntry两个来实现红黑树增加、删除节点的。</span></p><p><span style="font-size:14px;">我想通过这篇博文你对TreeMap一定有了更深的认识。好了，下面先简单普及红黑树知识。</span></p><p><span style="font-size:14px;"><br/></span></p><h1><span style="font-size:18px;color:#FF0000;">       一、红黑树简介</span></h1><p><span style="font-size:14px;">       红黑树又称红-黑二叉树，它首先是一颗二叉树，它具体二叉树所有的特性。同时红黑树更是一颗自平衡的排序二叉树。</span></p><p><span style="font-size:14px;">       我们知道一颗基本的二叉树他们都需要满足一个基本性质--即树中的任何节点的值大于它的左子节点，且小于它的右子节点。按照这个基本性质使得树的检索效率大大提高。我们知道在生成二叉树的过程是非常容易失衡的，最坏的情况就是一边倒（只有右/左子树），这样势必会导致二叉树的检索效率大大降低（O(n)），所以为了维持二叉树的平衡，大牛们提出了各种实现的算法，如：<a href="http://baike.baidu.com/view/414610.htm" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">AVL</a>，<a href="http://baike.baidu.com/view/2957252.htm" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">SBT</a>，<a href="http://baike.baidu.com/view/1118088.htm" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">伸展树</a>，<a href="http://baike.baidu.com/view/956602.htm" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">TREAP</a> ，<a href="http://baike.baidu.com/view/133754.htm?fr=aladdin#1_1" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">红黑树</a>等等。</span></p><p><span style="font-size:14px;">       平衡二叉树必须具备如下特性：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。也就是说该二叉树的任何一个等等子节点，其左右子树的高度都相近。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [7].png" type="image/png" data-filename="SouthEast.png" alt="" height="276" width="692"/><br/></p><p><span style="font-size:14px;">       红黑树顾名思义就是节点是红色或者黑色的平衡二叉树，它通过颜色的约束来维持着二叉树的平衡。对于一棵有效的红黑树二叉树而言我们必须增加如下规则：</span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span>1、每个节点都只能是红色或者黑色</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、根节点是黑色</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、每个叶节点（NIL节点，空节点）是黑色的。</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这棵树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。所以红黑树它是复杂而高效的，其检索效率O(log <em>n</em>)。下图为一颗典型的红黑二叉树。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [8].png" type="image/png" data-filename="SouthEast.png" alt="" height="217" width="450"/><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对于红黑二叉树而言它主要包括三大基本操作：左旋、右旋、着色。</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [1].gif" type="image/gif" data-filename="SouthEast.gif" alt="" height="241" width="329"/><img src="RSS-CSDN博客推荐文章_files/SouthEast [2].gif" type="image/gif" data-filename="SouthEast.gif" alt="" height="258" width="301"/><br/></span></p><p align="center"><span style="font-size:14px;">左旋                                   右旋</span></p><p><span style="font-size:14px;">（图片来自：<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html</a>）</span></p><hr/><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>本节参考文献：<a href="http://baike.baidu.com/view/133754.htm?fr=aladdin" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://baike.baidu.com/view/133754.htm?fr=aladdin">http://baike.baidu.com/view/133754.htm?fr=aladdin</a>-----百度百科</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>注：</span></strong>由于本文主要是讲解Java中TreeMap，所以并没有对红黑树进行非常深入的了解和研究，如果诸位想对其进行更加深入的研究Lz提供几篇较好的博文：</span></p><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1<span style="color:#ffc000;">、</span><a href="http://blog.csdn.net/v_JULY_v/article/category/774945" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#ffc000;">红黑树系列集锦</span></a></span></strong></span></p><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、</span></strong><a href="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong><span style="color:#ffc000;">红黑树数据结构剖析</span></strong></a></span></p><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、</span></strong><a href="http://blog.csdn.net/eric491179912/article/details/6179908" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong><span style="color:#ffc000;">红黑树 <br/></span></strong></a></span></p><p><span style="font-size:14px;"><a href="http://blog.csdn.net/eric491179912/article/details/6179908" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong><span style="color:#ffc000;"><br/></span></strong></a></span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#FF0000;"><strong>       </strong>二、TreeMap数据结构</span></span></h1><p><span style="font-size:14px;"><strong><span style="color:#f3a447;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>&gt;&gt;&gt;&gt;&gt;&gt;回归主角：TreeMap&lt;&lt;&lt;&lt;&lt;&lt;</span></strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>TreeMap的定义如下：</span></p><div style="padding:5px;border:1px solid rgb(204, 204, 204);background-color:rgb(245, 245, 245);"><pre><span style="font-size:14px;color:#00ff;">public</span><span style="font-size:14px;"> <span style="color:#00ff;">class</span> TreeMap&lt;K,V&gt;
    <span style="color:#00ff;">extends</span> AbstractMap&lt;K,V&gt;
    <span style="color:#00ff;">implements</span> NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</span></pre></div><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>TreeMap继承AbstractMap，实现NavigableMap、Cloneable、Serializable三个接口。其中AbstractMap表明TreeMap为一个Map即支持key-value的集合， NavigableMap（<a href="http://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">更多</a>）则意味着它支持一系列的导航方法，具备针对给定搜索目标返回最接近匹配项的导航方法 。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>TreeMap中同时也包含了如下几个重要的属性：</span></p><div style="padding:5px;border:1px solid rgb(204, 204, 204);background-color:rgb(245, 245, 245);"><pre><span style="font-size:14px;color:#0800;">//</span><span style="font-size:14px;color:#0800;">比较器，因为TreeMap是有序的，通过comparator接口我们可以对TreeMap的内部排序进行精密的控制</span><span style="font-size:14px;">
        <span style="color:#00ff;">private</span> <span style="color:#00ff;">final</span> Comparator&lt;? <span style="color:#00ff;">super</span> K&gt;<span style="color:#000000;"> comparator;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">TreeMap红-黑节点，为TreeMap的内部类</span>
        <span style="color:#00ff;">private</span> <span style="color:#00ff;">transient</span> Entry&lt;K,V&gt; root = <span style="color:#00ff;">null</span><span style="color:#000000;">;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">容器大小</span>
        <span style="color:#00ff;">private</span> <span style="color:#00ff;">transient</span> <span style="color:#00ff;">int</span> size = 0<span style="color:#000000;">;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">TreeMap修改次数</span>
        <span style="color:#00ff;">private</span> <span style="color:#00ff;">transient</span> <span style="color:#00ff;">int</span> modCount = 0<span style="color:#000000;">;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">红黑树的节点颜色--红色</span>
        <span style="color:#00ff;">private</span> <span style="color:#00ff;">static</span> <span style="color:#00ff;">final</span> <span style="color:#00ff;">boolean</span> RED = <span style="color:#00ff;">false</span><span style="color:#000000;">;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">红黑树的节点颜色--黑色</span>
        <span style="color:#00ff;">private</span> <span style="color:#00ff;">static</span> <span style="color:#00ff;">final</span> <span style="color:#00ff;">boolean</span> BLACK = <span style="color:#00ff;">true</span>;</span></pre></div><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对于叶子节点Entry是TreeMap的内部类，它有几个重要的属性：</span></p><div style="padding:5px;border:1px solid rgb(204, 204, 204);background-color:rgb(245, 245, 245);"><pre><span style="font-size:14px;color:#0800;">//</span><span style="font-size:14px;color:#0800;">键</span><span style="font-size:14px;">
<span style="color:#000000;">        K key;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">值</span>
<span style="color:#000000;">        V value;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">左孩子</span>
        Entry&lt;K,V&gt; left = <span style="color:#00ff;">null</span><span style="color:#000000;">;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">右孩子</span>
        Entry&lt;K,V&gt; right = <span style="color:#00ff;">null</span><span style="color:#000000;">;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">父亲</span>
        Entry&lt;K,V&gt;<span style="color:#000000;"> parent;
        </span><span style="color:#0800;">//</span><span style="color:#0800;">颜色</span>
        <span style="color:#00ff;">boolean</span> color = BLACK;</span></pre></div><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>注：</span></strong>前面只是开胃菜，下面是本篇博文的重中之重，在下面两节我将重点讲解treeMap的put()、delete()方法。通过这两个方法我们会了解红黑树增加、删除节点的核心算法。</span></p><p><span style="font-size:14px;"><br/></span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#FF0000;"><strong>       </strong>三、TreeMap put()方法</span></span></h1><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>在了解TreeMap的put()方法之前，我们先了解红黑树增加节点的算法。</span></p><h2><span style="font-size:14px;"><span style="font-size:14px;color:#3366FF;"><strong><span style="font-size:14px;">       </span></strong></span><span style="color:#3366FF;">红黑树增加节点</span></span></h2><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>红黑树在新增节点过程中比较复杂，复杂归复杂它同样必须要依据上面提到的五点规范，同时由于规则1、2、3基本都会满足，下面我们主要讨论规则4、5。假设我们这里有一棵最简单的树，我们规定新增的节点为N、它的父节点为P、P的兄弟节点为U、P的父节点为G。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [9].png" type="image/png" data-filename="SouthEast.png" alt="" height="106" width="189"/><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对于新节点的插入有如下三个关键地方：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、插入新节点总是红色节点 。</span><span style="font-size:14px;"><br/></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、如果插入节点的父节点是黑色, 能维持性质 。</span><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、如果插入节点的父节点是红色, 破坏了性质. 故插入算法就是通过重新着色或旋转, 来维持性质 。<br/></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>为了保证下面的阐述更加清晰和根据便于参考，我这里将红黑树的五点规定再贴一遍：<strong><br/></strong></span></p><p><span style="font-size:14px;"><strong>1、每个节点都只能是红色或者黑色</strong></span></p><p><span style="font-size:14px;"><strong>2、根节点是黑色</strong></span></p><p><span style="font-size:14px;"><strong>3、每个叶节点（NIL节点，空节点）是黑色的。</strong></span></p><p><span style="font-size:14px;"><strong>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</strong></span></p><p><span style="font-size:14px;"><strong>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></span></p><p><span style="font-size:14px;"><strong><br/></strong></span></p><div><li><br/></li><li><span style="font-size:14px;"><strong><span style="color:#f79646;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>一、为跟节点</span></strong></span></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>若新插入的节点N没有父节点，则直接当做根据节点插入即可，同时将颜色设置为黑色。（如图一（1））</span></p><p><span style="font-size:14px;"><strong><span style="color:#f79646;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>二、父节点为黑色</span></strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这种情况新节点N同样是直接插入，同时颜色为红色，由于根据规则四它会存在两个黑色的叶子节点，值为null。同时由于新增节点N为红色，所以通过它的子节点的路径依然会保存着相同的黑色节点数，同样满足规则5。（如图一（2））</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [10].png" type="image/png" data-filename="SouthEast.png" alt="" height="176" width="374"/><br/></p><p align="center"><span style="font-size:14px;">（图一）</span></p><p><span style="font-size:14px;"><strong><span style="color:#f79646;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>三、若父节点P和P的兄弟节点U都为红色</span></strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对于这种情况若直接插入肯定会出现不平衡现象。怎么处理？P、U节点变黑、G节点变红。这时由于经过节点P、U的路径都必须经过G所以在这些路径上面的黑节点数目还是相同的。但是经过上面的处理，可能G节点的父节点也是红色，这个时候我们需要将G节点当做新增节点递归处理。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [11].png" type="image/png" data-filename="SouthEast.png" alt="" height="252" width="761"/><br/></p><h3><span style="font-size:14px;color:#f79646;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>四、若父节点P为红色，叔父节点U为黑色或者缺少，且新增节点N为P节点的右孩子</span></h3><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对于这种情况我们对新增节点N、P进行一次左旋转。这里所产生的结果其实并没有完成，还不是平衡的（违反了规则四），这是我们需要进行情况5的操作。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [12].png" type="image/png" data-filename="SouthEast.png" alt="" height="258" width="723"/><br/></p></li><li><p><span style="font-size:14px;color:#f79646;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>五、父节点P为红色，叔父节点U为黑色或者缺少，新增节点N为父节点P左孩子</span></p></li><li><br/></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这种情况有可能是由于情况四而产生的，也有可能不是。对于这种情况先已P节点为中心进行右旋转，在旋转后产生的树中，节点P是节点N、G的父节点。但是这棵树并不规范，它违反了规则4，所以我们将P、G节点的颜色进行交换，使之其满足规范。开始时所有的路径都需要经过G其他们的黑色节点数一样，但是现在所有的路径改为经过P，且P为整棵树的唯一黑色节点，所以调整后的树同样满足规范5。</span></p></li><div align="center"><li><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [13].png" type="image/png" data-filename="SouthEast.png" alt="" height="179" width="795"/><br/></span></li></div><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>上面展示了红黑树新增节点的五种情况，这五种情况涵盖了所有的新增可能，不管这棵红黑树多么复杂，都可以根据这五种情况来进行生成。下面就来分析Java中的TreeMap是如何来实现红黑树的。</span></p></li><li><p><br/></p><h2><span style="font-size:14px;"><span style="font-size:14px;color:#3366FF;"><strong><span style="font-size:14px;">       </span></strong></span><span style="color:#3366FF;">TreeMap put()方法实现分析</span></span></h2><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>在TreeMap的put()的实现方法中主要分为两个步骤，第一：构建排序二叉树，第二：平衡二叉树。</span></p></li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对于排序二叉树的创建，其添加节点的过程如下：</span></p><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、以根节点为初始节点进行检索。</span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、与当前节点进行比对，若新增节点值较大，则以当前节点的右子节点作为新的当前节点。否则以当前节点的左子节点作为新的当前节点。</span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、循环递归2步骤知道检索出合适的叶子节点为止。</span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>4、将新增节点与3步骤中找到的节点进行比对，如果新增节点较大，则添加为右子节点；否则添加为左子节点。 </span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>按照这个步骤我们就可以将一个新增节点添加到排序二叉树中合适的位置。如下：</span></p></li><li><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;"><br/></span></strong></span></span><pre>public V put(K key, V value) {
           //用t表示二叉树的当前节点
            Entry&lt;K,V&gt; t = root;
            //t为null表示一个空树，即TreeMap中没有任何元素，直接插入
            if (t == null) {
                //比较key值，个人觉得这句代码没有任何意义，空树还需要比较、排序？
                compare(key, key); // type (and possibly null) check
                //将新的key-value键值对创建为一个Entry节点，并将该节点赋予给root
                root = new Entry&lt;&gt;(key, value, null);
                //容器的size = 1，表示TreeMap集合中存在一个元素
                size = 1;
                //修改次数 + 1
                modCount++;
                return null;
            }
            int cmp;     //cmp表示key排序的返回结果
            Entry&lt;K,V&gt; parent;   //父节点
            // split comparator and comparable paths
            Comparator&lt;? super K&gt; cpr = comparator;    //指定的排序算法
            //如果cpr不为空，则采用既定的排序算法进行创建TreeMap集合
            if (cpr != null) {
                do {
                    parent = t;      //parent指向上次循环后的t
                    //比较新增节点的key和当前节点key的大小
                    cmp = cpr.compare(key, t.key);
                    //cmp返回值小于0，表示新增节点的key小于当前节点的key，则以当前节点的左子节点作为新的当前节点
                    if (cmp &lt; 0)
                        t = t.left;
                    //cmp返回值大于0，表示新增节点的key大于当前节点的key，则以当前节点的右子节点作为新的当前节点
                    else if (cmp &gt; 0)
                        t = t.right;
                    //cmp返回值等于0，表示两个key值相等，则新值覆盖旧值，并返回新值
                    else
                        return t.setValue(value);
                } while (t != null);
            }
            //如果cpr为空，则采用默认的排序算法进行创建TreeMap集合
            else {
                if (key == null)     //key值为空抛出异常
                    throw new NullPointerException();
                /* 下面处理过程和上面一样 */
                Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
                do {
                    parent = t;
                    cmp = k.compareTo(t.key);
                    if (cmp &lt; 0)
                        t = t.left;
                    else if (cmp &gt; 0)
                        t = t.right;
                    else
                        return t.setValue(value);
                } while (t != null);
            }
            //将新增节点当做parent的子节点
            Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
            //如果新增节点的key小于parent的key，则当做左子节点
            if (cmp &lt; 0)
                parent.left = e;
          //如果新增节点的key大于parent的key，则当做右子节点
            else
                parent.right = e;
            /*
             *  上面已经完成了排序二叉树的的构建，将新增节点插入该树中的合适位置
             *  下面fixAfterInsertion()方法就是对这棵树进行调整、平衡，具体过程参考上面的五种情况
             */
            fixAfterInsertion(e);
            //TreeMap元素数量 + 1
            size++;
            //TreeMap容器修改次数 + 1
            modCount++;
            return null;
        }</pre><br/></li><li><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;"></span></strong></span>上面代码中do{}代码块是实现排序二叉树的核心算法，通过该算法我们可以确认新增节点在该树的正确位置。找到正确位置后将插入即可，这样做了其实还没有完成，因为我知道TreeMap的底层实现是红黑树，红黑树是一棵平衡排序二叉树，普通的排序二叉树可能会出现失衡的情况，所以下一步就是要进行调整。fixAfterInsertion(e); 调整的过程务必会涉及到红黑树的左旋、右旋、着色三个基本操作。代码如下： </span></li><li><span style="font-size:14px;"></span><pre>/**
     * 新增节点后的修复操作
     * x 表示新增节点
     */
     private void fixAfterInsertion(Entry&lt;K,V&gt; x) {
            x.color = RED;    //新增节点的颜色为红色

            //循环 直到 x不是根节点，且x的父节点不为红色
            while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {
                //如果X的父节点（P）是其父节点的父节点（G）的左节点
                if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
                    //获取X的叔节点(U)
                    Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));
                    //如果X的叔节点（U） 为红色（情况三）
                    if (colorOf(y) == RED) {     
                        //将X的父节点（P）设置为黑色
                        setColor(parentOf(x), BLACK);
                        //将X的叔节点（U）设置为黑色
                        setColor(y, BLACK);
                        //将X的父节点的父节点（G）设置红色
                        setColor(parentOf(parentOf(x)), RED);
                        x = parentOf(parentOf(x));
                    }
                    //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）
                    else {   
                        //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）
                        if (x == rightOf(parentOf(x))) {
                            //将X的父节点作为X
                            x = parentOf(x);
                            //右旋转
                            rotateLeft(x);
                        }
                        //（情况五）
                        //将X的父节点（P）设置为黑色
                        setColor(parentOf(x), BLACK);
                        //将X的父节点的父节点（G）设置红色
                        setColor(parentOf(parentOf(x)), RED);
                        //以X的父节点的父节点（G）为中心右旋转
                        rotateRight(parentOf(parentOf(x)));
                    }
                }
                //如果X的父节点（P）是其父节点的父节点（G）的右节点
                else {
                    //获取X的叔节点（U）
                    Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));
                  //如果X的叔节点（U） 为红色（情况三）
                    if (colorOf(y) == RED) {
                        //将X的父节点（P）设置为黑色
                        setColor(parentOf(x), BLACK);
                        //将X的叔节点（U）设置为黑色
                        setColor(y, BLACK);
                        //将X的父节点的父节点（G）设置红色
                        setColor(parentOf(parentOf(x)), RED);
                        x = parentOf(parentOf(x));
                    }
                  //如果X的叔节点（U为黑色）；这里会存在两种情况（情况四、情况五）
                    else {
                        //如果X节点为其父节点（P）的右子树，则进行左旋转（情况四）
                        if (x == leftOf(parentOf(x))) {
                            //将X的父节点作为X
                            x = parentOf(x);
                           //右旋转
                            rotateRight(x);
                        }
                        //（情况五）
                        //将X的父节点（P）设置为黑色
                        setColor(parentOf(x), BLACK);
                        //将X的父节点的父节点（G）设置红色
                        setColor(parentOf(parentOf(x)), RED);
                        //以X的父节点的父节点（G）为中心右旋转
                        rotateLeft(parentOf(parentOf(x)));
                    }
                }
            }
            //将根节点G强制设置为黑色
            root.color = BLACK;
        }</pre><br/><br/></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>对这段代码的研究我们发现,其处理过程完全符合红黑树新增节点的处理过程。所以在看这段代码的过程一定要对红黑树的新增节点过程有了解。在这个代码中还包含几个重要的操作。左旋(rotateLeft())、右旋（rotateRight()）、着色（setColor()）。</span></p><p><span style="font-size:14px;">左旋：rotateLeft()</span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>所谓左旋转，就是将新增节点（N）当做其父节点（P），将其父节点P当做新增节点（N）的左子节点。即：G.left ---&gt; N ,N.left ---&gt; P。</span></p></li></div><p><br/></p><div><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>右旋：rotateRight()</span></p></li><pre>private void rotateLeft(Entry&lt;K,V&gt; p) {
        if (p != null) {
            //获取P的右子节点，其实这里就相当于新增节点N（情况四而言）
            Entry&lt;K,V&gt; r = p.right;
            //将R的左子树设置为P的右子树
            p.right = r.left;
            //若R的左子树不为空，则将P设置为R左子树的父亲
            if (r.left != null)
                r.left.parent = p;
            //将P的父亲设置R的父亲
            r.parent = p.parent;
            //如果P的父亲为空，则将R设置为跟节点
            if (p.parent == null)
                root = r;
            //如果P为其父节点（G）的左子树，则将R设置为P父节点(G)左子树
            else if (p.parent.left == p)
                p.parent.left = r;
            //否则R设置为P的父节点（G）的右子树
            else
                p.parent.right = r;
            //将P设置为R的左子树
            r.left = p;
            //将R设置为P的父节点
            p.parent = r;
        }
    }</pre><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>所谓右旋转即，P.right ---&gt; G、G.parent ---&gt; P。</span></p></li><li><span style="font-size:14px;"></span><pre>private void rotateRight(Entry&lt;K,V&gt; p) {
        if (p != null) {
            //将L设置为P的左子树
            Entry&lt;K,V&gt; l = p.left;
            //将L的右子树设置为P的左子树
            p.left = l.right;
            //若L的右子树不为空，则将P设置L的右子树的父节点
            if (l.right != null) 
                l.right.parent = p;
            //将P的父节点设置为L的父节点
            l.parent = p.parent;
            //如果P的父节点为空，则将L设置根节点
            if (p.parent == null)
                root = l;
            //若P为其父节点的右子树，则将L设置为P的父节点的右子树
            else if (p.parent.right == p)
                p.parent.right = l;
            //否则将L设置为P的父节点的左子树
            else 
                p.parent.left = l;
            //将P设置为L的右子树
            l.right = p;
            //将L设置为P的父节点
            p.parent = l;
        }
    }</pre></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>左旋、右旋的示意图如下：</span></p></li><li><p><br/><span style="font-size:14px;"></span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [3].gif" type="image/gif" data-filename="SouthEast.gif" alt="" height="241" width="329"/><img src="RSS-CSDN博客推荐文章_files/SouthEast [4].gif" type="image/gif" data-filename="SouthEast.gif" alt="" height="258" width="301"/></p><p align="center"><span style="font-size:14px;">                                                 （左旋）                                         （右旋）</span></p><p><span style="font-size:14px;">（图片来自：<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html</a>）</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>着色：setColor()</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>着色就是改变该节点的颜色，在红黑树中，它是依靠节点的颜色来维持平衡的。</span></p></li><li><span style="font-size:14px;"></span><pre>private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) {
        if (p != null)
            p.color = c;
    }</pre><br/></li><li><h1><span style="font-size:18px;color:#FF0000;"><strong>       </strong>四、TreeMap delete()方法</span></h1><h2><span style="font-size:14px;"><span style="font-size:14px;color:#3366FF;"><strong><span style="font-size:14px;">       </span></strong></span><span style="color:#3366FF;">红黑树删除节点</span></span></h2><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>针对于红黑树的增加节点而言，删除显得更加复杂，使原本就复杂的红黑树变得更加复杂。同时删除节点和增加节点一样，同样是找到删除的节点，删除之后调整红黑树。但是这里的删除节点并不是直接删除，而是通过走了“弯路”通过一种捷径来删除的：<strong>找到被删除的节点D的子节点C，用C来替代D，不是直接删除D，因为D被C替代了，直接删除C即可。</strong>所以这里就将删除父节点D的事情转变为了删除子节点C的事情，这样处理就将复杂的删除事件简单化了。<strong>子节点C的规则是：右分支最左边，或者 左分支最右边的。</strong></span></p></li><div align="center"><li><span style="font-size:14px;"><strong><img src="RSS-CSDN博客推荐文章_files/SouthEast [14].png" type="image/png" data-filename="SouthEast.png" alt="" height="259" width="349"/><br/></strong></span></li></div><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>红-黑二叉树删除节点，最大的麻烦是要保持 各分支黑色节点数目相等。 因为是删除，所以不用担心存在颜色冲突问题——插入才会引起颜色冲突。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>红黑树删除节点同样会分成几种情况，这里是按照待删除节点有几个儿子的情况来进行分类：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>下面就论各种删除情况来进行图例讲解，但是在讲解之前请允许我再次啰嗦一句，<strong>请时刻牢记红黑树的5点规定：</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、每个节点都只能是红色或者黑色</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、根节点是黑色</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、每个叶节点（NIL节点，空节点）是黑色的。</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>4、如果一个结点是红的，则它两个子节点都是黑的。也就是说在一条路径上不能出现相邻的两个红色结点。</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>5、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</strong></span></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>（注：已经讲三遍了，再不记住我就怀疑你是否适合搞IT了 O(∩_∩)O~）</strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>诚然，既然删除节点比较复杂，那么在这里我们就约定一下规则：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、下面要讲解的删除节点一定是实际要删除节点的后继节点（N），如前面提到的C。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、下面提到的删除节点的树都是如下结构，该结构所选取的节点是待删除节点的右树的最左边子节点。这里我们规定真实删除节点为N、父节点为P、兄弟节点为W兄弟节点的两个子节点为X1、X2。如下图（2.1）。</span></p></li><div align="center"><li><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [15].png" type="image/png" data-filename="SouthEast.png" alt="" height="288" width="709"/><br/></span></li></div><li><p></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>现在我们就上面提到的三种情况进行分析、处理。</span></p><p><span style="font-size:14px;color:#ffc000;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况一、无子节点（红色节点）</strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这种情况对该节点直接删除即可，不会影响树的结构。因为该节点为叶子节点它不可能存在子节点-----如子节点为黑，则违反黑节点数原则（规定5），为红，则违反“颜色”原则（规定4）。 如上图（2.2）。</span></p><p><span style="font-size:14px;color:#ffc000;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况二、有一个子节点</strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这种情况处理也是非常简单的，用子节点替代待删除节点，然后删除子节点即可。如上图（2.3）</span></p><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况三、有两个子节点</span></strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这种情况可能会稍微有点儿复杂。它需要找到一个替代待删除节点（N）来替代它，然后删除N即可。它主要分为四种情况。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、N的兄弟节点W为红色</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>4、N的兄弟w是黑色的，且w的右孩子时红色的。</span></p><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况3.1、N的兄弟节点W为红色</span></strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>W为红色，那么其子节点X1、X2必定全部为黑色，父节点P也为黑色。处理策略是：改变W、P的颜色，然后进行一次左旋转。这样处理就可以使得红黑性质得以继续保持。N的新兄弟new w是旋转之前w的某个孩子，为黑色。这样处理后将情况3.1、转变为3.2、3.3、3.4中的一种。如下：</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [16].png" type="image/png" data-filename="SouthEast.png" alt="" height="233" width="605"/><br/></p></li><li><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况3.2、N的兄弟w是黑色的，且w的俩个孩子都是黑色的。</span></strong></span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这种情况其父节点可红可黑，由于W为黑色，这样导致N子树相对于其兄弟W子树少一个黑色节点，这时我们可以将W置为红色。这样，N子树与W子树黑色节点一致，保持了平衡。如下</span></p></li><div align="center"><li><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [17].png" type="image/png" data-filename="SouthEast.png" alt="" height="231" width="639"/><br/></span></li></div><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>将W由黑转变为红，这样就会导致新节点new N相对于它的兄弟节点会少一个黑色节点。但是如果new x为红色，我们直接将new x转变为黑色，保持整棵树的平衡。否则情况3.2 会转变为情况3.1、3.3、3.4中的一种。</span></p></li><li><p><span style="font-size:14px;color:#ffc000;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况3.3、N的兄弟w是黑色的，w的左孩子是红色，w的右孩子是黑色。</strong></span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>针对这种情况是将节点W和其左子节点进行颜色交换，然后对W进行右旋转处理。</span></p></li><div align="center"><li><img src="RSS-CSDN博客推荐文章_files/SouthEast [18].png" type="image/png" data-filename="SouthEast.png" alt="" height="259" width="730"/><br/></li></div><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>此时N的新兄弟X1(new w)是一个有红色右孩子的黑结点，于是将情况3转化为情况4.</span></p></li><li><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>情况3.4、N的兄弟w是黑色的，且w的右孩子时红色的。</span></strong></span></p></li><li><p><span style="font-size:14px;"> <span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>交换W和父节点P的颜色，同时对P进行左旋转操作。这样就把左边缺失的黑色节点给补回来了。同时将W的右子节点X2置黑。这样左右都达到了平衡。</span></p></li><div align="center"><li><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [19].png" type="image/png" data-filename="SouthEast.png" alt="" height="233" width="605"/><br/></span></li></div><li><br/></li><li><p><span style="font-size:14px;"><strong><span style="color:#ffc000;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>总结</span></strong></span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>个人认为这四种情况比较难理解，首先他们都不是单一的某种情况，他们之间是可以进行互转的。相对于其他的几种情况，情况3.2比较好理解，仅仅只是一个颜色的转变，通过减少右子树的一个黑色节点使之保持平衡，同时将不平衡点上移至N与W的父节点，然后进行下一轮迭代。情况3.1，是将W旋转将其转成情况2、3、4情况进行处理。而情况3.3通过转变后可以化成情况3.4来进行处理，从这里可以看出情况3.4应该最终结。情况3.4、右子节点为红色节点，那么将缺失的黑色节点交由给右子节点，通过旋转达到平衡。</span></p></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>通过上面的分析，我们已经初步了解了红黑树的删除节点情况，相对于增加节点而言它确实是选的较为复杂。下面我将看到在Java TreeMap中是如何实现红黑树删除的。</span></p></li><li><h2><span style="font-size:14px;"><span style="font-size:14px;color:#3366FF;"><strong><span style="font-size:14px;">       </span></strong></span><span style="color:#3366FF;">TreeMap deleteEntry()方法实现分析</span></span></h2></li><li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>通过上面的分析我们确认删除节点的步骤是：找到一个替代子节点C来替代P，然后直接删除C，最后调整这棵红黑树。下面代码是寻找替代节点、删除替代节点。</span></p></li><li><span style="font-size:14px;"></span><pre>private void deleteEntry(Entry&lt;K,V&gt; p) {
        modCount++;      //修改次数 +1
        size--;          //元素个数 -1

        /*
         * 被删除节点的左子树和右子树都不为空，那么就用 p节点的中序后继节点代替 p 节点
         * successor(P)方法为寻找P的替代节点。规则是右分支最左边，或者 左分支最右边的节点
         * ---------------------（1）
         */
        if (p.left != null &amp;&amp; p.right != null) {  
            Entry&lt;K,V&gt; s = successor(p);
            p.key = s.key;
            p.value = s.value;
            p = s;
        }

        //replacement为替代节点，如果P的左子树存在那么就用左子树替代，否则用右子树替代
        Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);

        /*
         * 删除节点，分为上面提到的三种情况
         * -----------------------（2）
         */
        //如果替代节点不为空
        if (replacement != null) {
            replacement.parent = p.parent;
            /*
             *replacement来替代P节点
             */
            //若P没有父节点，则跟节点直接变成replacement
            if (p.parent == null)
                root = replacement;
            //如果P为左节点，则用replacement来替代为左节点
            else if (p == p.parent.left)
                p.parent.left  = replacement;
          //如果P为右节点，则用replacement来替代为右节点
            else
                p.parent.right = replacement;

            //同时将P节点从这棵树中剔除掉
            p.left = p.right = p.parent = null;

            /*
             * 若P为红色直接删除，红黑树保持平衡
             * 但是若P为黑色，则需要调整红黑树使其保持平衡
             */
            if (p.color == BLACK)
                fixAfterDeletion(replacement);
        } else if (p.parent == null) {     //p没有父节点，表示为P根节点，直接删除即可
            root = null;
        } else {      //P节点不存在子节点，直接删除即可
            if (p.color == BLACK)         //如果P节点的颜色为黑色，对红黑树进行调整
                fixAfterDeletion(p);

            //删除P节点
            if (p.parent != null) {
                if (p == p.parent.left)
                    p.parent.left = null;
                else if (p == p.parent.right)
                    p.parent.right = null;
                p.parent = null;
            }
        }
    }</pre><br/><br/></li><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>（1）</strong>除是寻找替代节点replacement，其实现方法为successor()。如下：</span></p><p><span style="font-size:14px;"></span></p><pre>static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {
        if (t == null)
            return null;
        /*
         * 寻找右子树的最左子树
         */
        else if (t.right != null) {
            Entry&lt;K,V&gt; p = t.right;
            while (p.left != null)
                p = p.left;
            return p;
        } 
        /*
         * 选择左子树的最右子树
         */
        else {
            Entry&lt;K,V&gt; p = t.parent;
            Entry&lt;K,V&gt; ch = t;
            while (p != null &amp;&amp; ch == p.right) {
                ch = p;
                p = p.parent;
            }
            return p;
        }
    }</pre><p></p><p><span style="font-size:14px;"><strong><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>（2）</strong>处是删除该节点过程。它主要分为上面提到的三种情况，它与上面的if…else if… else一一对应 。如下：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>1、有两个儿子。这种情况比较复杂，但还是比较简单。上面提到过用子节点C替代代替待删除节点D，然后删除子节点C即可。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>2、没有儿子，即为叶结点。直接把父结点的对应儿子指针设为NULL，删除儿子结点就OK了。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>3、只有一个儿子。那么把父结点的相应儿子指针指向儿子的独生子，删除儿子结点也OK了。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>删除完节点后，就要根据情况来对红黑树进行复杂的调整：fixAfterDeletion()。</span></p><p><span style="font-size:14px;"></span></p><pre>private void fixAfterDeletion(Entry&lt;K,V&gt; x) {
        // 删除节点需要一直迭代，知道 直到 x 不是根节点，且 x 的颜色是黑色
        while (x != root &amp;&amp; colorOf(x) == BLACK) {
            if (x == leftOf(parentOf(x))) {      //若X节点为左节点
                //获取其兄弟节点
                Entry&lt;K,V&gt; sib = rightOf(parentOf(x));

                /*
                 * 如果兄弟节点为红色----（情况3.1）
                 * 策略：改变W、P的颜色，然后进行一次左旋转
                 */
                if (colorOf(sib) == RED) {     
                    setColor(sib, BLACK);     
                    setColor(parentOf(x), RED);  
                    rotateLeft(parentOf(x));
                    sib = rightOf(parentOf(x));
                }

                /*
                 * 若兄弟节点的两个子节点都为黑色----（情况3.2）
                 * 策略：将兄弟节点编程红色
                 */
                if (colorOf(leftOf(sib))  == BLACK &amp;&amp;
                    colorOf(rightOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } 
                else {
                    /*
                     * 如果兄弟节点只有右子树为黑色----（情况3.3）
                     * 策略：将兄弟节点与其左子树进行颜色互换然后进行右转
                     * 这时情况会转变为3.4
                     */
                    if (colorOf(rightOf(sib)) == BLACK) {
                        setColor(leftOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateRight(sib);
                        sib = rightOf(parentOf(x));
                    }
                    /*
                     *----情况3.4
                     *策略：交换兄弟节点和父节点的颜色，
                     *同时将兄弟节点右子树设置为黑色，最后左旋转
                     */
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(rightOf(sib), BLACK);
                    rotateLeft(parentOf(x));
                    x = root;
                }
            } 
            
            /**
             * X节点为右节点与其为做节点处理过程差不多，这里就不在累述了
             */
            else {
                Entry&lt;K,V&gt; sib = leftOf(parentOf(x));

                if (colorOf(sib) == RED) {
                    setColor(sib, BLACK);
                    setColor(parentOf(x), RED);
                    rotateRight(parentOf(x));
                    sib = leftOf(parentOf(x));
                }

                if (colorOf(rightOf(sib)) == BLACK &amp;&amp;
                    colorOf(leftOf(sib)) == BLACK) {
                    setColor(sib, RED);
                    x = parentOf(x);
                } else {
                    if (colorOf(leftOf(sib)) == BLACK) {
                        setColor(rightOf(sib), BLACK);
                        setColor(sib, RED);
                        rotateLeft(sib);
                        sib = leftOf(parentOf(x));
                    }
                    setColor(sib, colorOf(parentOf(x)));
                    setColor(parentOf(x), BLACK);
                    setColor(leftOf(sib), BLACK);
                    rotateRight(parentOf(x));
                    x = root;
                }
            }
        }

        setColor(x, BLACK);
    }</pre><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这是红黑树在删除节点后，对树的平衡性进行调整的过程，其实现过程与上面四种复杂的情况一一对应，所以在这个源码的时候一定要对着上面提到的四种情况看。<p></p><li><h1><span style="font-size:14px;"><span style="font-size:14px;color:#FF0000;"><strong><span style="font-size:14px;">       </span></strong></span><span style="color:#FF0000;">五、写在最后</span></span></h1></li><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>这篇博文确实是有点儿长，在这里非常感谢各位看客能够静下心来读完，我想你通过读完这篇博文一定收获不小。同时这篇博文很大篇幅都在阐述红黑树的实现过程，对Java 的TreeMap聊的比较少，但是我认为如果理解了红黑树的实现过程，对TreeMap那是手到擒来，小菜一碟。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><strong><span style="font-size:14px;">       </span></strong></span>同时这篇博文我写了四天，看了、参考了大量的博文。同时不免会有些地方存在借鉴之处，在这里对其表示感谢。LZ大二开始学习数据结构，自认为学的不错，现在发现数据结构我还有太多的地方需要学习了，同时也再一次体味了算法的魅力！！！！</span></p><p> </p><hr/><p><span style="font-size:14px;">参考资料：</span></p><p><span style="font-size:14px;"><strong>1、红黑树数据结构剖析：</strong><a href="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/fanzhidongyzby/p/3187912.html"><strong>http://www.cnblogs.com/fanzhidongyzby/p/3187912.html</strong></a></span></p><p><span style="font-size:14px;"><strong>2、红黑二叉树详解及理论分析 ：</strong><a href="http://blog.csdn.net/kartorz/article/details/8865997" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://blog.csdn.net/kartorz/article/details/8865997"><strong>http://blog.csdn.net/kartorz/article/details/8865997</strong></a></span></p><p><span style="font-size:14px;"><strong>3、</strong><a href="http://blog.csdn.net/v_july_v/article/details/6105630" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong>教你透彻了解红黑树 </strong></a><strong>：</strong><a href="http://blog.csdn.net/blog.csdn.net/v_july_v/article/details/6105630" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><strong>blog.csdn.net/v_july_v/article/details/6105630</strong></a></span></p><p><span style="font-size:14px;"><strong>4、经典算法研究系列：五、红黑树算法的实现与剖析 ：</strong><a href="http://blog.csdn.net/v_JULY_v/article/details/6109153" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://blog.csdn.net/v_JULY_v/article/details/6109153"><strong>http://blog.csdn.net/v_JULY_v/article/details/6109153</strong></a></span></p><p><span style="font-size:14px;"><strong>5、示例，红黑树插入和删除过程：</strong><a href="http://saturnman.blog.163.com/blog/static/557611201097221570/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://saturnman.blog.163.com/blog/static/557611201097221570/"><strong>http://saturnman.blog.163.com/blog/static/557611201097221570/</strong></a></span></p><p><span style="font-size:14px;"><strong>6、红黑二叉树详解及理论分析 ：</strong><a href="http://blog.csdn.net/kartorz/article/details/8865997" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://blog.csdn.net/kartorz/article/details/8865997"><strong>http://blog.csdn.net/kartorz/article/details/8865997</strong></a></span></p><p><font size="3"><a href="http://blog.csdn.net/kartorz/article/details/8865997" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://blog.csdn.net/kartorz/article/details/8865997"><strong><span style="font-size:14px;"><span style="font-size:14px;"><span style="color:#3333FF;">----------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span></span></span><br/></strong></a></font></p><p><span style="font-size:14px;"><span style="font-size:14px;"></span></span></p><p><span style="font-size:14px;color:#3366FF;">       原文出自：<a href="http://cmsblogs.com/?p=1013" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=1013</a>。尊重作者的成果，转载请注明出处！</span><span style="font-size:14px;">   <br/></span></p><p><span style="font-size:14px;color:#3366FF;">       个人站点：<a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com</a></span></p><br/></div>
<div>
    作者：chenssy 发表于2014/5/23 9:23:51 <a href="http://blog.csdn.net/chenssy/article/details/26668941" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：35121 评论：34 <a href="http://blog.csdn.net/chenssy/article/details/26668941#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/23299963" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">Java提高篇（二六）------hashCode</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;color:#3366FF;">       原文出自：<a href="http://cmsblogs.com/?p=631" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=631</a><a href="http://cmsblogs.com/?p=618" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"></a>。尊重作者的成果，转载请注明出处！</span><span style="font-size:14px;">   <br/></span></p><p><span style="font-size:14px;color:#3366FF;">       个人站点：<a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com</a></span></p><span style="font-size:14px;"><span style="color:#3333FF;">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- <br/></span></span><br/><p><span style="font-size:14px;"><span style="color:#0000ff;">       </span>在前面三篇博文中LZ讲解了（<a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">HashMap</a>、<a href="http://blog.csdn.net/chenssy/article/details/21988605" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">HashSet</a>、<span style="font-size:14px;"><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">HashTable</a></span>），在其中LZ不断地讲解他们的put和get方法，在这两个方法中计算key的hashCode应该是最重要也是最精华的部分，所以下面LZ揭开hashCode的“神秘”面纱。</span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3333FF;">      hashCode的作用</span></span></h1><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>要想了解一个方法的内在原理，我们首先需要明白它是干什么的，也就是这个方法的作用。在讲解数组时（<a href="http://blog.csdn.net/chenssy/article/details/17732783" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（十八）------数组</a>），我们提到数组是java中效率最高的数据结构，但是“最高”是有前提的。第一我们需要知道所查询数据的所在位置。第二：如果我们进行迭代查找时，数据量一定要小，对于大数据量而言一般推荐集合。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>在Java集合中有两类，一类是List，一类是Set他们之间的区别就在于List集合中的元素师有序的，且可以重复，而Set集合中元素是无序不可重复的。对于List好处理，但是对于Set而言我们要如何来保证元素不重复呢？通过迭代来equals()是否相等。数据量小还可以接受，当我们的数据量大的时候效率可想而知（当然我们可以利用算法进行优化）。比如我们向HashSet插入1000数据，难道我们真的要迭代1000次，调用1000次equals()方法吗？hashCode提供了解决方案。怎么实现？我们先看hashCode的源码(Object)。</span></p><p><span style="font-size:14px;"></span></p><pre>public native int hashCode();</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>它是一个本地方法，它的实现与本地机器有关，这里我们暂且认为他返回的是对象存储的物理位置（实际上不是，这里写是便于理解）。当我们向一个集合中添加某个元素，集合会首先调用hashCode方法，这样就可以直接定位它所存储的位置，若该处没有其他元素，则直接保存。若该处已经有元素存在，就调用equals方法来匹配这两个元素是否相同，相同则不存，不同则散列到其他位置（具体情况请参考（Java提高篇（）-----HashMap））。这样处理，当我们存入大量元素时就可以大大减少调用equals()方法的次数，极大地提高了效率。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>所以<span style="color:#0000ff;"><strong>hashCode在上面扮演的角色为寻域</strong></span>（寻找某个对象在集合中区域位置）。hashCode可以将集合分成若干个区域，每个对象都可以计算出他们的hash码，可以将hash码分组，每个分组对应着某个存储区域，根据一个对象的hash码就可以确定该对象所存储区域，这样就大大减少查询匹配元素的数量，提高了查询效率。</span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3333FF;">      </span><span style="font-size:18px;color:#3333FF;">hashCode对于一个对象的重要性</span></span></h1><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>hashCode重要么？不重要，对于List集合、数组而言，他就是一个累赘，但是对于HashMap、HashSet、HashTable而言，它变得异常重要。所以在使用HashMap、HashSet、HashTable时一定要注意hashCode。对于一个对象而言，其hashCode过程就是一个简单的Hash算法的实现，其实现过程对你实现对象的存取过程起到非常重要的作用。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>在前面LZ提到了HashMap和HashTable两种数据结构，虽然他们存在若干个区别，但是他们的实现原理是相同的，这里我以HashTable为例阐述hashCode对于一个对象的重要性。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>一个对象势必会存在若干个属性，如何选择属性来进行散列考验着一个人的设计能力。如果我们将所有属性进行散列，这必定会是一个糟糕的设计，因为对象的hashCode方法无时无刻不是在被调用，如果太多的属性参与散列，那么需要的操作数时间将会大大增加，这将严重影响程序的性能。但是如果较少属相参与散列，散列的多样性会削弱，会产生大量的散列“冲突”，除了不能够很好的利用空间外，在某种程度也会影响对象的查询效率。其实这两者是一个矛盾体，散列的多样性会带来性能的降低。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>那么如何对对象的hashCode进行设计，LZ也没有经验。从网上查到了这样一种解决方案：设置一个缓存标识来缓存当前的散列码，只有当参与散列的对象改变时才会重新计算，否则调用缓存的hashCode，这样就可以从很大程度上提高性能。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>在HashTable计算某个对象在table[]数组中的索引位置，其代码如下：</span></p><p><span style="font-size:14px;"></span></p><pre>int index = (hash &amp; 0x7FFFFFFF) % tab.length;</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>为什么要&amp;0x7FFFFFFF？因为某些对象的hashCode可能会为负值，与0x7FFFFFFF进行与运算可以确保index为一个正数。通过这步我可以直接定位某个对象的位置，所以从理论上来说我们是完全可以利用hashCode直接定位对象的散列表中的位置，但是为什么会存在一个key-value的键值对，利用key的hashCode来存入数据而不是直接存放value呢？这就关系HashTable性能问题的最重要的问题:Hash冲突！</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>我们知道冲突的产生是由于不同的对象产生了相同的散列码，假如我们设计对象的散列码可以确保99.999999999%的不重复，但是有一种绝对且几乎不可能遇到的冲突你是绝对避免不了的。我们知道hashcode返回的是int，它的值只可能在int范围内。如果我们存放的数据超过了int的范围呢？这样就必定会产生两个相同的index，这时在index位置处会存储两个对象，我们就可以利用key本身来进行判断。所以具有相索引的对象，在该index位置处存在多个对象，我们必须依靠key的hashCode和key本身来进行区分。</span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3333FF;">      hashCode与equals</span></span></h1><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>在Java中hashCode的实现总是伴随着equals，他们是紧密配合的，你要是自己设计了其中一个，就要设计另外一个。当然在多数情况下，这两个方法是不用我们考虑的，直接使用默认方法就可以帮助我们解决很多问题。但是在有些情况，我们必须要自己动手来实现它，才能确保程序更好的运作。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>对于equals，我们必须遵循如下规则：</span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>对称性：</span><span style="font-size:14px;">如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 </span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>反射性：</span><span style="font-size:14px;">x.equals(x)必须返回是“true”。 </span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>类推性：</span><span style="font-size:14px;">如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 </span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>一致性：</span><span style="font-size:14px;">如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 </span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 </span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>对于hashCode，我们应该遵循如下规则：</span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>1.</span><span style="font-size:14px;"> 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。</span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>2.</span><span style="font-size:14px;"> 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。</span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>3.</span><span style="font-size:14px;"> 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>至于两者之间的关联关系，我们只需要记住如下即可：</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。 </span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。 </span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>理清了上面的关系我们就知道他们两者是如何配合起来工作的。先看下图：</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [20].png" type="image/png" data-filename="SouthEast.png" alt="" height="435" width="314"/><br/></span></p><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>整个处理流程是：</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>1、判断两个对象的hashcode是否相等，若不等，则认为两个对象不等，完毕，若相等，则比较equals。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>2、若两个对象的equals不等，则可以认为两个对象不等，否则认为他们相等。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>实例：</span></p><p><span style="font-size:14px;"></span></p><pre>public class Person {
    private int age;
    private int sex;    //0：男，1：女
    private String name;
    
    private final int PRIME = 37;
    
    Person(int age ,int sex ,String name){
        this.age = age;
        this.sex = sex;
        this.name = name;
    }

    /** 省略getter、setter方法 **/
    
    @Override
    public int hashCode() {
        System.out.println(&quot;调用hashCode方法...........&quot;);

        int hashResult = 1;
        hashResult = (hashResult + Integer.valueOf(age).hashCode() + Integer.valueOf(sex).hashCode()) * PRIME;
        hashResult = PRIME * hashResult + ((name == null) ? 0 : name.hashCode()); 
        System.out.println(&quot;name:&quot;+name +&quot; hashCode:&quot; + hashResult);
        
        return hashResult;
    }

    /**
     * 重写hashCode()
     */
    public boolean equals(Object obj) {
        System.out.println(&quot;调用equals方法...........&quot;);
        
        if(obj == null){
            return false;
        }
        if(obj.getClass() != this.getClass()){
            return false;
        }
        if(this == obj){
            return true;
        }

        Person person = (Person) obj;
        
        if(getAge() != person.getAge() || getSex()!= person.getSex()){
            return false;
        }
        
        if(getName() != null){
            if(!getName().equals(person.getName())){
                return false;
            }
        }
        else if(person != null){
            return false;
        }
        return true;
    }
}</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>该Bean为一个标准的Java Bean，重新实现了hashCode方法和equals方法。</span></p><p><span style="font-size:14px;"></span></p><pre>public class Main extends JPanel {

    public static void main(String[] args) {
        Set&lt;Person&gt; set = new HashSet&lt;Person&gt;();
        
        Person p1 = new Person(11, 1, &quot;张三&quot;);
        Person p2 = new Person(12, 1, &quot;李四&quot;);
        Person p3 = new Person(11, 1, &quot;张三&quot;);
        Person p4 = new Person(11, 1, &quot;李四&quot;);
        
        //只验证p1、p3
        System.out.println(&quot;p1 == p3? :&quot; + (p1 == p3));
        System.out.println(&quot;p1.equals(p3)?:&quot;+p1.equals(p3));
        System.out.println(&quot;-----------------------分割线--------------------------&quot;);
        set.add(p1);
        set.add(p2);
        set.add(p3);
        set.add(p4);
        System.out.println(&quot;set.size()=&quot;+set.size());
    }
}</pre><p></p><p><span style="font-size:14px;">       <span style="font-size:14px;">      </span>运行结果如下：</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [21].png" type="image/png" data-filename="SouthEast.png" alt="" height="309" width="891"/><br/></span></p><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>从上图可以看出，程序调用四次hashCode方法，一次equals方法，其set的长度只有3。add方法运行流程完全符合他们两者之间的处理流程。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">      </span>更多请关注：</span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><a href="http://blog.csdn.net/chenssy/article/details/14963073" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="font-size:14px;"><span style="color:#0000ff;">Java提高篇（十三）------equals()</span></span></a></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="font-size:14px;"><span style="color:#0000ff;">Java提高篇（二三）------HashMap</span></span></a></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><span style="font-size:14px;"><a href="http://blog.csdn.net/chenssy/article/details/21988605" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#0000ff;">Java提高篇（二四）------HashSet</span></a></span></p><p><span style="font-size:14px;color:#0000ff;">      <span style="font-size:14px;">      </span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><span style="font-size:14px;"><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#0000ff;">Java提高篇（二五）------HashTable</span></a></span></p><p><font size="3"><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#0000ff;"><span style="font-size:14px;"><span style="color:#3333FF;">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- </span></span></span></a></font><br/></p><p><span style="font-size:14px;"><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#0000ff;"><span style="font-size:14px;color:#3366FF;">       原文出自：</span></span></a><a href="http://cmsblogs.com/?p=631" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=631</a>。尊重作者的成果，转载请注明出处！</span><span style="font-size:14px;">   <br/></span></p><p><span style="font-size:14px;color:#3366FF;">       个人站点：<a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com</a></span></p> <br/>
<div>
    作者：chenssy 发表于2014/4/9 21:44:05 <a href="http://blog.csdn.net/chenssy/article/details/23299963" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：2815 评论：2 <a href="http://blog.csdn.net/chenssy/article/details/23299963#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二五）-----HashTable</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;color:#3366FF;">       原文出自：<a href="http://cmsblogs.com/?p=618" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=618</a>。尊重作者的成果，转载请注明出处！</span></p><p><span style="font-size:14px;color:#3366FF;">       个人站点：<a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com</a></span></p><p><span style="font-size:14px;"><span style="color:#3333FF;">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- </span> <br/></span></p><p><span style="font-size:14px;"><span style="font-size:14px;">        </span>有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。</span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3366FF;">        </span><span style="font-size:18px;color:#3366FF;">一、定义</span></span></h1><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>HashTable在Java中的定义如下：</span></p><p><span style="font-size:14px;"></span></p><pre>public class Hashtable&lt;K,V&gt;
    extends Dictionary&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 <code>Hashtable</code>）的抽象父类。每个键和每个值都是一个对象。在任何一个 <tt>Dictionary</tt> 对象中，每个键至多与一个值相关联。Map是&quot;key-value键值对&quot;接口。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>HashTable采用&quot;拉链法&quot;实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>table：为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的&quot;key-value键值对&quot;都是存储在Entry数组中的。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=&quot;容量*加载因子&quot;。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>loadFactor：加载因子。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。</span></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3366FF;">        二、构造方法</span></span></h1><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>在HashTabel中存在5个构造函数。通过这5个构造函数我们构建出一个我想要的HashTable。</span></p><p><span style="font-size:14px;"></span></p><pre>public Hashtable() {
        this(11, 0.75f);
    }</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>默认构造函数，容量为11，加载因子为0.75。</span></p><p><span style="font-size:14px;"></span></p><pre>public Hashtable(int initialCapacity) {
        this(initialCapacity, 0.75f);
    }</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。</span></p><p><span style="font-size:14px;"></span></p><pre>public Hashtable(int initialCapacity, float loadFactor) {
        //验证初始容量
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        //验证加载因子
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal Load: &quot;+loadFactor);

        if (initialCapacity==0)
            initialCapacity = 1;
        
        this.loadFactor = loadFactor;
        
        //初始化table，获得大小为initialCapacity的table数组
        table = new Entry[initialCapacity];
        //计算阀值
        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        //初始化HashSeed值
        initHashSeedAsNeeded(initialCapacity);
    }</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。</span></p><p><span style="font-size:14px;"></span></p><pre>private int hash(Object k) {
        return hashSeed ^ k.hashCode();
    }</pre><p></p><p><span style="font-size:14px;">  <span style="font-size:14px;">        </span>构造一个与给定的 Map 具有相同映射关系的新哈希表。</span></p><p><span style="font-size:14px;"></span></p><pre>public Hashtable(Map&lt;? extends K, ? extends V&gt; t) {
        //设置table容器大小，其值==t.size * 2 + 1
        this(Math.max(2*t.size(), 11), 0.75f);
        putAll(t);
    }</pre><p></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3366FF;">        三、主要方法</span></span></h1><p>     <span style="font-size:14px;"><span style="font-size:14px;">        </span>HashTable的API对外提供了许多方法，这些方法能够很好帮助我们操作HashTable，但是这里我只介绍两个最根本的方法：put、get。</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>首先我们先看put方法：将指定 <code>key</code> 映射到此哈希表中的指定 <code>value</code>。注意这里键key和值value都不可为空。</span></p><p><span style="font-size:14px;"></span></p><pre>public synchronized V put(K key, V value) {
        // 确保value不为null
        if (value == null) {
            throw new NullPointerException();
        }

        /*
         * 确保key在table[]是不重复的
         * 处理过程：
         * 1、计算key的hash值，确认在table[]中的索引位置
         * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值
         */
        Entry tab[] = table;
        int hash = hash(key);    //计算key的hash值
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;     //确认该key的索引位置
        //迭代，寻找该key，替换
        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                V old = e.value;
                e.value = value;
                return old;
            }
        }

        modCount++;
        if (count &gt;= threshold) {  //如果容器中的元素数量已经达到阀值，则进行扩容操作
            rehash();
            tab = table;
            hash = hash(key);
            index = (hash &amp; 0x7FFFFFFF) % tab.length;
        }

        // 在索引位置处插入一个新的节点
        Entry&lt;K,V&gt; e = tab[index];
        tab[index] = new Entry&lt;&gt;(hash, key, value, e);
        //容器中元素+1
        count++;
        return null;
    }</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>put方法的整个处理流程是：计算key的hash值，根据hash值获得key在table数组中的索引位置，然后迭代该key处的Entry链表（我们暂且理解为链表），若该链表中存在一个这个的key对象，那么就直接替换其value值即可，否则在将改key-value节点插入该index索引位置处。如下：</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>首先我们假设一个容量为5的table，存在8、10、13、16、17、21。他们在table中位置如下：</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [22].png" type="image/png" data-filename="SouthEast.png" alt="" height="221" width="359"/><br/></span></p><p></p><p><span style="font-size:14px;">     <span style="font-size:14px;">        </span>然后我们插入一个数：put(16,22)，key=16在table的索引位置为1，同时在1索引位置有两个数，程序对该“链表”进行迭代，发现存在一个key=16,这时要做的工作就是用newValue=22替换oldValue16，并将oldValue=16返回。</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [23].png" type="image/png" data-filename="SouthEast.png" alt="" height="221" width="359"/><br/></span></p><p></p><p> <span style="font-size:14px;">     <span style="font-size:14px;">        </span>在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置。</span></p><p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [24].png" type="image/png" data-filename="SouthEast.png" alt="" height="259" width="367"/><br/></span></p><p></p><p><span style="font-size:14px;">         <span style="font-size:14px;">        </span>在HashTabled的put方法中有两个地方需要注意：</span></p><p>        <span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>1、</strong></span><span style="font-size:14px;">HashTable的扩容操作，在put方法中，如果需要向table[]中添加Entry元素，会首先进行容量校验，如果容量已经达到了阀值，HashTable就会进行扩容处理rehash()，如下:</span></p><p><span style="font-size:14px;"></span></p><pre>protected void rehash() {
        int oldCapacity = table.length;
        //元素
        Entry&lt;K,V&gt;[] oldMap = table;

        //新容量=旧容量 * 2 + 1
        int newCapacity = (oldCapacity &lt;&lt; 1) + 1;
        if (newCapacity - MAX_ARRAY_SIZE &gt; 0) {
            if (oldCapacity == MAX_ARRAY_SIZE)
                return;
            newCapacity = MAX_ARRAY_SIZE;
        }
        
        //新建一个size = newCapacity 的HashTable
        Entry&lt;K,V&gt;[] newMap = new Entry[];

        modCount++;
        //重新计算阀值
        threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);
        //重新计算hashSeed
        boolean rehash = initHashSeedAsNeeded(newCapacity);

        table = newMap;
        //将原来的元素拷贝到新的HashTable中
        for (int i = oldCapacity ; i-- &gt; 0 ;) {
            for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) {
                Entry&lt;K,V&gt; e = old;
                old = old.next;

                if (rehash) {
                    e.hash = hash(e.key);
                }
                int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity;
                e.next = newMap[index];
                newMap[index] = e;
            }
        }
    }</pre><p></p><p> <span style="font-size:14px;">     <span style="font-size:14px;">        </span>在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 * 2 + 1 =17，而阀值threshold=17*0.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。</span></p><p>     <span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>2、</strong></span><span style="font-size:14px;color:#000000;"><u>其实这里是我的一个疑问，在计算索引位置index时，HashTable进行了一个与运算过程（hash &amp; 0x7FFFFFFF），为什么需要做一步操作，这么做有什么好处？</u>如果哪位知道，望指导，LZ不胜感激！！下面是计算key的hash值，这里hashSeed发挥了作用。</span></p><p><span style="font-size:14px;color:#000000;"></span></p><pre>private int hash(Object k) {
        return hashSeed ^ k.hashCode();
    }</pre><p></p><p><span style="font-size:14px;">     <span style="font-size:14px;">        </span>相对于put方法，get方法就会比较简单，处理过程就是计算key的hash值，判断在table数组中的索引位置，然后迭代链表，匹配直到找到相对应key的value,若没有找到返回null。</span></p><p><span style="font-size:14px;"></span></p><pre>public synchronized V get(Object key) {
        Entry tab[] = table;
        int hash = hash(key);
        int index = (hash &amp; 0x7FFFFFFF) % tab.length;
        for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) {
            if ((e.hash == hash) &amp;&amp; e.key.equals(key)) {
                return e.value;
            }
        }
        return null;
    }</pre><p></p><h1><span style="font-size:14px;"><span style="font-size:18px;color:#3366FF;">        </span><span style="font-size:18px;color:#3366FF;">四、HashTable与HashMap的区别</span></span></h1><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>HashTable和HashMap存在很多的相同点，但是他们还是有几个比较重要的不同点。</span></p><p>      <span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>第一：</strong></span><span style="font-size:14px;">我们从他们的定义就可以看出他们的不同，HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。</span></p><p>      <span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">        </span>第二：</strong></span><span style="font-size:14px;">HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。如下：</span></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>当HashMap遇到为null的key时，它会调用putForNullKey方法来进行处理。对于value没有进行任何处理，只要是对象都可以。</span></p><p><span style="font-size:14px;"></span></p><pre>if (key == null)
            return putForNullKey(value);</pre><p></p><p><span style="font-size:14px;">      <span style="font-size:14px;">        </span>而当HashTable遇到null时，他会直接抛出NullPointerException异常信息。</span></p><p><span style="font-size:14px;"></span></p><pre>if (value == null) {
            throw new NullPointerException();
        }</pre><p></p><p>      <span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">        </span>第三：</span></strong>Hashtable的方法是同步的，而HashMap的方法不是。所以有人一般都建议如果是涉及到多线程同步时采用HashTable，没有涉及就采用HashMap，但是在Collections类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的Map对象，并把它作为一个封装的对象来返回，所以通过Collections类的synchronizedMap方法是可以我们你同步访问潜在的HashMap。这样君该如何选择呢？？？</span></p><p><span style="font-size:14px;"><span style="color:#3366FF;">--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</span><br/></span></p><p><span style="font-size:14px;"></span></p><p><span style="font-size:14px;color:#3366FF;">       原文出自：<a href="http://cmsblogs.com/?p=618" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=618</a>。尊重作者的成果，转载请注明出处！</span></p><p><span style="font-size:14px;color:#3366FF;">       个人站点：<a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com</a></span></p><br/>
<div>
    作者：chenssy 发表于2014/4/3 21:44:28 <a href="http://blog.csdn.net/chenssy/article/details/22896871" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：16958 评论：15 <a href="http://blog.csdn.net/chenssy/article/details/22896871#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/21988605" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二四）-----HashSet</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<p><span style="font-size:14px;"><span style="color:#3333FF;">      原文出自：http://cmsblogs.com/?p=599</span><br/></span></p><p><span style="font-size:14px;">      在前篇博文中（</span><a href="http://www.cnblogs.com/chenssy/p/3521565.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="font-size:14px;color:#0000ff;">java提高篇（二三）-----HashMap</span></a><span style="font-size:14px;">）详细讲解了HashMap的实现过程，对于HashSet而言，它是基于HashMap来实现的，底层采用HashMap来保存元素。所以如果对HashMap比较熟悉，那么HashSet是so  easy!!</span></p><h1><span style="font-size:24px;color:#3333FF;">一、定义</span></h1><p></p><pre>public class HashSet&lt;E&gt;
    extends AbstractSet&lt;E&gt;
    implements Set&lt;E&gt;, Cloneable, java.io.Serializable</pre><p></p><p><span style="font-size:14px;">          HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。</span></p><p><span style="font-size:14px;">     <span style="color:#0000ff;"><strong><span style="font-size:14px;">          </span>基本属性<br/></strong></span></span></p><p></p><pre>//基于HashMap实现，底层使用HashMap保存所有元素
private transient HashMap&lt;E,Object&gt; map;

 //定义一个Object对象作为HashMap的value
 private static final Object PRESENT = new Object();</pre><br/><span style="font-size:14px;"><span style="color:#0000ff;"><strong></strong></span></span><p></p><p><span style="font-size:14px;color:#0000ff;"><strong>     <span style="font-size:14px;">          </span>构造函数<br/></strong></span></p><p></p><pre>/**
         * 默认构造函数
         * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。
         */
        public HashSet() {
            map = new HashMap&lt;&gt;();
        }
        
        /**
         * 构造一个包含指定 collection 中的元素的新 set。
         */
        public HashSet(Collection&lt;? extends E&gt; c) {
            map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16));
            addAll(c);
        }
        
        /**
         * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子
         */
        public HashSet(int initialCapacity, float loadFactor) {
            map = new HashMap&lt;&gt;(initialCapacity, loadFactor);
        }
           
        /**
         * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。
         */
        public HashSet(int initialCapacity) {
           map = new HashMap&lt;&gt;(initialCapacity);
        }
           
        /**
         * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的）
         * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。
         * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用
         */
        HashSet(int initialCapacity, float loadFactor, boolean dummy) {
           map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);
        }</pre><br/><span style="font-size:14px;color:#0000ff;"><strong></strong></span><p></p><p><span style="font-size:14px;color:#000000;">     <span style="font-size:14px;">          </span>从构造函数中可以看出HashSet所有的构造都是构造出一个新的HashMap，其中最后一个构造函数，为包访问权限是不对外公开，仅仅只在使用LinkedHashSet时才会发生作用。</span></p><h1><span style="font-size:24px;color:#3333FF;">二、方法</span></h1><p><span style="font-size:14px;">     <span style="font-size:14px;">          </span>既然HashSet是基于HashMap，那么对于HashSet而言，其方法的实现过程是非常简单的。</span></p><p><span style="font-size:14px;"></span></p><pre>public Iterator&lt;E&gt; iterator() {
        return map.keySet().iterator();
    }</pre><p></p><p><span style="font-size:14px;">    <span style="font-size:14px;">          </span>iterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层调用HashMap的keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT对象，该对象为static final。</span></p><p><span style="font-size:14px;"></span></p><pre>public int size() {
        return map.size();
    }</pre><p></p><p><span style="font-size:14px;">   <span style="font-size:14px;">          </span>size()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean isEmpty() {
        return map.isEmpty();
    }</pre><p></p><p><span style="font-size:14px;">    <span style="font-size:14px;">          </span>isEmpty()，判断HashSet()集合是否为空，为空返回 <tt>true，否则返回false</tt>。</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean contains(Object o) {
        return map.containsKey(o);
    }</pre><p></p><p><span style="font-size:14px;">    <span style="font-size:14px;">          </span>contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否为空。</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean add(E e) {
        return map.put(e, PRESENT)==null;
    }</pre><p></p><p><span style="font-size:14px;">    <span style="font-size:14px;">          </span>add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足(e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。</span></p><p><span style="font-size:14px;"></span></p><pre>public boolean remove(Object o) {
        return map.remove(o)==PRESENT;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">          </span>remove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。</span></p><p><span style="font-size:14px;"></span></p><pre>public void clear() {
        map.clear();
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">          </span>clear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。</span></p><p><span style="font-size:14px;"></span></p><pre>public Object clone() {
        try {
            HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone();
            newSet.map = (HashMap&lt;E, Object&gt;) map.clone();
            return newSet;
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">          </span>clone返回此 <tt>HashSet</tt> 实例的浅表副本：并没有复制这些元素本身。</span></p><p><span style="font-size:18px;color:#0000ff;"><strong><span style="font-size:14px;">          </span>后记：</strong></span></p><p><span style="font-size:14px;"><span style="font-size:14px;">          </span>由于HashSet底层使用了HashMap实现，使其的实现过程变得非常简单，如果你对HashMap比较了解，那么HashSet简直是小菜一碟。有两个方法对HashMap和HashSet而言是非常重要的，下篇将详细讲解hashcode和equals。</span></p><p><span style="font-size:14px;">---------------------------------------------------------------------------------------------------------</span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><span style="color:#3333FF;">      原文出自：http://cmsblogs.com/?p=599</span></span></span></p><p><span style="font-size:14px;"><span style="font-size:14px;"><span style="color:#3333FF;">      关注我的个人站点：http://www.cmsblogs.com</span></span><br/></span></p>
<div>
    作者：chenssy 发表于2014/3/24 21:26:07 <a href="http://blog.csdn.net/chenssy/article/details/21988605" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：12464 评论：7 <a href="http://blog.csdn.net/chenssy/article/details/21988605#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二三）-----HashMap</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">
<span style="font-size:18px;"><strong><span></span></strong></span><p><span style="font-size:14px;">     <span style="color:#FF0000;"> &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;原文参见：</span><a href="http://cmsblogs.com/?p=176" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">http://cmsblogs.com/?p=176</a><br/></span></p><p><span style="font-size:14px;">      HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</span></p><h1><span style="font-size:14px;">       </span>一、定义</h1><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map，这里标注Map LZ觉得应该是更加清晰吧！</span></p><p><span style="font-size:14px;"></span></p><pre>public class HashMap&lt;K,V&gt;
    extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable</pre><p></p><h1>      二、构造函数</h1><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap提供了三个构造函数：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。</span></p><p><span style="font-size:14px;"><br/></span></p><h1><span style="font-size:14px;color:#FF0000;">       </span><span style="color:#FF0000;">三、数据结构</span></h1><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：</span></p><p><img src="RSS-CSDN博客推荐文章_files/SouthEast [25].png" type="image/png" data-filename="SouthEast.png" alt="" height="427" width="348"/><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码：</span></p><p><span style="font-size:14px;"></span></p><pre>public HashMap(int initialCapacity, float loadFactor) {
        //初始容量不能&lt;0
        if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot;
                    + initialCapacity);
        //初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        //负载因子不能 &lt; 0
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot;
                    + loadFactor);

        // 计算出大于 initialCapacity 的最小的 2 的 n 次方值。
        int capacity = 1;
        while (capacity &lt; initialCapacity)
            capacity &lt;&lt;= 1;
        
        this.loadFactor = loadFactor;
        //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作
        threshold = (int) (capacity * loadFactor);
        //初始化table数组
        table = new Entry[capacity];
        init();
    }</pre><br/><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>从源码中可以看出，每次新建一个HashMap时，都会初始化一个table数组。table数组的元素为Entry节点。</span></p><p><span style="font-size:14px;"></span></p><pre>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final K key;
        V value;
        Entry&lt;K,V&gt; next;
        final int hash;

        /**
         * Creates new entry.
         */
        Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
            value = v;
            next = n;
            key = k;
            hash = h;
        }
        .......
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>其中Entry为HashMap的内部类，它包含了键key、值value、下一个节点next，以及hash值，这是非常重要的，正是由于Entry才构成了table数组的项为链表。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>上面简单分析了HashMap的数据结构，下面将探讨HashMap是如何实现快速存取的。</span></p><h1><span style="font-size:14px;">       </span>四、存储实现：put(key,vlaue)</h1><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>首先我们先看源码</span></p><p><span style="font-size:14px;"></span></p><pre>public V put(K key, V value) {
        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因
        if (key == null)
            return putForNullKey(value);
        //计算key的hash值
        int hash = hash(key.hashCode());                  ------(1)
        //计算key hash 值在 table 数组中的位置
        int i = indexFor(hash, table.length);             ------(2)
        //从i出开始迭代 e,找到 key 保存的位置
        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {
            Object k;
            //判断该条链上是否有hash值相同的(key相同)
            //若存在相同，则直接覆盖value，返回旧value
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {
                V oldValue = e.value;    //旧值 = 新值
                e.value = value;
                e.recordAccess(this);
                return oldValue;     //返回旧值
            }
        }
        //修改次数增加1
        modCount++;
        //将key、value添加至i位置处
        addEntry(hash, key, value, i);
        return null;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。这个过程看似比较简单，其实深有内幕。有如下几点：</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1、 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>2、 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。</span></p><p><span style="font-size:14px;"></span></p><pre>static int hash(int h) {
        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);
        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。</span></p><p><span style="font-size:14px;"></span></p><pre>static int indexFor(int h, int length) {
        return h &amp; (length-1);
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。</span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>这里我们假设length为16(2^n)和15，h为5、6、7。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast.jpg" type="image/jpeg" data-filename="SouthEast.jpg" alt="" height="211" width="590"/><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>当n=15时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低。诚然这里只分析三个数字不是很多，那么我们就看0-15。</span></p><p align="center"><img src="RSS-CSDN博客推荐文章_files/SouthEast [1].jpg" type="image/jpeg" data-filename="SouthEast.jpg" alt="" height="381" width="596"/><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>从上面的图表中我们看到总共发生了8此碰撞，同时发现浪费的空间非常大，有1、3、5、7、9、11、13、15处没有记录，也就是没有存放数据。这是因为他们在与14进行&amp;运算时，得到的结果最后一位永远都是0，即0001、0011、0101、0111、1001、1011、1101、1111位置处是不可能存储数据的，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢。而当length = 16时，length – 1 = 15 即1111，那么进行低位&amp;运算时，值总是与原来hash值相同，而进行高位运算时，其值等于其低位值。<span style="color:#0000ff;">所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。</span></span></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>这里我们再来复习put的流程：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。具体的实现过程见addEntry方法，如下：</span></p><p><span style="font-size:14px;"></span></p><pre>void addEntry(int hash, K key, V value, int bucketIndex) {
        //获取bucketIndex处的Entry
        Entry&lt;K, V&gt; e = table[bucketIndex];
        //将新创建的 Entry 放入 bucketIndex 索引处，并让新的 Entry 指向原来的 Entry 
        table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e);
        //若HashMap中元素的个数超过极限了，则容量扩大两倍
        if (size++ &gt;= threshold)
            resize(2 * table.length);
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>这个方法中有两点需要注意：</span></p><p><span style="font-size:14px;"><strong><span style="color:#0000ff;"><span style="font-size:14px;">      </span>一是链的产生。</span></strong>这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。</span></p><p><strong><span style="color:#0000ff;"><span style="font-size:14px;">       </span>二、扩容问题。</span></strong></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>随着HashMap中元素的数量越来越多，发生碰撞的概率就越来越大，所产生的链表长度就会越来越长，这样势必会影响HashMap的速度，为了保证HashMap的效率，系统必须要在某个临界点进行扩容处理。该临界点在当HashMap中元素的数量等于table数组长度*加载因子。但是扩容是一个非常耗时的过程，因为它需要重新计算这些数据在新table数组中的位置并进行复制处理。所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</span></p><h1><span style="font-size:14px;">       </span>五、读取实现：get(key)</h1><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>相对于HashMap的存而言，取就显得比较简单了。通过key的hash值找到在table数组中的索引处的Entry，然后返回该key对应的value即可。</span></p><p><span style="font-size:14px;"></span></p><pre>public V get(Object key) {
        // 若为null，调用getForNullKey方法返回相对应的value
        if (key == null)
            return getForNullKey();
        // 根据该 key 的 hashCode 值计算它的 hash 码  
        int hash = hash(key.hashCode());
        // 取出 table 数组中指定索引处的值
        for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) {
            Object k;
            //若搜索的key与查找的key相同，则返回相对应的value
            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))
                return e.value;
        }
        return null;
    }</pre><p></p><p><span style="font-size:14px;"><span style="font-size:14px;">       </span>在这里能够根据key快速的取到value除了和HashMap的数据结构密不可分外，还和Entry有莫大的关系，在前面就提到过，HashMap在存储过程中并没有将key，value分开来存储，而是当做一个整体key-value来处理的，这个整体就是Entry对象。同时value也只相当于key的附属而已。在存储的过程中，系统根据key的hashcode来决定Entry在table数组中的存储位置，在取的过程中同样根据key的hashcode取出相对应的Entry对象。</span></p><p><br/></p><p><span style="font-size:14px;"><span style="font-size:14px;"><span style="font-size:18px;"><span style="font-weight:bold;"><span><span style="color:#0000ff;">&gt;&gt;&gt;&gt;&gt;&gt;欢迎各位关注我的个人站点</span>：<span style="color:#ff0000;"><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://cmsblogs.com/"><span style="color:#ff0000;">http://cmsblogs.com/</span></a></span></span></span></span><br/></span></span></p><p><br/></p><br/>
<div>
    作者：chenssy 发表于2014/1/15 21:41:46 <a href="http://blog.csdn.net/chenssy/article/details/18323767" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：9012 评论：13 <a href="http://blog.csdn.net/chenssy/article/details/18323767#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/18099417" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二二）-----LinkedList</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">

<h1>      一、概述</h1>
<p><span style="font-size:14px;">       LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>LinkedList实现所有可选的列表操作，并允许所有的元素包括null。</span></p>
<p><span style="font-size:14px;">除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</span></p>
<p><span style="font-size:14px;">同时，与ArrayList一样此实现不是同步的。</span></p>
<p><span style="font-size:14px;">（以上摘自JDK 6.0 API）。</span></p>
<p><span style="font-size:14px;"><br/>
</span></p>
<h1><span style="font-size:14px;">       </span>二、源码分析</h1>
<h2><span style="font-size:14px;">       </span>2.1、定义</h2>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>首先我们先看LinkedList的定义：</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>public class LinkedList&lt;E&gt;
    extends AbstractSequentialList&lt;E&gt;
    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性
 collection，支持在两端插入和移除元素，定义了双端队列的操作。</span></p>
<h2><span style="font-size:14px;">       </span>2.2、属性</h2>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>在LinkedList中提供了两个基本属性size、header。</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null);
private transient int size = 0;</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>private static class Entry&lt;E&gt; {
        E element;        //元素节点
        Entry&lt;E&gt; next;    //下一个元素
        Entry&lt;E&gt; previous;  //上一个元素

        Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) {
            this.element = element;
            this.next = next;
            this.previous = previous;
        }
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</span></p>
<h2><span style="font-size:14px;">       </span>2.3、构造方法</h2>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>LinkedList提高了两个构造方法：LinkedLis()和LinkedList(Collection&lt;? extends E&gt; c)。</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>/**
     *  构造一个空列表。
     */
    public LinkedList() {
        header.next = header.previous = header;
    }
    
    /**
     *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。
     */
    public LinkedList(Collection&lt;? extends E&gt; c) {
        this();
        addAll(c);
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>/**
     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。
     */
    public boolean addAll(Collection&lt;? extends E&gt; c) {
        return addAll(size, c);
    }
    
    /**
     * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引
     */
    public boolean addAll(int index, Collection&lt;? extends E&gt; c) {
        //若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常
        if (index &lt; 0 || index &gt; size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot; + size);
        Object[] a = c.toArray();
        int numNew = a.length;    //插入元素的个数
        //若插入的元素为空，则返回false
        if (numNew == 0)
            return false;
        //modCount:在AbstractList中定义的，表示从结构上修改列表的次数
        modCount++;
        //获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点
        Entry&lt;E&gt; successor = (index == size ? header : entry(index));
        //插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素
        Entry&lt;E&gt; predecessor = successor.previous;
        //执行插入动作
        for (int i = 0; i &lt; numNew; i++) {
            //构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用
            //
            Entry&lt;E&gt; e = new Entry&lt;E&gt;((E) a[i], successor, predecessor);
            //将插入位置前一个节点的下一个元素引用指向当前元素
            predecessor.next = e;
            //修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序
            predecessor = e;
        }
        successor.previous = predecessor;
        //修改容量大小
        size += numNew;
        return true;
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>/**
     * 返回指定位置(若存在)的节点元素
     */
    private Entry&lt;E&gt; entry(int index) {
        if (index &lt; 0 || index &gt;= size)
            throw new IndexOutOfBoundsException(&quot;Index: &quot; + index + &quot;, Size: &quot;
                    + size);
        //头部节点
        Entry&lt;E&gt; e = header;
        //判断遍历的方向
        if (index &lt; (size &gt;&gt; 1)) {
            for (int i = 0; i &lt;= index; i++)
                e = e.next;
        } else {
            for (int i = size; i &gt; index; i--)
                e = e.previous;
        }
        return e;
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。</span></p>
<p><span style="font-size:14px;">由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</span></p>
<h2><span style="font-size:14px;">       </span>2.4、增加方法</h2>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>add(E e): 将指定元素添加到此列表的结尾。</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>public boolean add(E e) {
    addBefore(e, header);
        return true;
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) {
        //利用Entry构造函数构建一个新节点 newEntry，
        Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous);
        //修改newEntry的前后节点的引用，确保其链表的引用关系是正确的
        newEntry.previous.next = newEntry;
        newEntry.next.previous = newEntry;
        //容量+1
        size++;
        //修改次数+1
        modCount++;
        return newEntry;
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>LinkedList还提供了其他的增加方法：</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>add(int index, E element)：在此列表中指定的位置插入指定的元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>AddFirst(E e): 将指定元素插入此列表的开头。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>addLast(E e): 将指定元素添加到此列表的结尾。</span></p>
<h2><span style="font-size:14px;">       </span>2.5、移除方法</h2>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>public boolean remove(Object o) {
        if (o==null) {
            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {
                if (e.element==null) {
                    remove(e);
                    return true;
                }
            }
        } else {
            for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) {
                if (o.equals(e.element)) {
                    remove(e);
                    return true;
                }
            }
        }
        return false;
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry&lt;E&gt; e)，remove(Entry&lt;E&gt; e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</span></p>
<p><span style="font-size:14px;"></span></p>
<pre>private E remove(Entry&lt;E&gt; e) {
        if (e == header)
            throw new NoSuchElementException();

        //保留被移除的元素：要返回
        E result = e.element;
        
        //将该节点的前一节点的next指向该节点后节点
        e.previous.next = e.next;
        //将该节点的后一节点的previous指向该节点的前节点
        //这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的
        e.next.previous = e.previous;
        //将该节点归空
        e.next = e.previous = null;
        e.element = null;
        size--;
        modCount++;
        return result;
    }</pre>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>其他的移除方法：</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>clear()： 从此列表中移除所有元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>remove()：获取并移除此列表的头（第一个元素）。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>remove(int index)：移除此列表中指定位置处的元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>removeFirst()：移除并返回此列表的第一个元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>removeLast()：移除并返回此列表的最后一个元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。</span></p>
<h2><span style="font-size:14px;">       </span>2.5、查找方法</h2>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>get(int index)：返回此列表中指定位置处的元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>getFirst()：返回此列表的第一个元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>getLast()：返回此列表的最后一个元素。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。</span></p>
<p><br/>
</p>
<p><span style="font-size:14px;"><span style="font-size:18px;"><strong><span><span style="color:#0000ff;">       &gt;&gt;&gt;&gt;&gt;&gt;欢迎各位关注我的个人站点</span>：<span style="color:#ff0000;"><a href="http://cmsblogs.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://cmsblogs.com/"><span style="color:#ff0000;">http://cmsblogs.com/</span></a></span></span></strong></span><br/>
</span></p>
<p><br/>
</p>

<div>
    作者：chenssy 发表于2014/1/10 23:00:39 <a href="http://blog.csdn.net/chenssy/article/details/18099417" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：4617 评论：1 <a href="http://blog.csdn.net/chenssy/article/details/18099417#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/17732841" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（二十）-----集合大家族</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">

<p><span style="font-size:14px;">       在编写java程序中，我们最常用的除了八种基本数据类型，String对象外还有一个集合类，在我们的的程序中到处充斥着集合类的身影！java中集合大家族的成员实在是太丰富了，有常用的ArrayList、HashMap、HashSet，也有不常用的Stack、Queue，有线程安全的Vector、HashTable，也有线程不安全的LinkedList、TreeMap等等！</span></p>
<p align="center"><span style="font-size:14px;"><img src="RSS-CSDN博客推荐文章_files/SouthEast [26].png" type="image/png" data-filename="SouthEast.png" alt="" height="665" width="674"/><br/>
</span></p>
<p></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>上面的图展示了整个集合大家族的成员以及他们之间的关系。下面就上面的各个接口、基类做一些简单的介绍(主要介绍各个集合的特点。区别)，更加详细的介绍会在不久的将来一一讲解。</span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       一、Collection接口
</span></span></h1>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       二、List接口</span></span></h1>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</span></p>
<h3><span style="font-size:14px;color:#0000ff;background-color:#ffffff;"><span style="font-size:14px;">      
</span>2.1、ArrayList</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以<span style="color:#0000ff;">如果我们明确所插入元素的多少，最好指定一个初始容量值</span><span style="color:#0000ff;">，避免过多的进行扩容操作而浪费时间、效率</span>。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</span></p>
<p><span style="font-size:14px;color:#0000ff;">ArrayList擅长于随机访问。同时ArrayList是非同步的。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>2.2、LinkedList</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：
<br/>
List list = Collections.synchronizedList(new LinkedList(...));</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>2.3、Vector</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>2.4、Stack</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       三、Set接口</span></span></h1>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>3.1、EnumSet</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>是枚举的专用Set。所有的元素都是枚举类型。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>3.2、HashSet</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>3.3、TreeSet</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的
<code>Comparator</code> 进行排序，具体取决于使用的构造方法。 </span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       四、Map接口</span></span></h1>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>4.1、HashMap</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>4.2、TreeMap</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>4.3、HashTable</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低</span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       五、Queue</span></span></h1>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       六、异同点</span></span></h1>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>出处：<a href="http://blog.csdn.net/softwave/article/details/4166598" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://blog.csdn.net/softwave/article/details/4166598">http://blog.csdn.net/softwave/article/details/4166598</a></span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>6.1、Vector和ArrayList</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1，vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用arraylist效率比较高。
<br/>
<span style="font-size:14px;">       </span>2，如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。
<br/>
<span style="font-size:14px;">       </span>3，如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>6.2、A<strong>arraylist和Linkedlist</strong></span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。
<br/>
<span style="font-size:14px;">       </span>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。
<br/>
<span style="font-size:14px;">       </span>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。
<br/>
这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>6.3、HashMap与TreeMap</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1、HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。HashMap中元素的排列顺序是不固定的）。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>2、 HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。集合框架”提供两种常规的Map实现：HashMap和TreeMap (TreeMap实现SortedMap接口)。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>3、在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>6.4、hashtable与hashmap</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1、历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>2、同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>3、值：只有HashMap可以让你将空值作为一个表的条目的key或value 。</span></p>
<h1><span style="font-size:14px;"><span style="font-size:24px;">       七、对集合的选择</span></span></h1>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>7.1、对List的选择</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1、对于随机查询与迭代遍历操作，数组比所有的容器都要快。所以在随机访问中一般使用ArrayList</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>2、LinkedList使用双向链表对元素的增加和删除提供了非常好的支持，而ArrayList执行增加和删除元素需要进行元素位移。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>3、对于Vector而已，我们一般都是避免使用。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>4、将ArrayList当做首选，毕竟对于集合元素而已我们都是进行遍历，只有当程序的性能因为List的频繁插入和删除而降低时，再考虑LinkedList。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>7.2、对Set的选择</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1、HashSet由于使用HashCode实现，所以在某种程度上来说它的性能永远比TreeSet要好，尤其是进行增加和查找操作。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>3、虽然TreeSet没有HashSet性能好，但是由于它可以维持元素的排序，所以它还是存在用武之地的。</span></p>
<h3><span style="font-size:14px;color:#0000ff;"><span style="font-size:14px;">      
</span>7.3、对Map的选择</span></h3>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>1、HashMap与HashSet同样，支持快速查询。虽然HashTable速度的速度也不慢，但是在HashMap面前还是稍微慢了些，所以HashMap在查询方面可以取代HashTable。</span></p>
<p><span style="font-size:14px;"><span style="font-size:14px;">       </span>2、由于TreeMap需要维持内部元素的顺序，所以它通常要比HashMap和HashTable慢。</span></p>
<p><span style="font-size:14px;"><br/>
</span></p>
<p></p>
<p><span style="font-size:14px;color:#0000ff;"><strong><span style="font-size:14px;">      
</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;我的个人网站：</strong></span><span style="font-size:14px;"><a href="http://chenssy.gotoip55.com/" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank"><span style="color:#0000ff;"><strong>CMSBLOGS|.com</strong></span></a></span></p>

<div>
    作者：chenssy 发表于2014/1/1 10:52:23 <a href="http://blog.csdn.net/chenssy/article/details/17732841" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：3605 评论：2 <a href="http://blog.csdn.net/chenssy/article/details/17732841#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/17732815" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇（十九）-----数组之二</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">

<p><span style="font-size:18px;">        前面一节主要介绍了数组的基本概念，对什么是数组稍微深入了一点点，在这篇博文中主要介绍数组的其他方面。</span></p>
<h1>      三、性能？请优先考虑数组</h1>
<p><span style="font-size:18px;">       在java中有很多方式来存储一系列数据，而且在操作上面比数组方便的多？但为什么我们还需要使用数组，而不是替代它呢？数组与其他种类的容器之间的区别有三个方面：效率、类型和保存基本类型的能力。<u><span style="color:#0000ff;">在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。</span></u></span></p>
<p><span style="font-size:18px;color:#000000;"><span style="font-size:18px;">      
</span>在项目设计中数组使用的越来越少了，而且它确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。</span></p>
<p><span style="font-size:18px;color:#000000;"></span></p><pre>--------这是ArrayList的add()------
    public boolean add(E e) {
    ensureCapacity(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>下面利用数组和list来做一些操作比较。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>一、求和</span></p>
<p></p><pre>Long time1 = System.currentTimeMillis();
        for(int i = 0 ; i &lt; 100000000 ;i++){
            sum += arrays[i%10];
        }
        Long time2 = System.currentTimeMillis();
        System.out.println(&quot;数组求和所花费时间：&quot; + (time2 - time1) + &quot;毫秒&quot;);
        Long time3 = System.currentTimeMillis();
        for (int i = 0; i &lt; 100000000; i++) {
            sum  += list.get(i%10);
        }
        Long time4 = System.currentTimeMillis();
        System.out.println(&quot;List求和所花费时间：&quot; + (time4 - time3) + &quot;毫秒&quot;);
--------------Output:
数组求和所花费时间：696毫秒
List求和所花费时间：3498毫秒</pre><br/>
<p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。</span></p>
<p><strong><span style="font-size:18px;color:#0000ff;"><span style="font-size:18px;">      
</span>所以在性能要求较高的场景中请优先考虑数组。</span></strong></p>
<h1><span style="font-size:18px;">       </span>四、变长数组？</h1>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>数组是定长的，一旦初始化声明后是不可改变长度的<span style="color:#444444;background-color:rgb(255,255,255);">。这对我们在实际开发中是非常不方便的，聪明的我们肯定是可以找到方法来实现的。就如java不能实现多重继承一样，我们一样可以利用内部类和接口来实现(请参考：<a href="http://blog.csdn.net/chenssy/article/details/13168265" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇(九)-----实现多重继承</a>)。</span></span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>那么如何来实现变长数组呢？我们可以利用List集合add方法里面的扩容思路来模拟实现。下面是ArrayList的扩容方法:</span></p>
<p><span style="font-size:18px;"></span></p><pre>public void ensureCapacity(int minCapacity) {
        modCount++;  
        int oldCapacity = elementData.length;
        /**
         * 若当前需要的长度超过数组长度时进行扩容处理
         */
        if (minCapacity &gt; oldCapacity) {
            Object oldData[] = elementData;    
            int newCapacity = (oldCapacity * 3) / 2 + 1;    //扩容
            if (newCapacity &lt; minCapacity)
                newCapacity = minCapacity;
            //拷贝数组，生成新的数组
            elementData = Arrays.copyOf(elementData, newCapacity);
        }
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>这段代码对我们有用的地方就在于if语句后面。它的思路是将原始数组拷贝到新数组中，新数组是原始数组长度的1.5倍。所以模拟的数组扩容代码如下：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class ArrayUtils {
    /**
     * @desc 对数组进行扩容
     * @author chenssy
     * @data 2013-12-8
     * @param &lt;T&gt;
     * @param datas 原始数组
     * @param newLen 扩容大小
     * @return T[]
     */
    public static &lt;T&gt; T[] expandCapacity(T[] datas,int newLen){
        newLen = newLen &lt; 0 ? datas.length :datas.length + newLen;   
        //生成一个新的数组
        return Arrays.copyOf(datas, newLen);
    }
    
    /**
     * @desc 对数组进行扩容处理，1.5倍
     * @author chenssy
     * @data 2013-12-8
     * @param &lt;T&gt;
     * @param datas  原始数组
     * @return T[]
     */
    public static &lt;T&gt; T[] expandCapacity(T[] datas){
        int newLen = (datas.length * 3) / 2;      //扩容原始数组的1.5倍
        //生成一个新的数组
        return Arrays.copyOf(datas, newLen);
    }
    
    /**
     * @desc 对数组进行扩容处理，
     * @author chenssy
     * @data 2013-12-8
     * @param &lt;T&gt;
     * @param datas 原始数组
     * @param mulitiple 扩容的倍数
     * @return T[]
     */
    public static &lt;T&gt; T[] expandCapacityMul(T[] datas,int mulitiple){
        mulitiple = mulitiple &lt; 0 ? 1 : mulitiple;
        int newLen = datas.length * mulitiple;
        return Arrays.copyOf(datas,newLen );
    }
}</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>通过这种迂回的方式我们可以实现数组的扩容。因此在项目中如果确实需要变长的数据集，数组也是在考虑范围之内的，我们不能因为他是固定长度而排斥他！</span></p>
<h1><span style="font-size:18px;">       </span>五、数组复制问题</h1>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>以前在做集合拷贝的时候由于集合没有拷贝的方法，所以一个一个的复制是非常麻烦的，所以我就干脆使用List.toArray()方法转换成数组然后再通过Arrays.copyOf拷贝，在转换成集合，个人觉得非常方便，殊不知我已经陷入了其中的陷进！我们知道若数组元素为对象，则数组里面数据是对象引用</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Test {
    public static void main(String[] args) {
        Person person_01 = new Person(&quot;chenssy_01&quot;);
        
        Person[] persons1 = new Person[]{person_01};
        Person[] persons2 = Arrays.copyOf(persons1,persons1.length);
        
        System.out.println(&quot;数组persons1:&quot;);
        display(persons1);
        System.out.println(&quot;---------------------&quot;);
        System.out.println(&quot;数组persons2:&quot;);
        display(persons2);
        //改变其值
        persons2[0].setName(&quot;chessy_02&quot;);
        System.out.println(&quot;------------改变其值后------------&quot;);
        System.out.println(&quot;数组persons1:&quot;);
        display(persons1);
        System.out.println(&quot;---------------------&quot;);
        System.out.println(&quot;数组persons2:&quot;);
        display(persons2);
    }
    public static void display(Person[] persons){
        for(Person person : persons){
            System.out.println(person.toString());
        }
    }
}
-------------Output:
数组persons1:
姓名是：chenssy_01
---------------------
数组persons2:
姓名是：chenssy_01
------------改变其值后------------
数组persons1:
姓名是：chessy_02
---------------------
数组persons2:
姓名是：chessy_02</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>从结果中发现,persons1中的值也发生了改变，这是典型的浅拷贝问题。所以通过Arrays.copyOf()方法产生的数组是一个浅拷贝。同时数组的clone()方法也是，集合的clone()方法也是，所以我们在使用拷贝方法的同时一定要注意浅拷贝这问题。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>有关于深浅拷贝的博文，参考：</span></p>
<h3><span style="color:#0000ff;"><span style="font-weight:normal;"><span style="color:#0000ff;"><span style="font-size:18px;">      
</span>渐析java的浅拷贝和深拷贝：</span></span><span style="font-size:18px;"><a href="http://www.cnblogs.com/chenssy/p/3308489.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/chenssy/p/3308489.html"><span style="color:#0000ff;font-weight:normal;">http://www.cnblogs.com/chenssy/p/3308489.html</span></a><span style="color:#0000ff;font-weight:normal;">。</span></span></span></h3>
<h3><span style="color:#0000ff;font-weight:normal;"><span style="font-size:18px;">      
</span>使用序列化实现对象的拷贝：</span><a href="http://www.cnblogs.com/chenssy/p/3382979.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/chenssy/p/3382979.html"><span style="color:#0000ff;font-weight:normal;"></span></a>http://blog.csdn.net/chenssy/article/details/12952063<span style="color:#0000ff;font-weight:normal;"></span></h3>
<h1><span style="font-size:18px;">       </span>六、数组转换为List注意地方</h1>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表。方便是方便，但是有时候会出现莫名其妙的问题。如下：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public static void main(String[] args) {
        int[] datas = new int[]{1,2,3,4,5};
        List list = Arrays.asList(datas);
        System.out.println(list.size());
    }
------------Output:
1</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>结果是1,是的你没有看错, 结果就是1。但是为什么会是1而不是5呢？先看asList()的源码</span></p>
<p><span style="font-size:18px;"></span></p><pre>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
        return new ArrayList&lt;T&gt;(a);
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>注意这个参数:T…a，这个参数是一个泛型的变长参数，我们知道基本数据类型是不可能泛型化的，也是就说8个基本数据类型是不可作为泛型参数的，但是为什么编译器没有报错呢？这是因为在java中，数组会当做一个对象来处理，它是可以泛型的，所以我们的程序是把一个int型的数组作为了T的类型，所以在转换之后List中就只会存在一个类型为int数组的元素了。所以我们这样的程序System.out.println(datas.equals(list.get(0)));输出结果肯定是true。当然如果将int改为Integer，则长度就会变成5了。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>我们在看下面程序：</span></p>
<p><span style="font-size:18px;"></span></p><pre>enum Week{Sum,Mon,Tue,Web,Thu,Fri,Sat}
    public static void main(String[] args) {
        Week[] weeks = {Week.Sum,Week.Mon,Week.Tue,Week.Web,Week.Thu,Week.Fri};
        List&lt;Week&gt; list = Arrays.asList(weeks);
        list.add(Week.Sat);
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>这个程序非常简单，就是讲一个数组转换成list，然后改变集合中值，但是运行呢？</span></p>
<p><span style="font-size:18px;"></span></p><pre>Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
    at java.util.AbstractList.add(AbstractList.java:131)
    at java.util.AbstractList.add(AbstractList.java:91)
    at com.array.Test.main(Test.java:18)</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>编译没错，但是运行竟然出现了异常错误！UnsupportedOperationException ，当不支持请求的操作时，就会抛出该异常。从某种程度上来说就是不支持add方法，我们知道这是不可能的！什么原因引起这个异常呢？先看asList()的源代码：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
        return new ArrayList&lt;T&gt;(a);
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>这里是直接返回一个ArrayList对象返回，但是注意这个ArrayList并不是java.util.ArrayList,而是Arrays工具类的一个内之类：</span></p>
<p><span style="font-size:18px;"></span></p><pre>private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;
    implements RandomAccess, java.io.Serializable{
        private static final long serialVersionUID = -2764017481108945198L;
        private final E[] a;
        ArrayList(E[] array) {
            if (array==null)
                throw new NullPointerException();
        a = array;
    }
       /** 省略方法 **/
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>但是这个内部类并没有提供add()方法，那么查看父类：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public boolean add(E e) {
    add(size(), e);
    return true;
    }
    public void add(int index, E element) {
    throw new UnsupportedOperationException();
    }</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>这里父类仅仅只是提供了方法，方法的具体实现却没有，所以具体的实现需要子类自己来提供，但是非常遗憾</span></p>
<p><span style="font-size:18px;">这个内部类ArrayList并没有提高add的实现方法。在ArrayList中，它主要提供了如下几个方法：</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>1、size：元素数量</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>2、toArray：转换为数组，实现了数组的浅拷贝。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>3、get：获得指定元素。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>4、contains：是否包含某元素。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>所以综上所述，asList返回的是一个长度不可变的列表。数组是多长，转换成的列表是多长，我们是无法通过add、remove来增加或者减少其长度的。</span></p>
<p><span style="font-size:18px;color:#0000ff;">       <u>参考文献：《编写高质量代码--改善Java程序的151个建议》</u></span></p>
<p><br/>
</p>

<div>
    作者：chenssy 发表于2014/1/1 10:41:48 <a href="http://blog.csdn.net/chenssy/article/details/17732815" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：2768 评论：0 <a href="http://blog.csdn.net/chenssy/article/details/17732815#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/17732783" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇(十八)-----数组之一：认识JAVA数组</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">

<blockquote>
<p><span style="font-size:18px;color:#0000ff;"><strong>噢，它明白了，河水既没有牛伯伯说的那么浅，也没有小松鼠说的那么深，只有自己亲自试过才知道！道听途说永远只能看到表明现象，只有亲自试过了，才知道它的深浅！！！！！</strong></span></p>
</blockquote>
<h1>      一、什么是数组</h1>
<p><span style="font-size:18px;">       数组？什么是数组？在我印象中的数组是应该这样的：通过new关键字创建并组装他们，通过使用整形索引值访问它的元素，并且它的尺寸是不可变的！</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>但是这只是数组的最表面的东西！深一点？就是这样：数组是一个简单的复合数据类型，它是一系列有序数据的集合，它当中的每一个数据都具有相同的数据类型，我们通过数组名加上一个不会越界下标值来唯一确定数组中的元素。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>还有更深的，那就是数组是一个特殊的对象！！（对于这个LZ理解的不是很好，对JVM也没有看，所以见解有限）。以下参考文献：<a href="http://developer.51cto.com/art/201001/176671.htm" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://developer.51cto.com/art/201001/176671.htm">http://developer.51cto.com/art/201001/176671.htm</a>、<a href="http://www.blogjava.net/flysky19/articles/92763.html?opt=admin" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.blogjava.net/flysky19/articles/92763.html?opt=admin">http://www.blogjava.net/flysky19/articles/92763.html?opt=admin</a></span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>不管在其他语言中数组是什么，在java中它就是对象。一个比较特殊的对象。</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Test {
    public static void main(String[] args) {
        int[] array = new int[10];
        System.out.println(&quot;array的父类是：&quot; + array.getClass().getSuperclass());
        System.out.println(&quot;array的类名是：&quot; + array.getClass().getName());
    }
}
-------Output:
array的父类是：class java.lang.Object
array的类名是：[I</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>从上面示例可以看出,数组的是Object的直接子类,它属于“第一类对象”，但是它又与普通的java对象存在很大的不同，从它的类名就可以看出：[I，这是什么东东？？在JDK中我就没有找到这个类，话说这个&quot;[I”都不是一个合法标识符。怎么定义成类啊？所以我认为SUM那帮天才肯定对数组的底层肯定做了特殊的处理。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>我们再看如下示例：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Test {
    public static void main(String[] args) {
        int[] array_00 = new int[10];
        System.out.println(&quot;一维数组：&quot; + array_00.getClass().getName());
        int[][] array_01 = new int[10][10];
        System.out.println(&quot;二维数组：&quot; + array_01.getClass().getName());
        
        int[][][] array_02 = new int[10][10][10];
        System.out.println(&quot;三维数组：&quot; + array_02.getClass().getName());
    }
}
-----------------Output:
一维数组：[I
二维数组：[[I
三维数组：[[[I</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>通过这个实例我们知道：[代表了数组的维度，一个[表示一维，两个[表示二维。可以简单的说数组的类名由若干个'['和数组元素类型的内部名称组成。不清楚我们再看：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;Object[]:&quot; + Object[].class);
        System.out.println(&quot;Object[][]:&quot; + Object[][].class);
        System.err.println(&quot;Object[][][]:&quot; + Object[][][].class);
        System.out.println(&quot;Object:&quot; + Object.class);
    }
}
---------Output:
Object[]:class [Ljava.lang.Object;
Object[][]:class [[Ljava.lang.Object;
Object[][][]:class [[[Ljava.lang.Object;
Object:class java.lang.Object</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>从这个实例我们可以看出数组的“庐山真面目”。同时也可以看出数组和普通的Java类是不同的，普通的java类是以全限定路径名+类名来作为自己的唯一标示的，而数组则是以若干个[+L+数组元素类全限定路径+类来最为唯一标示的。这个不同也许在某种程度上说明了数组也普通java类在实现上存在很大的区别，也许可以利用这个区别来使得JVM在处理数组和普通java类时作出区分。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>我们暂且不论这个[I是什么东东，是由谁来声明的，怎么声明的（这些我现在也不知道！但是有一点可以确认：这个是在运行时确定的）。先看如下：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Test {
    public static void main(String[] args) {
        int[] array = new int[10];
        Class clazz = array.getClass();   
        System.out.println(clazz.getDeclaredFields().length);   
        System.out.println(clazz.getDeclaredMethods().length);   
        System.out.println(clazz.getDeclaredConstructors().length);   
        System.out.println(clazz.getDeclaredAnnotations().length);   
        System.out.println(clazz.getDeclaredClasses().length);   
    }
}
----------------Output：
0
0
0
0
0</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>从这个运行结果可以看出，我们亲爱的[I没有生命任何成员变量、成员方法、构造函数、Annotation甚至连length成员变量这个都没有，它就是一个彻彻底底的空类。没有声明length，那么我们array.length时，编译器怎么不会报错呢？确实，数组的length是一个非常特殊的成员变量。我们知道数组的是Object的直接之类，但是Object是没有length这个成员变量的，那么length应该是数组的成员变量，但是从上面的示例中，我们发现数组根本就没有任何成员变量，这两者不是相互矛盾么？</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Main {
    public static void main(String[] args) {
        int a[] = new int[2];
        int i = a.length;
    }
}</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>打开class文件，得到main方法的字节码：</span></p>
<p><span style="font-size:18px;"></span></p><pre>0 iconst_2                   //将int型常量2压入操作数栈  
    1 newarray 10 (int)          //将2弹出操作数栈，作为长度，创建一个元素类型为int, 维度为1的数组，并将数组的引用压入操作数栈  
    3 astore_1                   //将数组的引用从操作数栈中弹出，保存在索引为1的局部变量(即a)中  
    4 aload_1                    //将索引为1的局部变量(即a)压入操作数栈  
    5 arraylength                //从操作数栈弹出数组引用(即a)，并获取其长度(JVM负责实现如何获取)，并将长度压入操作数栈  
    6 istore_2                   //将数组长度从操作数栈弹出，保存在索引为2的局部变量(即i)中  
    7 return                     //main方法返回</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>在这个字节码中我们还是没有看到length这个成员变量，但是看到了这个:arraylength ,这条指令是用来获取数组的长度的，所以说JVM对数组的长度做了特殊的处理，它是通过arraylength这条指令来实现的。</span></p>
<h1><span style="font-size:18px;">       </span>二、数组的使用方法 </h1>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>通过上面算是对数组是什么有了一个初步的认识，下面将简单介绍数组的使用方法。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>数组的使用方法无非就是四个步骤：</span><span style="font-size:18px;">声明数组、</span><span style="font-size:18px;">分配空间、</span><span style="font-size:18px;">赋值、处理。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>声明数组：就是告诉计算机数组的类型是什么。有两种形式：int[] array、int array[]。</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>分配空间：告诉计算机需要给该数组分配多少连续的空间，记住是连续的。array = new int[10];</span></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>赋值：赋值就是在已经分配的空间里面放入数据。array[0] = 1 、array[1] = 2……其实分配空间和赋值是一起进行的，也就是完成数组的初始化。有如下三种形式：</span></p>
<p><span style="font-size:18px;"></span></p><pre>int a[] = new int[2];    //默认为0,如果是引用数据类型就为null
        int b[] = new int[] {1,2,3,4,5};    
        int c[] = {1,2,3,4,5};</pre><p></p>
<p><span style="font-size:18px;"><span style="font-size:18px;">       </span>处理：就是对数组元素进行操作。通过数组名+有效的下标来确认数据。</span></p>
<p><span style="font-size:18px;"><strong><span style="color:#ff0000;"><span style="font-size:18px;">      
</span>PS：</span></strong>由于能力有限，所以“什么是数组”主要是参考这篇博文：<a href="http://developer.51cto.com/art/201001/176671.htm" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://developer.51cto.com/art/201001/176671.htm">http://developer.51cto.com/art/201001/176671.htm</a>。下篇将更多的介绍数组的一些特性，例如：效率问题、Array的使用、浅拷贝以及与list之间的转换问题。</span></p>
<p><span style="font-size:18px;"></span></p>

<div>
    作者：chenssy 发表于2014/1/1 10:36:26 <a href="http://blog.csdn.net/chenssy/article/details/17732783" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：3107 评论：2 <a href="http://blog.csdn.net/chenssy/article/details/17732783#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td style="font-family:Verdana, 宋体;font-size:16px;font-weight:bold;border-bottom-style:solid;border-bottom-width:1px;border-bottom-color:rgb(0, 153, 238);"><a href="http://blog.csdn.net/chenssy/article/details/17651971" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇(十七)-----异常(二)</a></td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;">

<p><strong><span style="font-size:18px;"><span style="color:#0000ff;">       承接上篇博文：</span></span></strong><span style="font-size:18px;"><span><a href="http://blog.csdn.net/chenssy/article/details/17651909" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇(十六)-----异常（一）</a></span></span><strong><span style="font-size:18px;"><a href="http://www.cnblogs.com/chenssy/p/3438130.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="java提高篇-----异常(一)"><span style="color:#0000ff;"><span style="text-decoration:underline;"></span></span></a></span></strong></p>
<h1>      五、自定义异常</h1>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>Java确实给我们提供了非常多的异常，但是异常体系是不可能预见所有的希望加以报告的错误，所以Java允许我们自定义异常来表现程序中可能会遇到的特定问题，总之就是一句话：我们不必拘泥于Java中已有的异常类型。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>Java自定义异常的使用要经历如下四个步骤：</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>1、定义一个类继承Throwable或其子类。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>2、添加构造方法(当然也可以不用添加，使用默认构造方法)。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>3、在某个方法类抛出该异常。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>4、捕捉该异常。</span><span style="color:#000000;"> <br/>
</span></p>
<p><span style="color:#000000;"></span></p><pre>/** 自定义异常 继承Exception类 **/
public class MyException extends Exception{
    public MyException(){
        
    }
    
    public MyException(String message){
        super(message);
    }
}

public class Test {
    public void display(int i) throws MyException{
        if(i == 0){
            throw new MyException(&quot;该值不能为0.......&quot;);
        }
        else{
            System.out.println( i / 2);
        }
    }
    
    public static void main(String[] args) {
        Test test = new Test();
        try {
            test.display(0);
            System.out.println(&quot;---------------------&quot;);
        } catch (MyException e) {
            e.printStackTrace();
        }
    }
}</pre><p></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>运行结果：</span></p>
<p><img src="RSS-CSDN博客推荐文章_files/SouthEast [27].png" type="image/png" data-filename="SouthEast.png" alt="" height="80" width="412"/><br/>
</p>
<h1><strong><span style="font-size:18px;"><span style="color:#0000ff;">       </span>
</span></strong>六、异常链</h1>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>在设计模式中有一个叫做责任链模式，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：异常链。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>我们知道每遇到一个异常信息，我们都需要进行try…catch,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个Exception解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>诚然在应用程序中，我们有时候不仅仅只需要封装异常，更需要传递。怎么传递？throws!！binge，正确！！但是如果仅仅只用throws抛出异常，那么你的封装类，怎么办？？</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>我们有两种方式处理异常，一是throws抛出交给上级处理，二是try…catch做具体处理。但是这个与上面有什么关联呢？try…catch的catch块我们可以不需要做任何处理，仅仅只用throw这个关键字将我们封装异常信息主动抛出来。然后在通过关键字throws继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。</span></p>
<p><font size="4"><strong><span style="color:#0000ff;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性。</span></strong></font></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>在异常链的使用中，throw抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在Throwable及其子类中的构造器中都可以接受一个cause参数，该参数保存了原有的异常信息，通过getCause()就可以获取该原始异常信息。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>语法：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public void test() throws XxxException{
        try {
            //do something:可能抛出异常信息的代码块
        } catch (Exception e) {
            throw new XxxException(e);
        }
    }</pre><p></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>示例：</span></p>
<p><span style="font-size:18px;"></span></p><pre>public class Test {
    public void f() throws MyException{
         try {
            FileReader reader = new FileReader(&quot;G:\\myfile\\struts.txt&quot;);  
             Scanner in = new Scanner(reader);  
             System.out.println(in.next());
        } catch (FileNotFoundException e) {
            //e 保存异常信息
            throw new MyException(&quot;文件没有找到--01&quot;,e);
        }  
    }
    
    public void g() throws MyException{
        try {
            f();
        } catch (MyException e) {
            //e 保存异常信息
            throw new MyException(&quot;文件没有找到--02&quot;,e);
        }
    }
    
    public static void main(String[] args) {
        Test t = new Test();
        try {
            t.g();
        } catch (MyException e) {
            e.printStackTrace();
        }
    }
}</pre><br/>
<p></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>运行结果:</span></p>
<p><span style="font-size:18px;"></span></p><pre>com.test9.MyException: 文件没有找到--02
    at com.test9.Test.g(Test.java:31)
    at com.test9.Test.main(Test.java:38)
Caused by: com.test9.MyException: 文件没有找到--01
    at com.test9.Test.f(Test.java:22)
    at com.test9.Test.g(Test.java:28)
    ... 1 more
Caused by: java.io.FileNotFoundException: G:\myfile\struts.txt (系统找不到指定的路径。)
    at java.io.FileInputStream.open(Native Method)
    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106)
    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:66)
    at java.io.FileReader.&lt;init&gt;(FileReader.java:41)
    at com.test9.Test.f(Test.java:17)
    ... 2 more</pre><p></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>如果在程序中,去掉e，也就是：throw new MyException(&quot;文件没有找到--02&quot;);</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>那么异常信息就保存不了，运行结果如下：</span></p>
<p><span style="font-size:18px;"></span></p><pre>com.test9.MyException: 文件没有找到--02
    at com.test9.Test.g(Test.java:31)
    at com.test9.Test.main(Test.java:38)</pre><p></p>
<p><span style="font-size:18px;color:#0000ff;"><strong><em><span style="text-decoration:underline;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>PS:其实对于异常链鄙人使用的也不是很多，理解的不是很清楚，望各位指正！！！！</span></em></strong></span></p>
<h1><strong><span style="font-size:18px;"><span style="color:#0000ff;">       </span>
</span></strong>七、<strong>异常的使用误区</strong></h1>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>首先我们先看如下示例：该实例能够反映java异常的不正确使用（其实这也是我刚刚学Java时写的代码）！！</span></p>
<p><span style="font-size:18px;"></span></p><pre>OutputStreamWriter out = null;
        java.sql.Connection conn = null;
        try {            //   ---------1
            Statement stat = conn.createStatement();
            ResultSet rs = stat.executeQuery(&quot;select *from user&quot;);
            while (rs.next()){
                out.println(&quot;name:&quot; + rs.getString(&quot;name&quot;) + &quot;sex:&quot;
                        + rs.getString(&quot;sex&quot;));
            }
            conn.close();         //------2
            out.close();
        } 
        catch (Exception ex){    //------3
            ex.printStackTrace();    //------4
        }</pre><br/>
<p></p>
<p><font color="#0000ff" size="4"><strong><span style="color:#00ff00;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>1、-----------1</span></strong></font></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>对于这个try…catch块，我想他的真正目的是捕获SQL的异常，但是这个try块是不是包含了太多的信息了。这是我们为了偷懒而养成的代码坏习惯。有些人喜欢将一大块的代码全部包含在一个try块里面，因为这样省事，反正有异常它就会抛出，而不愿意花时间来分析这个大代码块有那几块会产生异常，产生什么类型的异常，反正就是一篓子全部搞定。这就想我们出去旅游将所有的东西全部装进一个箱子里面，而不是分类来装，虽不知装进去容易，找出来难啊！！！所有对于一个异常块，我们应该仔细分清楚每块的抛出异常，因为一个大代码块有太多的地方会出现异常了。</span></p>
<p><font size="4"><strong><span style="color:#0000ff;"><span style="text-decoration:underline;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>结论一：尽可能的减小try块！！！</span></span></strong></font></p>
<p><strong><span style="font-size:18px;color:#00ff00;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>2、--------2</span></strong></p>
<p><font color="#00ff00" size="4"><strong></strong><span style="color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>在这里你发现了什么？异常改变了运行流程！！不错就是异常改变了程序运行流程。如果该程序发生了异常那么<span style="color:#000000;">conn.close();
</span><span style="color:#000000;">out.close();是不可能执行得到的，这样势必会导致资源不能释放掉。所以如果程序用到了文件、Socket、JDBC连接之类的资源，即使遇到了异常，我们也要确保能够正确释放占用的资源。这里finally就有用武之地了：不管是否出现了异常，finally总是有机会运行的，所以finally用于释放资源是再适合不过了。</span></span></font></p>
<p><span style="color:#00ff00;font-size:18px;"><span style="color:#000000;"><font color="#000000"><strong><span style="text-decoration:underline;"><span style="color:#0000ff;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>结论二：保证所有资源都被正确释放。充分运用finally关键词。</span></span></strong> </font>
</span></span></p>
<p><span style="font-size:18px;color:#00ff00;"><strong><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>3、----------3</strong></span></p>
<p><font color="#00ff00" size="4"><strong></strong><span style="color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>对于这个代码我想大部分人都是这样处理的，（LZ也是<img alt="尴尬" height="0" src="" style="border-bottom-style:none;border-left-style:none;border-top-style:none;border-right-style:none;" width="0"></img>）。使用这样代码的人都有这样一个心理，一个catch解决所有异常，这样是可以，但是不推荐！为什么！首先我们需要明白catch块所表示是它预期会出现何种异常，并且需要做何种处理，而使用Exception就表示他要处理所有的异常信息，但是这样做有什么意义呢？</span></font></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>这里我们再来看看上面的程序实例，很显然它可能需要抛出两个异常信息，SQLException和IOException。所以一个catch处理两个截然不同的Exception明显的不合适。如果用两个catch，一个处理SQLException、一个处理IOException就好多了。所以：</span></p>
<p><font color="#000000" size="4"><strong><span style="color:#0000ff;"><span style="text-decoration:underline;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>结论三：catch语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的Exception类。 不要一个Exception试图处理所有可能出现的异常。</span></span></strong>
</font></p>
<p><font color="#000000" size="4"><strong><span style="color:#00ff00;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>4、----------4</span></strong></font></p>
<p><font color="#00ff00" size="4"><strong></strong><span style="color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>这个就问题多多了，我敢保证几乎所有的人都这么使用过。这里涉及到了两个问题，一是，捕获了异常不做处理，二是异常信息不够明确。</span></font></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>4.1、捕获异常不做处理，就是我们所谓的丢弃异常。我们都知道异常意味着程序出现了不可预期的问题，程序它希望我们能够做出处理来拯救它，但是你呢？一句ex.printStackTrace()搞定，这是多么的不负责任对程序的异常情况不理不顾。虽然这样在调试可能会有一定的帮助，但是调试阶段结束后呢？不是一句ex.printStackTrace()就可以搞定所有的事情的！</span></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>那么怎么改进呢？有四种选择：</span></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>1、处理异常。对所发生的的异常进行一番处理，如修正错误、提醒。再次申明ex.printStackTrace()算不上已经“处理好了异常”.</span></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>2、重新抛出异常。既然你认为你没有能力处理该异常，那么你就尽情向上抛吧！！！</span></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>3、封装异常。这是LZ认为最好的处理方法，对异常信息进行分类，然后进行封装处理。</span></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>4、不要捕获异常。</span></p>
<p><span style="font-size:18px;color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>4.2、异常信息不明确。我想对于这样的：<span style="color:#000000;">java.io.FileNotFoundException: ………信息除了我们IT人没有几个人看得懂和想看吧！所以在出现异常后，我们最好能够提供一些文字信息，例如当前正在执行的类、方法和其他状态信息，包括以一种更适合阅读的方式整理和组织printStackTrace提供的信息。起码我公司是需要将异常信息所在的类、方法、何种异常都需要记录在日志文件中的。</span></span></p>
<p><span style="font-size:18px;color:#000000;"><span style="color:#000000;">所以：</span></span></p>
<p><span style="color:#0000ff;font-size:18px;"><font color="#000000"><strong><span style="text-decoration:underline;"><span style="color:#0000ff;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>结论四：既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。 不要做一个不负责的人。</span></span></strong></font></span></p>
<p><span style="color:#000000;font-size:18px;"><font color="#000000"><span style="color:#0000ff;"><strong><span style="text-decoration:underline;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>结论五：在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。</span></strong></span></font></span></p>
<p><font color="#0000ff" size="4"><span style="color:#000000;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>对于异常还有以下几个注意地方：</span></font></p>
<p><span style="color:#0000ff;font-size:18px;"><font color="#000000"><strong><span style="text-decoration:underline;"><span style="color:#0000ff;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>六、不要在finally块中处理返回值。</span></span></strong></font></span></p>
<p><span style="color:#0000ff;font-size:18px;"><font color="#000000"><strong><span style="text-decoration:underline;"><span style="color:#0000ff;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>七、不要在构造函数中抛出异常。</span></span></strong></font></span></p>
<p></p>
<p></p>
<h1><strong><span style="font-size:18px;"><span style="color:#0000ff;">       </span>
</span></strong>八、<strong>try…catch、throw、throws</strong></h1>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>在这里主要是区分throw和throws。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>throws是方法抛出异常。在方法声明中，如果添加了throws子句，表示该方法即将抛出异常，异常的处理交由它的调用者，至于调用者任何处理则不是它的责任范围内的了。所以如果一个方法会有异常发生时，但是又不想处理或者没有能力处理，就使用throws吧！</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>而throw是语句抛出异常。它不可以单独使用，要么与try…catch配套使用，要么与throws配套使用。</span></p>
<p><span style="font-size:18px;"></span></p><pre>//使用throws抛出异常
    public void f() throws MyException{
         try {
            FileReader reader = new FileReader(&quot;G:\\myfile\\struts.txt&quot;);  
             Scanner in = new Scanner(reader);  
             System.out.println(in.next());
        } catch (FileNotFoundException e) {
            throw new MyException(&quot;文件没有找到&quot;, e);    //throw
        }  
        
    }</pre><p></p>
<p></p>
<p></p>
<p></p>
<h1><strong><span style="font-size:18px;"><span style="color:#0000ff;">       </span>
</span></strong>九、总结</h1>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>其实对于异常使用的优缺点现在确实存在很多的讨论。例如：</span><a href="http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank" title="http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html"><span style="font-size:18px;">http://www.cnblogs.com/mailingfeng/archive/2012/11/14/2769974.html</span></a><span style="font-size:18px;">。这篇博文对于是否需要使用异常进行了比较深刻的讨论。LZ实乃菜鸟一枚，不能理解异常深奥之处。但是有一点LZ可以肯定，那就是异常必定会影响系统的性能。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>异常使用指南（摘自：Think in java）</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>应该在下列情况下使用异常。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>1、在恰当的级别处理问题（在知道该如何处理异常的情况下才捕获异常）。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>2、解决问题并且重新调用产生异常的方法。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>3、进行少许修补，然后绕过异常发生的地方继续执行。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>4、用别的数据进行计算，以代替方法预计会返回的值。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>5、把当前运行环境下能做的事情尽量做完。然后把相同（不同）的异常重新抛到更高层。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>6、终止程序。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>7、进行简化。</span></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>8、让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮做长期投资）</span></p>
<p></p>
<p><span style="font-size:18px;"><strong><span style="font-size:18px;"><span style="color:#0000ff;">      
</span></span></strong>更多阅读：</span><span><a href="http://blog.csdn.net/chenssy/article/details/17651909" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">java提高篇(十六)-----异常（一）
</a></span></p>

<div>
    作者：chenssy 发表于2013/12/29 10:32:40 <a href="http://blog.csdn.net/chenssy/article/details/17651971" style="color:rgb(0, 153, 238);text-decoration:none;">原文链接</a>
</div>
<div>
    阅读：2614 评论：1 <a href="http://blog.csdn.net/chenssy/article/details/17651971#comments" style="color:rgb(0, 153, 238);text-decoration:none;" target="_blank">查看评论</a>
</div>

</td></tr>
<tr><td style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
<tr><td height="40" style="font-size:13px;font-family:Verdana, 宋体;"></td></tr>
</tbody></table>
</center>
<div style="border-top-color:rgb(204, 204, 204);border-top-width:1px;border-top-style:solid;text-align:center;line-height:200%;margin-top:20px;padding-top:6px;"><dl style="padding:3px 0px;margin:0px;"><dt></dt> <dd><a href="http://www.csdn.net/company/about.html" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank">公司简介</a>|<a href="http://www.csdn.net/company/marketing.html" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank">广告服务</a>|<a href="http://www.csdn.net/company/account.html" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank">银行汇款帐号</a>|<a href="http://www.csdn.net/company/contact.html" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank">联系方式</a>|<a href="http://www.csdn.net/company/statement.html" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank">版权声明</a>|<a href="http://www.csdn.net/company/layer.html" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank">法律顾问</a>|<a href="http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprmailto:webmaster@csdn.net" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;">问题报告</a></dd><dd>北京创新乐知信息技术有限公司 版权所有, 京 ICP 证 070598 号</dd><dd>世纪乐知(北京)网络技术有限公司 提供技术支持</dd><dd><img src="RSS-CSDN博客推荐文章_files/webmastermail.png" type="image/png" data-filename="webmastermail.png" alt="" height="12" title="" width="163"/></dd><dd>Copyright © 1999-2011, CSDN.NET, All Rights Reserved</dd><dd><a href="http://www.hd315.gov.cn/beian/view.asp?bianhao=010202001032100010" style="text-decoration:none;color:rgb(0, 0, 0);padding:0px 5px;" target="_blank"><img src="RSS-CSDN博客推荐文章_files/gongshang_logos.gif" type="image/gif" data-filename="gongshang_logos.gif" alt="GongshangLogo" height="31" title="" width="25"/></a></dd></dl></div>

<div style="position:static;width:0px;height:0px;border:none;padding:0px;margin:0px;"><div style="font-style:normal;padding:0px 2px 2px 0px;float:none;border:0px;position:absolute;text-align:left;z-index:10000;visibility:hidden;margin:0px;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:12px;line-height:normal;font-family:arial, u5b8bu4f53;zoom:1;border-radius:3px;"><div style="text-align:left;padding:0px;float:none;border:0px;position:absolute;margin:0px;left:0px;top:0px;width:3px;height:3px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-left-top.png');"></div><div style="padding:0px;margin:0px;float:none;border:0px;position:absolute;text-align:left;left:0px;top:0px;height:2px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-top.png') repeat-x;"></div><div style="z-index:10001;padding:0px;float:none;border:0px;position:absolute;text-align:left;margin:0px;right:0px;top:0px;width:6px;height:3px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-right-top.png');"></div><div style="padding:0px;margin:0px;float:none;border:0px;position:absolute;text-align:left;right:0px;top:3px;width:4px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-right.png') repeat-y;"></div><div style="z-index:10001;padding:0px;float:none;border:0px;position:absolute;text-align:left;margin:0px;right:0px;bottom:1px;width:6px;height:5px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-right-bottom.png');"></div><div style="padding:0px;margin:0px;float:none;border:0px;position:absolute;text-align:left;left:5px;bottom:0px;height:4px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-bottom.png') repeat-x;"></div><div style="z-index:10001;padding:0px;float:none;border:0px;position:absolute;text-align:left;margin:0px;left:0px;bottom:0px;width:5px;height:6px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-left-bottom.png');"></div><div style="padding:0px;margin:0px;float:none;border:0px;position:absolute;text-align:left;left:0px;top:0px;width:2px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-left.png');"></div><div style="padding:5px 10px 8px 8px;margin:0px;float:none;border:0px;position:static;text-align:left;color:rgb(0, 0, 0);background:rgb(255, 255, 255);"></div></div><div style="visibility:hidden;padding:0px;float:none;border:0px;position:absolute;text-align:left;margin:0px;z-index:10003;width:15px;height:12px;font-size:0px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-arrow-bottom.png');"></div><div style="visibility:hidden;padding:0px;float:none;border:0px;position:absolute;text-align:left;margin:0px;z-index:10003;width:15px;height:12px;font-size:0px;background:url('http://blog.csdn.net/rss.html?type=column&amp;column=chenssy-javaimprchrome-extension://ikkepelhgbcgmhhmcmpfkjmchccjblkd/imgs/map/tip-arrow-top.png');"></div></div><div style="margin:0px;padding:0px;border:none;position:absolute;width:5px;height:5px;top:-10px;left:-10px;"></div></div></div></div><br/></div></span>
</div></body></html> 