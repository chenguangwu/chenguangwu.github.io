<html>
<head>
  <title>线程生命周期</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8719"/>
<h1>线程生命周期</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2015/8/22 7:34</i></td></tr>
</table>
</div>
<br/>

<div><span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>        与人有生老病死一样，线程也同样要经历开始（等待）、运行、挂起和停止四种不同的状态。这四种状态都可以通过Thread类中的方法进行控制。下面给出了Thread类中和这四种状态相关的方法。<br/>        <div><br/></div>        // 开始线程 <br/>        public void start( ); <br/>        public void run( ); <br/>        // 挂起和唤醒线程 <br/>        public void resume( ); // 不建议使用 <br/>        public void suspend( ); // 不建议使用 <br/>        public static void sleep(long millis); <br/>        public static void sleep(long millis, int nanos); <br/>        // 终止线程 <br/>        public void stop( ); // 不建议使用 <br/>        public void interrupt( ); <br/>        // 得到线程状态 <br/>        public boolean isAlive( ); <br/>        public boolean isInterrupted( ); <br/>        public static boolean interrupted( ); <br/>        // join方法 <br/>        public void join( ) throws InterruptedException; <br/>        <div><br/></div><div><br/></div>        <br/>        一、创建并运行线程<br/>        线程在建立后并不马上执行run方法中的代码，而是处于等待状态。线程处于等待状态时，可以通过Thread类的方法来设置线程不各种属性，如线程的优先级（setPriority）、线程名(setName)和线程的类型（setDaemon）等。<br/>        当调用start方法后，线程开始执行run方法中的代码。线程进入运行状态。可以通过Thread类的isAlive方法来判断线程是否处于运行状态。当线程处于运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于等待状态，也可能处于停止状态。下面的代码演示了线程的创建、运行和停止三个状态之间的切换，并输出了相应的isAlive返回值。<br/>        <div><br/></div>        package chapter2; <br/>         <br/>        public class LifeCycle extends Thread <br/>        { <br/>         public void run() <br/>         { <br/>         int n = 0; <br/>         while ((++n) &lt; 1000); <br/>         } <br/>         <br/>         public static void main(String[] args) throws Exception <br/>         { <br/>         LifeCycle thread1 = new LifeCycle(); <br/>         System.out.println(“isAlive: ” + thread1.isAlive()); <br/>         thread1.start(); <br/>         System.out.println(“isAlive: ” + thread1.isAlive()); <br/>         thread1.join(); // 等线程thread1结束后再继续执行 <br/>         System.out.println(“thread1已经结束!”); <br/>         System.out.println(“isAlive: ” + thread1.isAlive()); <br/>         } <br/>        } <br/>        <div><br/></div><div><br/></div>        要注意一下，在上面的代码中使用了join方法，这个方法的主要功能是保证线程的run方法完成后程序才继续运行，这个方法将在后面的文章中介绍<br/>        上面代码的运行结果：<br/>        <div><br/></div>        isAlive: false<br/>        isAlive: true<br/>        thread1已经结束!<br/>        isAlive: false<br/>        <div><br/></div><div><br/></div>        <br/>        二、挂起和唤醒线程<br/>        一但线程开始执行run方法，就会一直到这个run方法执行完成这个线程才退出。但在线程执行的过程中，可以通过两个方法使线程暂时停止执行。这两个方法是suspend和sleep。在使用suspend挂起线程后，可以通过resume方法唤醒线程。而使用sleep使线程休眠后，只能在设定的时间后使线程处于就绪状态（在线程休眠结束后，线程不一定会马上执行，只是进入了就绪状态，等待着系统进行调度）。<br/>        虽然suspend和resume可以很方便地使线程挂起和唤醒，但由于使用这两个方法可能会造成一些不可预料的事情发生，因此，这两个方法被标识为deprecated(抗议)标记，这表明在以后的jdk版本中这两个方法可能被删除，所以尽量不要使用这两个方法来操作线程。下面的代码演示了sleep、suspend和resume三个方法的使用。<br/>        <div><br/></div>        package chapter2; <br/>         <br/>        public class MyThread extends Thread <br/>        { <br/>         class SleepThread extends Thread <br/>         { <br/>         public void run() <br/>         { <br/>         try <br/>         { <br/>         sleep(2000); <br/>         } <br/>         catch (Exception e) <br/>         { <br/>         } <br/>         } <br/>         } <br/>        	public void run() <br/>         { <br/>         while (true) <br/>         System.out.println(new java.util.Date().getTime()); <br/>         } <br/>         public static void main(String[] args) throws Exception <br/>         { <br/>         MyThread thread = new MyThread(); <br/>         SleepThread sleepThread = thread.new SleepThread(); <br/>         sleepThread.start(); // 开始运行线程sleepThread <br/>         sleepThread.join(); // 使线程sleepThread延迟2秒 <br/>         thread.start(); <br/>         boolean flag = false; <br/>         while (true) <br/>         { <br/>         sleep(5000); // 使主线程延迟5秒 <br/>         flag = !flag; <br/>         if (flag) <br/>         thread.suspend(); <br/>         else <br/>         thread.resume(); <br/>         } <br/>         } <br/>        } <br/>        <div><br/></div><div><br/></div>        从表面上看，使用sleep和suspend所产生的效果类似，但sleep方法并不等同于suspend。它们之间最大的一个区别是可以在一个线程中通过suspend方法来挂起另外一个线程，如上面代码中在主线程中挂起了thread线程。而sleep只对当前正在执行的线程起作用。在上面代码中分别使sleepThread和主线程休眠了2秒和5秒。在使用sleep时要注意，不能在一个线程中来休眠另一个线程。如main方法中使用thread.sleep(2000)方法是无法使thread线程休眠2秒的，而只能使主线程休眠2秒。<br/>        在使用sleep方法时有两点需要注意：<br/>        1.sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒(1,000,000纳秒等于1毫秒)。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。<br/>        2.在使用sleep方法时必须使用throws或try{...}catch{...}。因为run方法无法使用throws，所以只能使用try{...}catch{...}。当在线程休眠的过程中，使用interrupt方法（这个方法将在2.3.3中讨论）中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下：<br/>        <div><br/></div>        public static void sleep(long millis) throws InterruptedException <br/>        public static void sleep(long millis, int nanos) throws InterruptedException <br/>        <div><br/></div><div><br/></div>        <br/>        三、终止线程的三种方法<br/>        有三种方法可以使终止线程。<br/>        1.使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。<br/>        2.使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。<br/>        3.使用interrupt方法中断线程。 <br/>        1.使用退出标志终止线程<br/>        当run方法执行完后，线程就会退出。但有时run方法是永远不会结束的。如在服务端程序中使用线程进行监听客户端请求，或是其他的需要循环处理的任务。在这种情况下，一般是将这些任务放在一个循环中，如while循环。如果想让循环永远运行下去，可以使用while(true){...}来处理。但要想使while循环在某一特定条件下退出，最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。下面给出了一个利用退出标志终止线程的例子。<br/>        <div><br/></div>        package chapter2; <br/>         <br/>        public class ThreadFlag extends Thread <br/>        { <br/>         public volatile boolean exit = false; <br/>         <br/>         public void run() <br/>         { <br/>         while (!exit); <br/>         } <br/>         public static void main(String[] args) throws Exception <br/>         { <br/>         ThreadFlag thread = new ThreadFlag(); <br/>         thread.start(); <br/>        	 sleep(5000); // 主线程延迟5秒 <br/>        	 thread.exit = true; // 终止线程thread <br/>        	 thread.join(); <br/>        	 System.out.println(“线程退出!”); <br/>        	} <br/>        } <br/>        <div><br/></div><div><br/></div>        在上面代码中定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false。在定义exit时，使用了一个Java关键字volatile，这个关键字的目的是使exit同步，也就是说在同一时刻只能由一个线程来修改exit的值。<br/>        2.使用stop方法终止线程<br/>        使用stop方法可以强行终止正在运行或挂起的线程。我们可以使用如下的代码来终止线程：<br/>        <div><br/></div>        thread.stop();<br/>        <div><br/></div><div><br/></div>        虽然使用上面的代码可以终止线程，但使用stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，因此，并不推荐使用stop方法来终止线程。<br/>        3.使用interrupt方法终止线程<br/>        使用interrupt方法来终端线程可分为两种情况：<br/>        （1）线程处于阻塞状态，如使用了sleep方法。<br/>        （2）使用while(!isInterrupted()){...}来判断线程是否被中断。<br/>        在第一种情况下使用interrupt方法，sleep方法将抛出一个InterruptedException例外，而在第二种情况下线程将直接退出。下面的代码演示了在第一种情况下使用interrupt方法。<br/>        <div><br/></div>        package chapter2; <br/>         <br/>        public class ThreadInterrupt extends Thread <br/>        { <br/>        	public void run() <br/>        	{ <br/>         try <br/>        	 { <br/>        	 sleep(50000); // 延迟50秒 <br/>        	 } <br/>         catch (InterruptedException e) <br/>         { <br/>         System.out.println(e.getMessage()); <br/>         } <br/>         } <br/>         public static void main(String[] args) throws Exception <br/>         { <br/>        	 Thread thread = new ThreadInterrupt(); <br/>         thread.start(); <br/>         System.out.println(“在50秒之内按任意键中断线程!”); <br/>         System.in.read(); <br/>         thread.interrupt(); <br/>         thread.join(); <br/>         System.out.println(“线程已经退出!”); <br/>         } <br/>        } <br/>        <div><br/></div><div><br/></div>        上面代码的运行结果如下：<br/>        <div><br/></div>        在50秒之内按任意键中断线程!<br/>        sleep interrupted<br/>        线程已经退出!<br/>        <div><br/></div><div><br/></div>        在调用interrupt方法后， sleep方法抛出异常，然后输出错误信息：sleep interrupted。<br/>        注意：在Thread类中有两个方法可以判断线程是否通过interrupt方法被终止。一个是静态的方法interrupted()，一个是非静态的方法isInterrupted()，这两个方法的区别是interrupted用来判断当前线是否被中断，而isInterrupted可以用来判断其他线程是否被中断。因此，while (!isInterrupted())也可以换成while (!Thread.interrupted())。<br/>        以上就是线程的生命周期。要进一步学习Java多线程，务必要对Java线程生命周期有着足够的认识。</div></span>
</div></body></html> 