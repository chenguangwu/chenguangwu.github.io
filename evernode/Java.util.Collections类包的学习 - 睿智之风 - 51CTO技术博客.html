<html>
<head>
  <title>Java.util.Collections类包的学习 - 睿智之风 - 51CTO技术博客</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="6994"/>
<h1>Java.util.Collections类包的学习 - 睿智之风 - 51CTO技术博客</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2015/9/18 22:58</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://daiyanfei.blog.51cto.com/698782/196335/"><i>http://daiyanfei.blog.51cto.com/698782/196335/</i></a></td></tr>
</table>
</div>
<br/>

<div><span><br/><div style="font-size: 16px"><div><div style="font-family:宋体, 'Arial Narrow', arial, serif;font-size:12px;color:rgb(85, 85, 85);background:url(http://daiyanfei.blog.51cto.com/image/skin/30/bg.jpg);"><div><div style="overflow:hidden;"><div style="background:rgb(255, 255, 255);margin-top:5px;"><div><div style="margin:0 0 10px;"><div style="line-height:2;font-size:14px;word-wrap:break-word;word-break:normal;">
    		  <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">Java</font></span>.util.Collections类包的学习 <br style="padding:0px;margin:0px;"/>1. 描述： <br style="padding:0px;margin:0px;"/>1.1 概述 <br style="padding:0px;margin:0px;"/><span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">java</font></span>.util.Collections类包含很多有用的方法，可以使程序员的工作变得更加容易，但是这些方法通常都没有被充分地利用。Javadoc给出Collections类最完整的描述<br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>列子： <br style="padding:0px;margin:0px;"/>import <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">java</font></span>.util.ArrayList; <br style="padding:0px;margin:0px;"/>import <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">java</font></span>.util.<span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#55ff55;">Collection</font></span>; <br style="padding:0px;margin:0px;"/>import <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">java</font></span>.util.Collections; <br style="padding:0px;margin:0px;"/>import <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">java</font></span>.util.Comparator; <br style="padding:0px;margin:0px;"/>import <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#ffff00;">java</font></span>.util.List; <br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>public class CollectionsSort { <br style="padding:0px;margin:0px;"/>public CollectionsSort() { <br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>public static void main(String[] args) { <br style="padding:0px;margin:0px;"/>double array[] = {111, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>List li = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>//list.add(&quot;&quot;+array[i]); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>double arr[] = {111}; <br style="padding:0px;margin:0px;"/>for(int j=0;j&lt;arr.length;j++){ <br style="padding:0px;margin:0px;"/>li.add(new Double(arr[j])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>2. 具体操作 <br style="padding:0px;margin:0px;"/>1) 排序(Sort) <br style="padding:0px;margin:0px;"/>使用sort方法可以根据元素的自然顺序 对指定列表按升序进行排序。列表中的所有元素都必须实现 Comparable 接口。此列表内的所有元素都必须是使用指定比较器可相互比较的 <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.sort(list); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>   System.out.println(li.get(i)); <br style="padding:0px;margin:0px;"/>}  <br style="padding:0px;margin:0px;"/>//结果：112,111,23,456,231 <br style="padding:0px;margin:0px;"/>2) 混排（Shuffling） <br style="padding:0px;margin:0px;"/>混排算法所做的正好与 sort 相反: 它打乱在一个 List 中可能有的任何排列的踪迹。也就是说，基于随机源的输入重排该 List, 这样的排列具有相同的可能性（假设随机源是公正的）。这个算法在实现一个碰运气的游戏中是非常有用的。例如，它可被用来混排代表一副牌的 Card 对象的一个 List 。另外，在生成测试案例时，它也是十分有用的。 <br style="padding:0px;margin:0px;"/>Collections.Shuffling(list) <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.shuffle(list); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>   System.out.println(li.get(i)); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：112,111,23,456,231 <br style="padding:0px;margin:0px;"/>3) 反转(Reverse) <br style="padding:0px;margin:0px;"/>       使用Reverse方法可以根据元素的自然顺序 对指定列表按降序进行排 <br style="padding:0px;margin:0px;"/>序。 <br style="padding:0px;margin:0px;"/>Collections.reverse(list) <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections. reverse (list); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>   System.out.println(li.get(i)); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：231,456,23,111,112 <br style="padding:0px;margin:0px;"/>4) 替换所以的元素(Fill) <br style="padding:0px;margin:0px;"/>使用指定元素替换指定列表中的所有元素。 <br style="padding:0px;margin:0px;"/>String str[] = {&quot;dd&quot;,&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;ee&quot;}; <br style="padding:0px;margin:0px;"/>for(int j=0;j&lt;str.length;j++){ <br style="padding:0px;margin:0px;"/>li.add(new String(str[j])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.fill(li,&quot;aaa&quot;); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; li.size(); i++) { <br style="padding:0px;margin:0px;"/>System.out.println(&quot;list[&quot; + i + &quot;]=&quot; + li.get(i)); <br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：aaa,aaa,aaa,aaa,aaa <br style="padding:0px;margin:0px;"/><br style="padding:0px;margin:0px;"/>5) 拷贝(Copy) <br style="padding:0px;margin:0px;"/>用两个参数，一个目标 List 和一个源 List, 将源的元素拷贝到目标，并覆盖它的内容。目标 List 至少与源一样长。如果它更长，则在目标 List 中的剩余元素不受影响。 <br style="padding:0px;margin:0px;"/>Collections.copy(list,li): 后面一个参数是目标列表 ,前一个是源列表 <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>List li = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>double arr[] = {1131,333}; <br style="padding:0px;margin:0px;"/>String str[] = {&quot;dd&quot;,&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;ee&quot;}; <br style="padding:0px;margin:0px;"/>for(int j=0;j&lt;arr.length;j++){ <br style="padding:0px;margin:0px;"/>li.add(new Double(arr[j])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.copy(list,li); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt;list.size(); i++) { <br style="padding:0px;margin:0px;"/>System.out.println(&quot;list[&quot; + i + &quot;]=&quot; + list.get(i)); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：1131,333,23,456,231 <br style="padding:0px;margin:0px;"/>6) 返回Collections中最小元素(min) <br style="padding:0px;margin:0px;"/>根据指定比较器产生的顺序，返回给定 <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#55ff55;">collection</font></span> 的最小元素。<span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#55ff55;">collection</font></span> 中的所有元素都必须是通过指定比较器可相互比较的 <br style="padding:0px;margin:0px;"/>Collections.min(list) <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.min(list); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt;list.size(); i++) { <br style="padding:0px;margin:0px;"/>System.out.println(&quot;list[&quot; + i + &quot;]=&quot; + list.get(i)); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：23 <br style="padding:0px;margin:0px;"/>7) 返回Collections中最小元素(max) <br style="padding:0px;margin:0px;"/>根据指定比较器产生的顺序，返回给定 <span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#55ff55;">collection</font></span> 的最大元素。<span style="padding:0px;margin:0px;"><font style="padding:0px;margin:0px;background-color:#55ff55;">collection</font></span> 中的所有元素都必须是通过指定比较器可相互比较的 <br style="padding:0px;margin:0px;"/>Collections.max(list) <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.max(list); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt;list.size(); i++) { <br style="padding:0px;margin:0px;"/>System.out.println(&quot;list[&quot; + i + &quot;]=&quot; + list.get(i)); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：456 <br style="padding:0px;margin:0px;"/>8) lastIndexOfSubList <br style="padding:0px;margin:0px;"/>返回指定源列表中最后一次出现指定目标列表的起始位置 <br style="padding:0px;margin:0px;"/>int count = Collections.lastIndexOfSubList(list,li); <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>List li = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>double arr[] = {111}; <br style="padding:0px;margin:0px;"/>String str[] = {&quot;dd&quot;,&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;ee&quot;}; <br style="padding:0px;margin:0px;"/>for(int j=0;j&lt;arr.length;j++){ <br style="padding:0px;margin:0px;"/>li.add(new Double(arr[j])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Int locations = Collections. lastIndexOfSubList (list,li); <br style="padding:0px;margin:0px;"/>System.out.println(“===”+ locations); <br style="padding:0px;margin:0px;"/>//结果 3 <br style="padding:0px;margin:0px;"/>9) IndexOfSubList <br style="padding:0px;margin:0px;"/>返回指定源列表中第一次出现指定目标列表的起始位置 <br style="padding:0px;margin:0px;"/>int count = Collections.indexOfSubList(list,li); <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>List li = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>double arr[] = {111}; <br style="padding:0px;margin:0px;"/>String str[] = {&quot;dd&quot;,&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;ee&quot;}; <br style="padding:0px;margin:0px;"/>for(int j=0;j&lt;arr.length;j++){ <br style="padding:0px;margin:0px;"/>li.add(new Double(arr[j])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Int locations = Collections.indexOfSubList(list,li); <br style="padding:0px;margin:0px;"/>System.out.println(“===”+ locations); <br style="padding:0px;margin:0px;"/>//结果 1 <br style="padding:0px;margin:0px;"/>10) Rotate <br style="padding:0px;margin:0px;"/>根据指定的距离循环移动指定列表中的元素 <br style="padding:0px;margin:0px;"/>Collections.rotate(list,-1); <br style="padding:0px;margin:0px;"/>如果是负数，则正向移动，正数则方向移动 <br style="padding:0px;margin:0px;"/>double array[] = {112, 111, 23, 456, 231 }; <br style="padding:0px;margin:0px;"/>List list = new ArrayList(); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt; array.length; i++) { <br style="padding:0px;margin:0px;"/>list.add(new Double(array[i])); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>Collections.rotate(list,-1); <br style="padding:0px;margin:0px;"/>for (int i = 0; i &lt;list.size(); i++) { <br style="padding:0px;margin:0px;"/>System.out.println(&quot;list[&quot; + i + &quot;]=&quot; + list.get(i)); <br style="padding:0px;margin:0px;"/>} <br style="padding:0px;margin:0px;"/>//结果：111,23,456,231,112
    		</div></div></div></div></div></div></div></div></div><br/></span>
</div></body></html> 