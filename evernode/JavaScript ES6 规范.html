<html>
<head>
  <title>JavaScript ES6 规范</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="12164"/>
<h1>JavaScript ES6 规范</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2016/6/29 15:19</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2016/6/29 15:20</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><a href="http://www.tuicool.com/articles/BRviymF" shape="rect">http://www.tuicool.com/articles/BRviymF</a><br clear="none"/></div><div><br clear="none"/></div><div><h1>JavaScript ES6 规范</h1><div><div><span>时间 2015-04-05 20:26:37 </span><span><span></span> <a href="http://www.tuicool.com/sites/aQvAr2U" shape="rect" target="_blank">bubkoo</a></span></div><div><span>原文</span>  <a href="http://bubkoo.com/2015/04/05/javascript-style-guide/?utm_source=tuicool&amp;utm_medium=referral" shape="rect">http://bubkoo.com/2015/04/05/javascript-style-guide/</a></div><div><span>主题</span> <a href="http://www.tuicool.com/topics/11060004" shape="rect" target="_blank"><span>JavaScript</span> </a><a href="http://www.tuicool.com/topics/11060047" shape="rect" target="_blank"><span>ECMAScript</span></a></div></div><div><div><ul><li><p>原始类型：值传递</p><ul><li><code>string</code></li><li><code>number</code></li><li><code>boolean</code></li><li><code>null</code></li><li><code>undefined</code></li></ul></li></ul><div><div><pre><span>const</span> foo = <span>1</span>;
<span>let</span> bar = foo;

bar = <span>9</span>;

console.log(foo, bar); <span>// =&gt; 1, 9</span>
</pre></div></div><ul><li><p>复杂类型：引用传递</p><ul><li><code>object</code></li><li><code>array</code></li><li><code>function</code></li></ul></li></ul><div><div><pre><span>const</span> foo = [<span>1</span>, <span>2</span>];
<span>const</span> bar = foo;

bar[<span>0</span>] = <span>9</span>;

console.log(foo[<span>0</span>], bar[<span>0</span>]); <span>// =&gt; 9, 9</span>
</pre></div></div><h2>引用</h2><ul><li><p>为引用使用 <code>const</code> 关键字，而不是 <code>var</code></p><div><p>这样确保你不能修改引用类型，否则可能会导致一些 bug 或难以理解的代码。</p></div></li></ul><div><div><pre><span>// bad</span>
<span>var</span> a = <span>1</span>;
<span>var</span> b = <span>2</span>;

<span>// good</span>
<span>const</span> a = <span>1</span>;
<span>const</span> b = <span>2</span>;
</pre></div></div><ul><li><p>如果你必须修改引用，使用 <code>let</code> 代替 <code>var</code></p><div><p>因为 <code>let</code> 是块作用域的，而 <code>var</code> 是函数作用域。</p></div></li></ul><div><div><pre><span>// bad</span>
<span>var</span> count = <span>1</span>;
<span>if</span> (<span>true</span>) {
  count += <span>1</span>;
}

<span>// good, use the let.</span>
<span>let</span> count = <span>1</span>;
<span>if</span> (<span>true</span>) {
  count += <span>1</span>;
}
</pre></div></div><ul><li><code>let</code> 和 <code>const</code> 都是块作用域的</li></ul><div><div><pre><span>// const and let only exist in the blocks they are defined in.</span>
{
  <span>let</span> a = <span>1</span>;
  <span>const</span> b = <span>1</span>;
}
console.log(a); <span>// ReferenceError</span>
console.log(b); <span>// ReferenceError</span>
</pre></div></div><h2>对象</h2><ul><li>使用对象字面量创建对象</li></ul><div><div><pre><span>// bad</span>
<span>var</span> item = <span>new</span> Object();

<span>// good</span>
<span>var</span> item = {};
</pre></div></div><ul><li>不要使用 <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Reserved_Words" rel="nofollow,noindex" shape="rect" target="_blank">保留字（reserved words）</a> 作为键，否则在 IE8 下将出错， <a href="https://github.com/airbnb/javascript/issues/61" rel="nofollow,noindex" shape="rect" target="_blank">issue</a></li></ul><div><div><pre><span>// bad</span>
<span>var</span> superman = {
  <span>class</span>: <span>'superhero'</span>,
  <span>default</span>: { clark: <span>'kent'</span> },
  <span>private</span>: <span>true</span>
};

<span>// good</span>
<span>var</span> superman = {
  klass: <span>'superhero'</span>,
  defaults: { clark: <span>'kent'</span> },
  hidden: <span>true</span>
};
</pre></div></div><ul><li>使用易读的同义词代替保留字</li></ul><div><div><pre><span>// bad</span>
<span>const</span> superman = {
  <span>class</span>: <span>'alien'</span>
};

<span>// bad</span>
<span>const</span> superman = {
  klass: <span>'alien'</span>
};

<span>// good</span>
<span>const</span> superman = {
  type: <span>'alien'</span>
};
</pre></div></div><ul><li><p>创建对象时使用计算的属性名，而不要在创建对象后使用对象的动态特性</p><div><p>这样可以在同一个位置定义对象的所有属性。</p></div></li></ul><div><div><pre><span><span>function</span></span><span> <span>getKey</span><span>(k)</span> </span><span>{</span>
    <span>return</span> `a key named ${k}`;
  }

  <span>// bad</span>
  <span>const</span> obj = {
    id: <span>5</span>,
    name: <span>'San Francisco'</span>
  };
  obj[getKey(<span>'enabled'</span>)] = <span>true</span>;

  <span>// good</span>
  <span>const</span> obj = {
    id: <span>5</span>,
    name: <span>'San Francisco'</span>,
    [getKey(<span>'enabled'</span>)]: <span>true</span>
  };
</pre></div></div><ul><li>使用定义对象方法的简短形式</li></ul><div><div><pre><span>// bad</span>
<span>const</span> atom = {
  <span>value</span>: <span>1</span>,

  addValue: function (<span>value</span>) {
    <span>return</span> atom.<span>value</span> + <span>value</span>;
  }
};

<span>// good</span>
<span>const</span> atom = {
  <span>value</span>: <span>1</span>,

  addValue(<span>value</span>) {
    <span>return</span> atom.<span>value</span> + <span>value</span>;
  }
};
</pre></div></div><ul><li><p>使用定义对象属性的简短形式</p><div><p>书写起来更加简单，并且可以自描述。</p></div></li></ul><div><div><pre><span>const</span> lukeSkywalker = <span>'Luke Skywalker'</span>;

  <span>// bad</span>
  <span>const</span> obj = {
    lukeSkywalker: lukeSkywalker
  };

  <span>// good</span>
  <span>const</span> obj = {
    lukeSkywalker
  };
</pre></div></div><ul><li><p>将所有简写的属性写在对象定义的最顶部</p><div><p>这样可以更加方便地知道哪些属性使用了简短形式。</p></div></li></ul><div><div><pre><span>const</span> anakinSkywalker = <span>'Anakin Skywalker'</span>;
  <span>const</span> lukeSkywalker = <span>'Luke Skywalker'</span>;

  <span>// bad</span>
  <span>const</span> obj = {
    episodeOne: <span>1</span>,
    twoJedisWalkIntoACantina: <span>2</span>,
    lukeSkywalker,
    episodeThree: <span>3</span>,
    mayTheFourth: <span>4</span>,
    anakinSkywalker
  };

  <span>// good</span>
  <span>const</span> obj = {
    lukeSkywalker,
    anakinSkywalker,
    episodeOne: <span>1</span>,
    twoJedisWalkIntoACantina: <span>2</span>,
    episodeThree: <span>3</span>,
    mayTheFourth: <span>4</span>
  };
</pre></div></div><h2>数组</h2><ul><li>使用字面量语法创建数组</li></ul><div><div><pre><span>// bad</span>
<span>const</span> items = <span>new</span> <span>Array</span>();

<span>// good</span>
<span>const</span> items = [];
</pre></div></div><ul><li>如果你不知道数组的长度，使用 <code>push</code></li></ul><div><div><pre><span>const</span> someStack = [];


<span>// bad</span>
someStack[someStack.length] = <span>'abracadabra'</span>;

<span>// good</span>
someStack.push(<span>'abracadabra'</span>);
</pre></div></div><ul><li>使用 <code>...</code> 来拷贝数组</li></ul><div><div><pre><span>// bad</span>
<span>const</span> len = items.length;
<span>const</span> itemsCopy = [];
<span>let</span> i;

<span>for</span> (i = <span>0</span>; i &lt; len; i++) {
  itemsCopy[i] = items[i];
}

<span>// good</span>
<span>const</span> itemsCopy = [...items];
</pre></div></div><ul><li>使用 <code>Array.from</code> 将类数组对象转换为数组</li></ul><div><div><pre><span>const</span> foo = document.querySelectorAll(<span>'.foo'</span>);
<span>const</span> nodes = Array.<span>from</span>(foo);
</pre></div></div><h2>解构 Destructuring</h2><ul><li><p>访问或使用对象的多个属性时请使用对象的解构赋值</p><div><p>解构赋值避免了为这些属性创建临时变量或对象。</p></div></li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>getFullName</span><span>(user)</span> </span><span>{</span>
  <span>const</span> firstName = user.firstName;
  <span>const</span> lastName = user.lastName;

  <span>return</span> `${firstName} ${lastName}`;
}

<span>// good</span>
<span><span>function</span></span><span> <span>getFullName</span><span>(obj)</span> </span><span>{</span>
  <span>const</span> { firstName, lastName } = obj;
  <span>return</span> `${firstName} ${lastName}`;
}

<span>// best</span>
<span><span>function</span></span><span> <span>getFullName</span><span>({ firstName, lastName })</span> </span><span>{</span>
  <span>return</span> `${firstName} ${lastName}`;
}
</pre></div></div><ul><li>使用数组解构赋值</li></ul><div><div><pre><span>const</span> arr = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>];

<span>// bad</span>
<span>const</span> first = arr[<span>0</span>];
<span>const</span> second = arr[<span>1</span>];

<span>// good</span>
<span>const</span> [first, second] = arr;
</pre></div></div><ul><li><p>函数有多个返回值时使用对象解构，而不是数组解构</p><div><p>这样你就可以随时添加新的返回值或任意改变返回值的顺序，而不会导致调用失败。</p></div></li></ul><div><div><pre><span><span>function</span></span><span> <span>processInput</span><span>(input)</span> </span><span>{</span>
    <span>// then a miracle occurs</span>
    <span>return</span> [left, right, top, bottom];
  }

  <span>// the caller needs to think about the order of return data</span>
  <span>const</span> [left, __, top] = processInput(input);

  <span>// good</span>
  <span><span>function</span></span><span> <span>processInput</span><span>(input)</span> </span><span>{</span>
    <span>// then a miracle occurs</span>
    <span>return</span> { left, right, top, bottom };
  }

  <span>// the caller selects only the data they need</span>
  <span>const</span> { left, right } = processInput(input);
</pre></div></div><h2>字符串</h2><ul><li>使用单引号 <code>''</code></li></ul><div><div><pre><span>// bad</span>
<span>var</span> name = <span>&quot;Bob Parr&quot;</span>;

<span>// good</span>
<span>var</span> name = <span>'Bob Parr'</span>;

<span>// bad</span>
<span>var</span> fullName = <span>&quot;Bob &quot;</span> + <span>this</span>.lastName;

<span>// good</span>
<span>var</span> fullName = <span>'Bob '</span> + <span>this</span>.lastName;
</pre></div></div><ul><li>超过80个字符的字符串应该使用字符串连接换行</li><li>注：如果过度使用长字符串连接可能会对性能有影响。 <a href="http://jsperf.com/ya-string-concat" rel="nofollow,noindex" shape="rect" target="_blank">jsPerf</a> &amp; <a href="https://github.com/airbnb/javascript/issues/40" rel="nofollow,noindex" shape="rect" target="_blank">Discussion</a></li></ul><div><div><pre>// bad
var errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to <span><span>do</span> <span>with</span> this, you would <span>get</span> nowhere fast.<span>'</span></span><span><span>;</span></span><span><span>

// bad
var errorMessage = '</span>This <span>is</span> a super long error that \
was thrown because <span>of</span> Batman. \
<span>When</span> you stop <span>to</span> think about \
how Batman had anything <span>to</span> <span>do</span> \
<span>with</span> this, you would <span>get</span> nowhere \
fast.<span>'</span><span>;</span><span>


// good
var errorMessage = '</span>This <span>is</span> a super long error that <span>'</span><span> +</span><span>
  '</span>was thrown because <span>of</span> Batman.<span>'</span><span> +</span><span>
  '</span><span>When</span> you stop <span>to</span> think about <span>'</span><span> +</span><span>
  '</span>how Batman had anything <span>to</span> <span>do</span> <span>'</span><span> +</span><span>
  '</span><span>with</span> this, you would <span>get</span> nowhere <span>'</span><span> +</span><span>
  '</span>fast.<span>'</span><span>;</span><span>
</span></span></pre></div></div><ul><li><p>编程构建字符串时，使用字符串模板而不是字符串连接</p><div><p>模板给你一个可读的字符串，简洁的语法与适当的换行和字符串插值特性。</p></div></li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>sayHi</span><span>(name)</span> </span><span>{</span>
  <span>return</span> <span>'How are you, '</span> + name + <span>'?'</span>;
}

<span>// bad</span>
<span><span>function</span></span><span> <span>sayHi</span><span>(name)</span> </span><span>{</span>
  <span>return</span> [<span>'How are you, '</span>, name, <span>'?'</span>].join();
}

<span>// good</span>
<span><span>function</span></span><span> <span>sayHi</span><span>(name)</span> </span><span>{</span>
  <span>return</span> `How are you, ${name}?`;
}
</pre></div></div><h2>函数</h2><ul><li><p>使用函数声明而不是函数表达式</p><div><p>函数声明拥有函数名，在调用栈中更加容易识别。并且，函数声明会整体提升，而函数表达式只会提升变量本身。这条规则也可以这样描述，始终使用 <a href="https://github.com/airbnb/javascript/tree/es6?utm_source=javascriptweekly&amp;utm_medium=email#arrow-functions" rel="nofollow,noindex" shape="rect" target="_blank">箭头函数</a> 来代替函数表达式。</p></div></li></ul><div><div><pre><span>// bad</span>
<span>const</span> foo = <span><span>function</span></span><span> <span>()</span> </span><span>{</span>
};

<span>// good</span>
<span><span>function</span></span><span> <span>foo</span><span>()</span> </span><span>{</span>
}
</pre></div></div><ul><li>函数表达式</li></ul><div><div><pre><span>// immediately-invoked function expression (IIFE)</span>
(() =&gt; {
  console.log(<span>'Welcome to the Internet. Please follow me.'</span>);
})();
</pre></div></div><ul><li>绝对不要在一个非函数块（if，while，等等）里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同</li><li>注：ECMA-262 把 <code>块</code> 定义为一组语句，函数声明不是一个语句。阅读 <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf#page=97" rel="nofollow,noindex" shape="rect" target="_blank">ECMA-262</a> 对这个问题的说明</li></ul><div><div><pre><span>// bad</span>
<span>if</span> (currentUser) {
  <span><span>function</span></span><span> <span>test</span><span>()</span> </span><span>{</span>
    console.log(<span>'Nope.'</span>);
  }
}

<span>// good</span>
<span>if</span> (currentUser) {
  <span>var</span> test = <span><span>function</span></span><span> <span>test</span><span>()</span> </span><span>{</span>
    console.log(<span>'Yup.'</span>);
  };
}
</pre></div></div><ul><li>绝对不要把参数命名为 <code>arguments</code> , 这将会覆盖函数作用域内传过来的<code>arguments</code> 对象</li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>nope</span><span>(name, options, arguments)</span> </span><span>{</span>
  <span>// ...stuff...</span>
}

<span>// good</span>
<span><span>function</span></span><span> <span>yup</span><span>(name, options, args)</span> </span><span>{</span>
  <span>// ...stuff...</span>
}
</pre></div></div><ul><li><p>永远不要使用 <code>arguments</code> ，使用 <code>...</code> 操作符来代替</p><div><p><code>...</code> 操作符可以明确指定你需要哪些参数，并且得到的是一个真实的数组，而不是 <code>arguments</code> 这样的类数组对象。</p></div></li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>concatenateAll</span><span>()</span> </span><span>{</span>
  <span>const</span> args = <span>Array</span>.prototype.slice.call(arguments);
  <span>return</span> args.join(<span>''</span>);
}

<span>// good</span>
<span><span>function</span></span><span> <span>concatenateAll</span><span>(...args)</span> </span><span>{</span>
  <span>return</span> args.join(<span>''</span>);
}
</pre></div></div><ul><li>使用函数参数默认值语法，而不是修改函数的实参</li></ul><div><div><pre><span>// really bad</span>
<span><span>function</span></span><span> <span>handleThings</span><span>(opts)</span> </span><span>{</span>
  <span>// No! We shouldn't mutate function arguments.</span>
  <span>// Double bad: if opts is falsy it'll be set to an object which may</span>
  <span>// be what you want but it can introduce subtle bugs.</span>
  opts = opts || {};
  <span>// ...</span>
}

<span>// still bad</span>
<span><span>function</span></span><span> <span>handleThings</span><span>(opts)</span> </span><span>{</span>
  <span>if</span> (opts === <span>void</span> <span>0</span>) {
    opts = {};
  }
  <span>// ...</span>
}

<span>// good</span>
<span><span>function</span></span><span> <span>handleThings</span><span>(opts = {})</span> </span><span>{</span>
  <span>// ...</span>
}
</pre></div></div><h2>箭头函数 Arrow Functions</h2><ul><li><p>当必须使用函数表达式时（例如传递一个匿名函数时），请使用箭头函数</p><div><p>箭头函数提供了更简洁的语法，并且箭头函数中 <code>this</code> 对象的指向是不变的，<code>this</code> 对象绑定定义时所在的对象，这通常是我们想要的。如果该函数的逻辑非常复杂，请将该函数提取为一个函数声明。</p></div></li></ul><div><div><pre><span>// bad</span>
[<span>1</span>, <span>2</span>, <span>3</span>].map(<span><span>function</span></span><span> <span>(x)</span> </span><span>{</span>
  <span>return</span> x * x;
});

<span>// good</span>
[<span>1</span>, <span>2</span>, <span>3</span>].map((x) =&gt; {
  <span>return</span> x * x
});
</pre></div></div><ul><li>总是用括号包裹参数，省略括号只适用于单个参数，并且还降低了程序的可读性</li></ul><div><div><pre><span>// bad</span>
  [<span>1</span>, <span>2</span>, <span>3</span>].map(x =&gt; x * x);

  <span>// good</span>
  [<span>1</span>, <span>2</span>, <span>3</span>].map((x) =&gt; x * x);
</pre></div></div><h2>构造函数</h2><ul><li><p>总是使用 <code>class</code> 关键字，避免直接修改 <code>prototype</code></p><div><p><code>class</code> 语法更简洁，也更易理解。</p></div></li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>Queue</span><span>(contents = [])</span> </span><span>{</span>
  <span>this</span>._queue = [...contents];
}
Queue.prototype.pop = function() {
  <span>const</span> value = <span>this</span>._queue[<span>0</span>];
  <span>this</span>._queue.splice(<span>0</span>, <span>1</span>);
  <span>return</span> value;
}


<span>// good</span>
<span><span>class</span></span><span> <span>Queue</span> </span><span>{</span>
  constructor(contents = []) {
    <span>this</span>._queue = [...contents];
  }
  pop() {
    <span>const</span> value = <span>this</span>._queue[<span>0</span>];
    <span>this</span>._queue.splice(<span>0</span>, <span>1</span>);
    <span>return</span> value;
  }
}
</pre></div></div><ul><li><p>使用 <code>extends</code> 关键字来继承</p><div><p>这是一个内置的继承方式，并且不会破坏 <code>instanceof</code> 原型检查。</p></div></li></ul><div><div><pre><span>// bad</span>
  <span>const</span> inherits = require(<span>'inherits'</span>);
  function PeekableQueue(contents) {
    Queue.apply(<span>this</span>, contents);
  }
  inherits(PeekableQueue, Queue);
  PeekableQueue.prototype.peek = function() {
    <span>return</span> <span>this</span>._queue[<span>0</span>];
  }

  <span>// good</span>
  <span><span>class</span></span><span> <span>PeekableQueue</span> <span>extends</span> <span>Queue</span> </span><span>{</span>
    peek() {
      <span>return</span> <span>this</span>._queue[<span>0</span>];
    }
  }
</pre></div></div><ul><li>在方法中返回 <code>this</code> 以方便链式调用</li></ul><div><div><pre><span>// bad</span>
Jedi.prototype.jump = function() {
  <span>this</span>.jumping = <span>true</span>;
  <span>return</span> <span>true</span>;
};

Jedi.prototype.setHeight = function(height) {
  <span>this</span>.height = height;
};

<span>const</span> luke = <span>new</span> Jedi();
luke.jump(); <span>// =&gt; true</span>
luke.setHeight(<span>20</span>); <span>// =&gt; undefined</span>

<span>// good</span>
<span><span>class</span></span><span> <span>Jedi</span> </span><span>{</span>
  jump() {
    <span>this</span>.jumping = <span>true</span>;
    <span>return</span> <span>this</span>;
  }

  setHeight(height) {
    <span>this</span>.height = height;
    <span>return</span> <span>this</span>;
  }
}

<span>const</span> luke = <span>new</span> Jedi();

luke.jump()
  .setHeight(<span>20</span>);
</pre></div></div><ul><li>可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用</li></ul><div><div><pre><span><span>class</span></span><span> <span>Jedi</span> </span><span>{</span>
  contructor(options = {}) {
    <span>this</span>.name = options.name || <span>'no name'</span>;
  }

  getName() {
    <span>return</span> <span>this</span>.name;
  }

  toString() {
    <span>return</span> `Jedi - ${<span>this</span>.getName()}`;
  }
}
</pre></div></div><h2>模块</h2><ul><li><p>总是在非标准的模块系统中使用标准的 <code>import</code> 和 <code>export</code> 语法，我们总是可以将标准的模块语法转换成支持特定模块加载器的语法。</p><div><p>模块是未来的趋势，那么我们为何不现在就开始使用。</p></div></li></ul><div><div><pre><span>// bad</span>
<span>const</span> AirbnbStyleGuide = require(<span>'./AirbnbStyleGuide'</span>);
module.exports = AirbnbStyleGuide.es6;

<span>// ok</span>
import AirbnbStyleGuide <span>from</span> <span>'./AirbnbStyleGuide'</span>;
export <span>default</span> AirbnbStyleGuide.es6;

<span>// best</span>
import { es6 } <span>from</span> <span>'./AirbnbStyleGuide'</span>;
export <span>default</span> es6;
</pre></div></div><ul><li><p>不要使用通配符 <code>*</code> 的 <code>import</code></p><div><p>这样确保了只有一个默认的 <code>export</code> 项</p></div></li></ul><div><div><pre><span>// bad</span>
import * <span>as</span> AirbnbStyleGuide <span>from</span> <span>'./AirbnbStyleGuide'</span>;

<span>// good</span>
import AirbnbStyleGuide <span>from</span> <span>'./AirbnbStyleGuide'</span>;
</pre></div></div><ul><li><p>不要直接从一个 <code>import</code> 上 <code>export</code></p><div><p>虽然一行代码看起来更简洁，但是有一个明确的 <code>import</code> 和一个明确的 <code>export</code>使得代码行为更加明确。</p></div></li></ul><div><div><pre><span>// bad</span>
<span>// filename es6.js</span>
export <span>default</span> { es6 } <span>from</span> <span>'./airbnbStyleGuide'</span>;

<span>// good</span>
<span>// filename es6.js</span>
import { es6 } <span>from</span> <span>'./AirbnbStyleGuide'</span>;
export <span>default</span> es6;
</pre></div></div><h2>Iterators 和 Generators</h2><ul><li><p>不要使用迭代器（Iterators）。优先使用 JavaScript 中 <code>map</code> 和 <code>reduce</code> 这类高阶函数来代替 <code>for-of</code> 循环</p><div><p>处理纯函数的返回值更加容易并且没有副作用</p></div></li></ul><div><div><pre><span>const</span> numbers = [<span>1</span>, <span>2</span>, <span>3</span>, <span>4</span>, <span>5</span>];

  <span>// bad</span>
  <span>let</span> sum = <span>0</span>;
  <span>for</span> (<span>let</span> num of numbers) {
    sum += num;
  }

  sum === <span>15</span>;

  <span>// good</span>
  <span>let</span> sum = <span>0</span>;
  numbers.forEach((num) =&gt; sum += num);
  sum === <span>15</span>;

  <span>// best (use the functional force)</span>
  <span>const</span> sum = numbers.reduce((total, num) =&gt; total + num, <span>0</span>);
  sum === <span>15</span>;
</pre></div></div><ul><li><p>不要使用 generators</p><div><p>它们不太容易转换为 ES5 的语法。</p></div></li></ul><h2>属性</h2><ul><li>使用点 <code>.</code> 操作符来访问属性</li></ul><div><div><pre><span>const</span> luke = {
  jedi: <span>true</span>,
  age: <span>28</span>
};

<span>// bad</span>
<span>const</span> isJedi = luke[<span>'jedi'</span>];

<span>// good</span>
<span>const</span> isJedi = luke.jedi;
</pre></div></div><ul><li>当使用变量访问属性时使用中括号 <code>[]</code></li></ul><div><div><pre><span>var</span> luke = {
  jedi: <span>true</span>,
  age: <span>28</span>
};

<span><span>function</span></span><span> <span>getProp</span><span>(prop)</span> </span><span>{</span>
  <span>return</span> luke[prop];
}

<span>var</span> isJedi = getProp(<span>'jedi'</span>);
</pre></div></div><h2>变量</h2><ul><li>总是使用 <code>const</code> 来声明变量，否则将生成全局变量，我们应该避免污染全局命名空间</li></ul><div><div><pre><span>// bad</span>
superPower = <span>new</span> SuperPower();

<span>// good</span>
<span>const</span> superPower = <span>new</span> SuperPower();
</pre></div></div><ul><li><p>为每个变量都使用 <code>const</code> 关键字声明</p><div><p>这种方式更加容易添加新变量，并且不必担忧将 <code>,</code> 错误写成 <code>;</code> 而导致生成全局变量。</p></div></li></ul><div><div><pre><span>// bad</span>
<span>const</span> items = getItems(),
    goSportsTeam = <span>true</span>,
    dragonball = <span>'z'</span>;

<span>// bad</span>
<span>// (compare to above, and try to spot the mistake)</span>
<span>const</span> items = getItems(),
    goSportsTeam = <span>true</span>;
    dragonball = <span>'z'</span>;

<span>// good</span>
<span>const</span> items = getItems();
<span>const</span> goSportsTeam = <span>true</span>;
<span>const</span> dragonball = <span>'z'</span>;
</pre></div></div><ul><li>将所有 <code>const</code> 变量放在一起，然后将所有 <code>let</code> 变量放在一起</li></ul><div><div><pre><span>// bad</span>
<span>let</span> i, len, dragonball,
    items = getItems(),
    goSportsTeam = <span>true</span>;

<span>// bad</span>
<span>let</span> i;
<span>let</span> items = getItems();
<span>let</span> dragonball;
<span>let</span> goSportsTeam = <span>true</span>;
<span>let</span> len;

<span>// good</span>
<span>const</span> goSportsTeam = <span>true</span>;
<span>const</span> items = getItems();
<span>let</span> dragonball;
<span>let</span> i;
<span>let</span> length;
</pre></div></div><ul><li><p>在必要的时候声明变量，并且将其放在合适的位置</p><div><p><code>let</code> 和 <code>const</code> 是块级作用域的，而不是函数作用域。</p></div></li></ul><div><div><pre><span>// good</span>
  <span>function</span>() {
    test();
    console.log(<span>'doing stuff..'</span>);

    <span>//..other stuff..</span>

    <span>const</span> name = getName();

    <span>if</span> (name === <span>'test'</span>) {
      <span>return</span> <span>false</span>;
    }

    <span>return</span> name;
  }

  <span>// bad</span>
  <span>function</span>() {
    <span>const</span> name = getName();

    <span>if</span> (!arguments.length) {
      <span>return</span> <span>false</span>;
    }

    <span>return</span> <span>true</span>;
  }

  <span>// good</span>
  <span>function</span>() {
    <span>if</span> (!arguments.length) {
      <span>return</span> <span>false</span>;
    }

    <span>const</span> name = getName();

    <span>return</span> <span>true</span>;
  }
</pre></div></div><h2>变量提升 Hoisting</h2><ul><li>通过 <code>var</code> 声明的变量将被提升到作用域的顶部，但他们的赋值不会被提升。通过<code>const</code> 和 <code>let</code> 声明的变量不存在变量提升，这里有一个新概念，称为“ <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" rel="nofollow,noindex" shape="rect" target="_blank">暂时性死区（ Temporal Dead Zones (TDZ)）</a> ”。有必要理解 <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15" rel="nofollow,noindex" shape="rect" target="_blank"><code>typeof</code> 不再是一个百分之百安全的操作 </a>。</li></ul><div><div><pre><span>// we know this wouldn't work (assuming there</span>
<span>// is no notDefined global variable)</span>
<span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  console.log(notDefined); <span>// =&gt; throws a ReferenceError</span>
}

<span>// creating a variable declaration after you</span>
<span>// reference the variable will work due to</span>
<span>// variable hoisting. Note: the assignment</span>
<span>// value of `true` is not hoisted.</span>
<span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  console.log(declaredButNotAssigned); <span>// =&gt; undefined</span>
  <span>var</span> declaredButNotAssigned = <span>true</span>;
}

<span>// The interpreter is hoisting the variable</span>
<span>// declaration to the top of the scope,</span>
<span>// which means our example could be rewritten as:</span>
<span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  <span>let</span> declaredButNotAssigned;
  console.log(declaredButNotAssigned); <span>// =&gt; undefined</span>
  declaredButNotAssigned = <span>true</span>;
}

<span>// using const and let</span>
<span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  console.log(declaredButNotAssigned); <span>// =&gt; throws a ReferenceError</span>
  console.log(<span>typeof</span> declaredButNotAssigned); <span>// =&gt; throws a ReferenceError</span>
  <span>const</span> declaredButNotAssigned = <span>true</span>;
}
</pre></div></div><ul><li>匿名函数表达式提升了对应的变量名，但赋值过程没有被提升</li></ul><div><div><pre><span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  console.log(anonymous); <span>// =&gt; undefined</span>

  anonymous(); <span>// =&gt; TypeError anonymous is not a function</span>

  <span>let</span> anonymous = <span>function</span>() {
    console.log(<span>'anonymous function expression'</span>);
  };
}
</pre></div></div><ul><li>命名的函数表达式提升了对应的变量名，函数名和函数体没有被提升</li></ul><div><div><pre><span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  console.log(named); <span>// =&gt; undefined</span>

  named(); <span>// =&gt; TypeError named is not a function</span>

  superPower(); <span>// =&gt; ReferenceError superPower is not defined</span>

  <span>var</span> named = <span><span>function</span></span><span> <span>superPower</span><span>()</span> </span><span>{</span>
    console.log(<span>'Flying'</span>);
  };
}

<span>// the same is true when the function name</span>
<span>// is the same as the variable name.</span>
<span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  console.log(named); <span>// =&gt; undefined</span>

  named(); <span>// =&gt; TypeError named is not a function</span>

  <span>var</span> named = <span><span>function</span></span><span> <span>named</span><span>()</span> </span><span>{</span>
    console.log(<span>'named'</span>);
  }
}
</pre></div></div><ul><li>函数声明将被提升</li></ul><div><div><pre><span><span>function</span></span><span> <span>example</span><span>()</span> </span><span>{</span>
  superPower(); <span>// =&gt; Flying</span>

  <span><span>function</span></span><span> <span>superPower</span><span>()</span> </span><span>{</span>
    console.log(<span>'Flying'</span>);
  }
}
</pre></div></div><ul><li>更多细节可以参考 <a href="http://www.adequatelygood.com/" rel="nofollow,noindex" shape="rect" target="_blank">Ben Cherry</a> 的 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting" rel="nofollow,noindex" shape="rect" target="_blank">JavaScript Scoping &amp; Hoisting</a></li></ul><h2>比较运算符和等号</h2><ul><li>使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code></li><li><p>比较运算通过 <code>ToBoolean</code> 强制转换并遵循一下规则：</p><ul><li><code>Object</code> - <code>true</code></li><li><code>Undefined</code> - <code>false</code></li><li><code>Null</code> - <code>false</code></li><li><code>Booleans</code> - 被转换为对应的值</li><li><code>Number</code> - 值为 <code>+0</code> ， <code>-0</code> ， <code>NaN</code> 时为 <code>false</code> ，否则为 <code>true</code></li><li><code>String</code> - 空字符串 <code>''</code> 为 <code>false</code> ，否则为 <code>true</code></li></ul></li></ul><div><div><pre><span>if</span> ([0]) {
  // <span>true</span>
  // An array is an object, objects evaluate to <span>true</span>
}
</pre></div></div><ul><li>使用快捷方式</li></ul><div><div><pre><span>// bad</span>
<span>if</span> (name !== <span>''</span>) {
  <span>// ...stuff...</span>
}

<span>// good</span>
<span>if</span> (name) {
  <span>// ...stuff...</span>
}

<span>// bad</span>
<span>if</span> (collection.length &gt; <span>0</span>) {
  <span>// ...stuff...</span>
}

<span>// good</span>
<span>if</span> (collection.length) {
  <span>// ...stuff...</span>
}
</pre></div></div><ul><li>更多细节请阅读 <a href="http://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" rel="nofollow,noindex" shape="rect" target="_blank">Truth Equality and JavaScript</a></li></ul><h2>块</h2><ul><li>给所有多行的块使用大括号</li></ul><div><div><pre><span>// bad</span>
<span>if</span> (test)
  <span>return</span> <span>false</span>;

<span>// good</span>
<span>if</span> (test) <span>return</span> <span>false</span>;

<span>// good</span>
<span>if</span> (test) {
  <span>return</span> <span>false</span>;
}

<span>// bad</span>
<span>function</span>() { <span>return</span> <span>false</span>; }

<span>// good</span>
<span>function</span>() {
  <span>return</span> <span>false</span>;
}
</pre></div></div><ul><li>使用 <code>if...else</code> 这样的多行块时，请将 <code>else</code> 和 <code>if</code> 的结束括号放在同一行</li></ul><div><div><pre><span>// bad</span>
<span>if</span> (test) {
  thing1();
  thing2();
}
<span>else</span> {
  thing3();
}

<span>// good</span>
<span>if</span> (test) {
  thing1();
  thing2();
} <span>else</span> {
  thing3();
}
</pre></div></div><h2>注释</h2><ul><li>使用 <code>/** ... */</code> 进行多行注释，包括描述，指定类型以及参数值和返回值</li></ul><div><div><pre><span>// bad</span>
<span>// make() returns a new element</span>
<span>// based on the passed in tag name</span>
<span>//</span>
<span>// @param &lt;String&gt; tag</span>
<span>// @return &lt;Element&gt; element</span>
function make(tag) {

  <span>// ...stuff...</span>

  <span>return</span> element;
}

<span>// good</span>
<span>/**</span><span>
 * make() returns a new element
 * based on the passed in tag name
 *
 * <span>@param</span> &lt;String&gt; tag
 * <span>@return</span> &lt;Element&gt; element
 */</span>
function make(tag) {

  <span>// ...stuff...</span>

  <span>return</span> element;
}
</pre></div></div><ul><li>使用 <code>//</code> 进行单行注释，将注释放在被注释对象的上面，并在注释之前保留一个空行</li></ul><div><div><pre><span>// bad</span>
<span>const</span> active = <span>true</span>;  <span>// is current tab</span>

<span>// good</span>
<span>// is current tab</span>
<span>const</span> active = <span>true</span>;

<span>// bad</span>
<span><span>function</span></span><span> <span>getType</span><span>()</span> </span><span>{</span>
  console.log(<span>'fetching type...'</span>);
  <span>// set the default type to 'no type'</span>
  <span>const</span> type = <span>this</span>._type || <span>'no type'</span>;

  <span>return</span> type;
}

<span>// good</span>
<span><span>function</span></span><span> <span>getType</span><span>()</span> </span><span>{</span>
  console.log(<span>'fetching type...'</span>);

  <span>// set the default type to 'no type'</span>
  <span>const</span> type = <span>this</span>._type || <span>'no type'</span>;

  <span>return</span> type;
}
</pre></div></div><ul><li>使用 <code>// FIXME:</code> 来注释一个问题</li></ul><div><div><pre><span><span>function</span></span><span> <span>Calculator</span><span>()</span> </span><span>{</span>

  <span>// FIXME: shouldn't use a global here</span>
  total = <span>0</span>;

  <span>return</span> <span>this</span>;
}
</pre></div></div><ul><li>使用 <code>// TODO:</code> 来注释一个问题的解决方案</li></ul><div><div><pre><span><span>function</span></span><span> <span>Calculator</span><span>()</span> </span><span>{</span>

  <span>// TODO: total should be configurable by an options param</span>
  <span>this</span>.total = <span>0</span>;

  <span>return</span> <span>this</span>;
}
</pre></div></div><h2>空白</h2><ul><li>将 <code>tab</code> 设置为 <code>2</code> 个空格缩进</li></ul><div><div><pre><span>// bad</span>
<span>function</span>() {
∙∙∙∙<span>const</span> name;
}

<span>// bad</span>
<span>function</span>() {
∙<span>const</span> name;
}

<span>// good</span>
<span>function</span>() {
∙∙<span>const</span> name;
}
</pre></div></div><ul><li>前大括号前放置一个空格</li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>test</span><span>()</span></span><span>{</span>
  console.log(<span>'test'</span>);
}

<span>// good</span>
<span><span>function</span></span><span> <span>test</span><span>()</span> </span><span>{</span>
  console.log(<span>'test'</span>);
}

<span>// bad</span>
dog.set(<span>'attr'</span>,{
  age: <span>'1 year'</span>,
  breed: <span>'Bernese Mountain Dog'</span>
});

<span>// good</span>
dog.set(<span>'attr'</span>, {
  age: <span>'1 year'</span>,
  breed: <span>'Bernese Mountain Dog'</span>
});
</pre></div></div><ul><li>运算符之间用空格分隔</li></ul><div><div><pre><span>// bad</span>
<span>const</span> x=y+<span>5</span>;

<span>// good</span>
<span>const</span> x = y + <span>5</span>;
</pre></div></div><ul><li>文件末尾使用单个换行符</li></ul><div><div><pre><span>// bad</span>
(<span>function</span>(global) {
  <span>// ...stuff...</span>
})(<span>this</span>);
</pre></div></div><div><div><pre><span>// bad</span>
(<span>function</span>(global) {
  <span>// ...stuff...</span>
})(<span>this</span>);↵
↵
</pre></div></div><div><div><pre><span>// good</span>
(<span>function</span>(global) {
  <span>// ...stuff...</span>
})(<span>this</span>);↵
</pre></div></div><ul><li>方法链式调用时保持适当的缩进，并且使用前置的 <code>.</code> 来表示该行是一个方法调用，而不是一个新语句</li></ul><div><div><pre><span>// bad</span>
$(<span>'#items'</span>).find(<span>'.selected'</span>).highlight().end().find(<span>'.open'</span>).updateCount();

<span>// bad</span>
$(<span>'#items'</span>).
  find(<span>'selected'</span>).
    highlight().
    end().
  find(<span>'.open'</span>).
    updateCount();

<span>// good</span>
$(<span>'#items'</span>)
  .find(<span>'.selected'</span>)
    .highlight()
    .end()
  .find(<span>'.open'</span>)
    .updateCount();

<span>// bad</span>
<span>const</span> leds = stage.selectAll(<span>'.led'</span>).data(data).enter().append(<span>'svg:svg'</span>).<span>class</span>(<span>'led'</span>, <span>true</span>)
    .attr(<span>'width'</span>,  (radius + margin) * <span>2</span>).append(<span>'svg:g'</span>)
    .attr(<span>'transform'</span>, <span>'translate('</span> + (radius + margin) + <span>','</span> + (radius + margin) + <span>')'</span>)
    .call(tron.led);

<span>// good</span>
<span>const</span> leds = stage.selectAll(<span>'.led'</span>)
    .data(data)
  .enter().append(<span>'svg:svg'</span>)
    .<span>class</span>(<span>'led'</span>, <span>true</span>)
    .attr(<span>'width'</span>,  (radius + margin) * <span>2</span>)
  .append(<span>'svg:g'</span>)
    .attr(<span>'transform'</span>, <span>'translate('</span> + (radius + margin) + <span>','</span> + (radius + margin) + <span>')'</span>)
    .call(tron.led);
</pre></div></div><ul><li>在语句块之后和下一语句之前都保持一个空行</li></ul><div><div><pre><span>// bad</span>
<span>if</span> (foo) {
  <span>return</span> bar;
}
<span>return</span> baz;

<span>// good</span>
<span>if</span> (foo) {
  <span>return</span> bar;
}

<span>return</span> baz;

<span>// bad</span>
<span>const</span> obj = {
  foo: <span>function</span>() {
  },
  bar: <span>function</span>() {
  }
};
<span>return</span> obj;

<span>// good</span>
<span>const</span> obj = {
  foo: <span>function</span>() {
  },

  bar: <span>function</span>() {
  }
};

<span>return</span> obj;
</pre></div></div><h2>逗号</h2><ul><li>不要将逗号放前面</li></ul><div><div><pre><span>// bad</span>
<span>const</span> story = [
    once
  , upon
  , aTime
];

<span>// good</span>
<span>const</span> story = [
  once,
  upon,
  aTime
];

<span>// bad</span>
<span>const</span> hero = {
    firstName: <span>'Bob'</span>
  , lastName: <span>'Parr'</span>
  , heroName: <span>'Mr. Incredible'</span>
  , superPower: <span>'strength'</span>
};

<span>// good</span>
<span>const</span> hero = {
  firstName: <span>'Bob'</span>,
  lastName: <span>'Parr'</span>,
  heroName: <span>'Mr. Incredible'</span>,
  superPower: <span>'strength'</span>
};
</pre></div></div><ul><li>不要添加多余的逗号，否则将在 IE6/7 和 IE9 的怪异模式下导致错误。同时，某些 ES3 的实现会计算多数组的长度，这在 ES5 中有 <a href="http://es5.github.io/#D" rel="nofollow,noindex" shape="rect" target="_blank">澄清</a></li></ul><div><div><pre><span>// bad</span>
  <span>const</span> hero = {
    firstName: <span>'Kevin'</span>,
    lastName: <span>'Flynn'</span>,
  };

  <span>const</span> heroes = [
    <span>'Batman'</span>,
    <span>'Superman'</span>,
  ];

  <span>// good</span>
  <span>const</span> hero = {
    firstName: <span>'Kevin'</span>,
    lastName: <span>'Flynn'</span>
  };

  <span>const</span> heroes = [
    <span>'Batman'</span>,
    <span>'Superman'</span>
  ];
</pre></div></div><h2>分号</h2><ul><li>句末一定要添加分号</li></ul><div><div><pre><span>// bad</span>
(function() {
  <span>const</span> name = <span>'Skywalker'</span>
  <span>return</span> name
})()

<span>// good</span>
(() =&gt; {
  <span>const</span> name = <span>'Skywalker'</span>;
  <span>return</span> name;
})();

<span>// good (guards against the function becoming an argument when two files with IIFEs are concatenated)</span>
;(() =&gt; {
  <span>const</span> name = <span>'Skywalker'</span>;
  <span>return</span> name;
})();
</pre></div></div><h2>类型转换</h2><ul><li>在语句的开始执行类型转换</li><li>字符串：</li></ul><div><div><pre><span>//  =&gt; this.reviewScore = 9;</span>

<span>// bad</span>
<span>const</span> totalScore = <span>this</span>.reviewScore + <span>''</span>;

<span>// good</span>
<span>const</span> totalScore = String(<span>this</span>.reviewScore);
</pre></div></div><ul><li>对数字使用 parseInt 并且总是带上类型转换的基数</li></ul><div><div><pre><span>const</span> inputValue = <span>'4'</span>;

<span>// bad</span>
<span>const</span> val = <span>new</span> Number(inputValue);

<span>// bad</span>
<span>const</span> val = +inputValue;

<span>// bad</span>
<span>const</span> val = inputValue &gt;&gt; <span>0</span>;

<span>// bad</span>
<span>const</span> val = parseInt(inputValue);

<span>// good</span>
<span>const</span> val = Number(inputValue);

<span>// good</span>
<span>const</span> val = parseInt(inputValue, <span>10</span>);
</pre></div></div><ul><li>不管是出于一些奇特的原因，还是 <code>parseInt</code> 是一个瓶颈而需要位运算来解决某些 <a href="http://jsperf.com/coercion-vs-casting/3" rel="nofollow,noindex" shape="rect" target="_blank">性能问题</a> ，请为你的代码注释为什么要这样做</li></ul><div><div><pre><span>// good</span>
<span>/**</span><span>
 * parseInt was the reason my code was slow.
 * Bitshifting the String to coerce it to a
 * Number made it a lot faster.
 */</span>
<span>const</span> val = inputValue &gt;&gt; <span>0</span>;
</pre></div></div><ul><li><strong>注意：</strong> 使用位移运算时要特别小心。 <code>Number</code> 在 JavaScript 中表示为 <a href="http://es5.github.io/#x4.3.19" rel="nofollow,noindex" shape="rect" target="_blank">64 位的值</a>，但位移运算总是返回一个 32 位的整数（ <a href="http://es5.github.io/#x11.7" rel="nofollow,noindex" shape="rect" target="_blank">source</a> ），对大于 32 位的整数进行位移运算会导致意外的结果（ <a href="https://github.com/airbnb/javascript/issues/109" rel="nofollow,noindex" shape="rect" target="_blank">讨论</a> ）。32 位最大整数为 <code>2,147,483,647</code> ：</li></ul><div><div><pre><span>2147483647</span> &gt;&gt; <span>0</span> <span>//=&gt; 2147483647</span>
<span>2147483648</span> &gt;&gt; <span>0</span> <span>//=&gt; -2147483648</span>
<span>2147483649</span> &gt;&gt; <span>0</span> <span>//=&gt; -2147483647</span>
</pre></div></div><ul><li>布尔值</li></ul><div><div><pre><span>var</span> age = <span>0</span>;

<span>// bad</span>
<span>var</span> hasAge = <span>new</span> Boolean(age);

<span>// good</span>
<span>var</span> hasAge = Boolean(age);

<span>// good</span>
<span>var</span> hasAge = !!age;
</pre></div></div><h2>命名约定</h2><ul><li>避免单个字符名，让你的变量名有描述意义</li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>q</span><span>()</span> </span><span>{</span>
  <span>// ...stuff...</span>
}

<span>// good</span>
<span><span>function</span></span><span> <span>query</span><span>()</span> </span><span>{</span>
  <span>// ..stuff..</span>
}
</pre></div></div><ul><li>命名对象、函数和实例时使用小驼峰命名规则</li></ul><div><div><pre><span>// bad</span>
<span>var</span> OBJEcttsssss = {};
<span>var</span> this_is_my_object = {};
<span>var</span> <span>this</span>-is-my-object = {};
<span><span>function</span></span><span> <span>c</span><span>()</span> </span><span>{</span>};
<span>var</span> u = <span>new</span> user({
  name: <span>'Bob Parr'</span>
});

<span>// good</span>
<span>var</span> thisIsMyObject = {};
<span><span>function</span></span><span> <span>thisIsMyFunction</span><span>()</span> </span><span>{</span>};
<span>var</span> user = <span>new</span> User({
  name: <span>'Bob Parr'</span>
});
</pre></div></div><ul><li>命名构造函数或类时使用大驼峰命名规则</li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>user</span><span>(options)</span> </span><span>{</span>
  <span>this</span>.name = options.name;
}

<span>const</span> bad = <span>new</span> user({
  name: <span>'nope'</span>
});

<span>// good</span>
<span><span>class</span></span><span> <span>User</span> </span><span>{</span>
  constructor(options) {
    <span>this</span>.name = options.name;
  }
}

<span>const</span> good = <span>new</span> User({
  name: <span>'yup'</span>
});
</pre></div></div><ul><li>命名私有属性时前面加个下划线 <code>_</code></li></ul><div><div><pre><span>// bad</span>
<span>this</span>.__firstName__ = <span>'Panda'</span>;
<span>this</span>.firstName_ = <span>'Panda'</span>;

<span>// good</span>
<span>this</span>._firstName = <span>'Panda'</span>;
</pre></div></div><ul><li>保存对 <code>this</code> 的引用时使用 <code>_this</code></li></ul><div><div><pre><span>// bad</span>
<span>function</span>() {
  <span>var</span> self = <span>this</span>;
  <span>return</span> <span>function</span>() {
    console.log(self);
  };
}

<span>// bad</span>
<span>function</span>() {
  <span>var</span> that = <span>this</span>;
  <span>return</span> <span>function</span>() {
    console.log(that);
  };
}

<span>// good</span>
<span>function</span>() {
  <span>var</span> _<span>this</span> = <span>this</span>;
  <span>return</span> <span>function</span>() {
    console.log(_<span>this</span>);
  };
}
</pre></div></div><ul><li>导出单一一个类时，确保你的文件名就是你的类名</li></ul><div><div><pre><span>// file contents</span>
<span><span>class</span></span><span> <span>CheckBox</span> </span><span>{</span>
  <span>// ...</span>
}
module.exports = CheckBox;

<span>// in some other file</span>
<span>// bad</span>
<span>const</span> CheckBox = <span>require</span>(<span>'./checkBox'</span>);

<span>// bad</span>
<span>const</span> CheckBox = <span>require</span>(<span>'./check_box'</span>);

<span>// good</span>
<span>const</span> CheckBox = <span>require</span>(<span>'./CheckBox'</span>);
</pre></div></div><ul><li>导出一个默认小驼峰命名的函数时，文件名应该就是导出的方法名</li></ul><div><div><pre><span><span>function</span></span><span> <span>makeStyleGuide</span><span>()</span> </span><span>{</span>
}

export <span>default</span> makeStyleGuide;
</pre></div></div><ul><li>导出单例、函数库或裸对象时，使用大驼峰命名规则</li></ul><div><div><pre><span>const</span> AirbnbStyleGuide = {
  es6: {
  }
};

<span>export</span> <span>default</span> AirbnbStyleGuide;
</pre></div></div><h2>访问器</h2><ul><li>属性的访问器函数不是必须的</li><li>如果你确实有存取器函数的话使用 <code>getVal()</code> 和 <code>setVal('hello')</code></li></ul><div><div><pre><span>// bad</span>
dragon.age();

<span>// good</span>
dragon.getAge();

<span>// bad</span>
dragon.age(<span>25</span>);

<span>// good</span>
dragon.setAge(<span>25</span>);
</pre></div></div><ul><li>如果属性是布尔值，使用 <code>isVal()</code> 或 <code>hasVal()</code></li></ul><div><div><pre><span>// bad</span>
<span>if</span> (!dragon.age()) {
  <span>return</span> <span>false</span>;
}

<span>// good</span>
<span>if</span> (!dragon.hasAge()) {
  <span>return</span> <span>false</span>;
}
</pre></div></div><ul><li>可以创建get()和set()函数，但是要保持一致性</li></ul><div><div><pre><span><span>function</span></span><span> <span>Jedi</span><span>(options)</span> </span><span>{</span>
  options || (options = {});
  <span>var</span> lightsaber = options.lightsaber || <span>'blue'</span>;
  <span>this</span>.set(<span>'lightsaber'</span>, lightsaber);
}

Jedi.prototype.set = <span>function</span>(key, val) {
  <span>this</span>[key] = val;
};

Jedi.prototype.get = <span>function</span>(key) {
  <span>return</span> <span>this</span>[key];
};
</pre></div></div><h2>事件</h2><ul><li>当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的事件处理器</li></ul><div><div><pre><span>// bad</span>
$(<span>this</span>).trigger(<span>'listingUpdated'</span>, listing.id);

...

$(<span>this</span>).on(<span>'listingUpdated'</span>, <span>function</span>(e, listingId) {
  <span>// do something with listingId</span>
});
</pre></div></div><div><div><pre><span>// good</span>
$(<span>this</span>).trigger(<span>'listingUpdated'</span>, { listingId : listing.id });

...

$(<span>this</span>).on(<span>'listingUpdated'</span>, <span>function</span>(e, data) {
  <span>// do something with data.listingId</span>
});
</pre></div></div><h2>jQuery</h2><ul><li>为 jQuery 对象命名时添加 <code>$</code> 前缀</li></ul><div><div><pre><span>// bad</span>
<span>const</span> sidebar = $(<span>'.sidebar'</span>);

<span>// good</span>
<span>const</span> <span>$sidebar</span> = $(<span>'.sidebar'</span>);
</pre></div></div><ul><li>缓存 jQuery 的查询结果</li></ul><div><div><pre><span>// bad</span>
<span><span>function</span></span><span> <span>setSidebar</span><span>()</span> </span><span>{</span>
  $(<span>'.sidebar'</span>).hide();

  <span>// ...stuff...</span>

  $(<span>'.sidebar'</span>).css({
    <span>'background-color'</span>: <span>'pink'</span>
  });
}

<span>// good</span>
<span><span>function</span></span><span> <span>setSidebar</span><span>()</span> </span><span>{</span>
  <span>const</span> <span>$sidebar</span> = $(<span>'.sidebar'</span>);
  <span>$sidebar</span>.hide();

  <span>// ...stuff...</span>

  <span>$sidebar</span>.css({
    <span>'background-color'</span>: <span>'pink'</span>
  });
}
</pre></div></div><ul><li>对DOM查询使用级联的 <code>$('.sidebar ul')</code> 或 <code>$('.sidebar ul')</code> ， <a href="http://jsperf.com/jquery-find-vs-context-sel/16" rel="nofollow,noindex" shape="rect" target="_blank">jsPerf</a></li><li>在指定作用域进行查询时使用 <code>find</code></li></ul><div><div><pre><span>// bad</span>
$(<span>'ul'</span>, <span>'.sidebar'</span>).hide();

<span>// bad</span>
$(<span>'.sidebar'</span>).find(<span>'ul'</span>).hide();

<span>// good</span>
$(<span>'.sidebar ul'</span>).hide();

<span>// good</span>
$(<span>'.sidebar &gt; ul'</span>).hide();

<span>// good</span>
<span>$sidebar</span>.find(<span>'ul'</span>).hide();</pre></div></div></div></div><br clear="none"/></div></span>
</div></body></html> 