<html>
<head>
  <title>java各种概念</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8727"/>
<h1>java各种概念</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2015/8/20 22:12</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2015/8/21 7:50</i></td></tr>
</table>
</div>
<br/>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
java各种概念.txt鲜花往往不属于赏花的人，而属于牛粪。。。道德常常能弥补智慧的缺陷，然而智慧却永远填补不了道德空白人生有三样东西无法掩盖：咳嗽     贫穷和爱，越隐瞒，就越欲盖弥彰。                                        Core Java总结<br/>
Base:<br/>
OOA是什么？OOD是什么？OOP是什么？<br/>
分别是：面向对象分析、面向对象设计、面向对象编程<br/><br/>
抽象的概念：<br/>
抽象就是忽略一个主题中与当前目标无关的方面，以便更充分地注意与当前目标相关的方法。抽象并不打算了解全部问题，而只是选择其中的一部分。抽象包括过程抽象和数据抽象两个方面。<br/><br/>
继承的概念：<br/>
继承是一种联结类的层次模型，并且允许和鼓励类的重用，提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程就是类的继承，子类继承父类的特性。子类可以从父类继承方法和实例变量，并且子类可以修改或增加新的方法以便更适合的使用。<br/><br/>
封装的概念：<br/>
封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个概念。<br/><br/>
多态的概念：<br/>
多态是指同一个消息的不同响应方式，又可分为运行时多态和编译期多态。<br/><br/>
构造器是否可被Override<br/>
不可以，但是可以Overload。<br/><br/>
接口是否可继承接口？抽象类是否可以实现接口？抽象类是否可继承实体类？<br/>
可以；可以；可以。<br/><br/>
Overload和Override的区别<br/>
两者是多态的不同表现，Override是父类和子类之间多态性的一种表现，Overload是一个类中多态性的一种表现。Overload本身和返回值无关，所以是可以改变返回值的。<br/><br/>
abstract class和interface的区别<br/>
抽象类中可以存在非抽象方法，而接口不可以。抽象类只可以被单继承而接口则可以实现多继承。<br/><br/>
&amp;和&amp;&amp;的区别<br/>
&amp;是位运算符，表示按位与运算，&amp;&amp;是逻辑运算符，表示逻辑与(and)<br/><br/>
int和Integer有什么区别<br/>
Java的两种不同的类型，基本数据类型和复合类型，Integer是int的封装类型，提供了多种方法调用。运行速度上也有着区别，基本数据类型的运行速度更快。<br/><br/>
String是最基本的数据类型吗？<br/>
基本数据类型只有以下8种:boolean,byte,char,short,int,float,long,double。所以String不是最基本的数据类型。<br/><br/>
String和StringBuffer的区别<br/>
都可以储存和操作字符串，String提供了数值不可变的字符串，而StringBuffer可以进行字符串的修改。<br/><br/>
是否可继承String类<br/>
不可以，String类是final的。<br/><br/>
final,finally,finalize的区别<br/>
final是最终形态修饰符，修饰变量时，此变量为常量，修饰方法时，此方法不可被重写，修饰类时，此类不可被继承。<br/>
finally是异常处理语句结构的一部分，表示总会被执行的语句块。<br/>
finalize是Object中的方法，在垃圾回收器执行的时候会调用被回收对象的该方法用于释放一些资源。<br/><br/>
String s = new String(“xyz”)一共创建了几个String对象？<br/>
两个<br/><br/>
Static Nested Class和Inner Class的不同<br/>
静态内部类可以不依赖于外部实例被实例化，而内部类需要在外部类实例化后才能实例化。<br/><br/>
GC是什么？为什么要有GC？<br/>
GC是垃圾回收器，程序员经常会忘记或错误的进行内存回收而导致程序或系统的不稳定甚至崩溃，java使用GC可以自动回收内存。<br/><br/>
abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized<br/>
都不能。<br/><br/>
数组有没有length()方法？String有没有length()方法<br/>
没有；有。<br/><br/>
switch能够作用在byte上，能否作用在long上，能否作用在String上<br/>
switch只能作用于以下几种类型：byte,char,short,int。<br/><br/>
两个对象值相同，但却可有不同的hash code<br/>
这话不对，值相同，hash code一定相同。<br/><br/>
Java是值传递还是引用传递？<br/>
值传递，一个对象被当作参数传递进一个方法后，值被改变，在此方法结束后，被改变的值将保留，那是因为参数的值就是对该对象的引用，所以引用其实是不同的，但是所指对象是相同的。<br/><br/>
Java的接口和C++的虚类的相同和不同处<br/>
Java的接口和C++的虚类都可以实现多继承，只是C++的虚类类似于Java的抽象类。<br/><br/>
JVM加载类文件的原理机制<br/>
JVM中类的装载是由ClassLoader和它的子类来实现，ClassLoader是一个重要的Java运行时系统组件，负责在运行时查找和装入类文件的类。<br/><br/>
char型变量能存储一个中文汉字吗？<br/>
能，因为java中以unicode编码，一个char占16个字节，所以可以。<br/><br/>
逻辑操作(&amp;,|,^)与条件操作(&amp;&amp;,||)的区别<br/>
条件操作只能操作boolean型，而逻辑操作不仅可以操作boolean还可以操作数值型。逻辑操作不会产生短路。<br/><br/>
是否可以从一个static方法内部发出对非static方法的调用<br/>
不可以。<br/><br/>
写clone()方法时，通常都有一行代码，是什么？<br/>
clone有缺省行为，super.clone()；负责产生正确大小的空间，并逐位复制。<br/><br/>
静态变量和实例变量的区别<br/>
静态变量为类所有，一个类的每一个实例都共用该变量，因此，对于每个实例来说，其值都是一致的。实例变量为每一个实例所特有，因此，对于每个实例来说，实例变量的值都保证了自己的某些状态。<br/><br/>
Anonymous Inner Class是否可继承其他类或实现接口<br/>
都可以。<br/><br/>
Java中有没有goto?<br/>
有，是保留字，但是不能使用。<br/><br/>
访问修饰符的区别<br/>
作用域<br/>
当前类<br/>
同包<br/>
子类<br/>
其他<br/><br/>
public<br/>
√<br/>
√<br/>
√<br/>
√<br/><br/>
protected<br/>
√<br/>
√<br/>
√<br/>
×<br/><br/>
default(不写时)<br/>
√<br/>
√<br/>
×<br/>
×<br/><br/>
private<br/>
√<br/>
×<br/>
×<br/>
×<br/><br/><br/>
Java是从什么语言改进重新设计？<br/>
C++<br/><br/>
以下哪句话正确？<br/>
A.Java程序经过编译后产生machine code<br/>
B.Java程序经过编译后产生byte code<br/>
C.Java程序经过编译后产生dll<br/>
D.以上都不正确<br/>
答案：B<br/><br/>
以下说法正确的有<br/>
A.class中constructor不可省略<br/>
B.constructor必须与class同名，但方法不能与class同名<br/>
C.constructor在一个对象被new时执行<br/>
D.一个class只能定义一个constructor<br/>
答案：C<br/><br/>
下列语句正确的是<br/>
A.形参可被视为local variable<br/>
B.形参可被字段修饰符修饰<br/>
C.形参为方法被调用时，真正被传递的参数<br/>
D.形参不可以是对象<br/>
答案：A<br/><br/>
public class A{<br/><br/><br/>
int x = 10;<br/><br/><br/>
public A(){<br/><br/><br/>
System.out.println(&quot;A's constructor&quot;);<br/><br/><br/>
add(2);<br/><br/><br/><br/>
}<br/><br/><br/>
public void add(int y){<br/><br/><br/>
System.out.println(&quot;A's add method&quot;);<br/><br/><br/>
x+=y;<br/><br/><br/>
}<br/>
}<br/>
class B extends A{<br/><br/><br/>
int x = 9;<br/><br/><br/>
public B(){<br/><br/><br/>
System.out.println(&quot;B's constructor&quot;);<br/><br/><br/>
}<br/><br/><br/>
public void add(int y){<br/><br/><br/>
System.out.println(&quot;B's add method&quot;);<br/><br/><br/>
x+=y;<br/><br/><br/>
}<br/><br/><br/>
public static void main(String []args){<br/><br/><br/>
A a = new B();<br/><br/><br/>
System.out.println(a.x);<br/><br/><br/>
B b = new B();<br/><br/><br/>
System.out.println(b.x);<br/><br/><br/>
A c = new A();<br/><br/><br/>
System.out.println(c.x);<br/><br/><br/>
}<br/>
}<br/><br/>
以上程序输出结果是多少？<br/><br/>
10，9，12<br/>
Exception:<br/>
运行时异常与一般异常有何不同<br/>
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。Java编译器要求方法必须声明抛出可能发生的非运行时异常，但并不要求必须声明抛出未被捕获的运行时异常。<br/><br/>
Error和Exception的区别<br/>
Error表示恢复很困难的一种严重问题，一般由os或jvm抛出。Exception表示一种设计或实现问题，一般由运行的程序本身产生和抛出。<br/><br/>
try里有个return语句，紧跟在try后的finally中的code是否会被执行<br/>
会，在return之前。<br/>
Collection:<br/>
说出ArrayList,Vectory,LinkedList的存储性能和特性<br/>
ArrayList和Vectory实现了线性结构，遍历元素时，效率较高，LinkedList实现了链表结构（双向循环），插入和删除效率较高，ArrayList是线程异步，Vectory是线程同步，所以执行效率Vectory较低，但是数据安全性较高。<br/><br/>
Collection和Collections的区别<br/>
Collection是集合框架的父接口，其直接子接口主要有Set和List。Collections是针对集合类的一个工具类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。<br/><br/>
HashMap和Hashtable的区别<br/>
Hashtable的方法是同步的而HashMap不是，另外HashMap允许有一个null作为key,而Hashtable不允许<br/><br/>
heap和stack有什么区别<br/>
stack是一种线形集合，按照先进后出（FILO）的方式进行处理。heap是stack的一个组成元素。<br/><br/>
List,Set,Map是否继承自Collection接口？<br/>
List,Set是；Map不是。<br/><br/>
Set里的元素是不能重复的，那么用什么方法来区分是否重复？是用==还是equals？有什么区别？<br/>
通过iterator来区分是否重复。==判断的是地址，equals判断内容和类型是否相同。<br/><br/>
List,Set,Map接口各有什么特点？<br/>
List以特有次序来存放元素，可以重复。Set内部排序，不可重复。Map接口以键值对来存放数据，键不可重复，值可以重复。<br/>
Thread:<br/>
sleep和wait的区别<br/>
sleep是线程类Thread的方法，导致此线程暂停执行指定时间，将CPU的控制权出让给其他线程，但监控状态依然保持，到时恢复。wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify或notifyAll后本线程才进入对象锁定池准备获得对象锁进入运行状态。<br/><br/>
同步和异步的区别<br/>
独占锁的概念，同步为线程独占，异步则是共享使用，同步将导致运行效率降低，异步则可能使得多线程并发访问资源时产生状态的冲突。<br/><br/>
一个线程进入一个synchronized方法后，其他线程是否可进入此对象的其他方法？<br/>
可以进入他的其他方法，而不能进入那一个方法。<br/><br/>
简述synchronized和java.util.concurrent.locks.Lock的异同<br/>
Lock能完成synchronized所实现的所有功能。Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手动释放，并且必须在finally中释放。<br/><br/>
启动一个线程需要调用什么方法？<br/>
start方法。但是并不代表这个线程被启动了，而是处于一个待启动状态。线程启动将调用run方法。<br/>
IO:<br/>
Java中有几种类型的流？<br/>
根据不同的分类可以分为：输入流和输出流、字节流和字符流、节点流和介质流。<br/><br/>
什么是Java序列化，如何实现Java序列化<br/>
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流花。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题。<br/>
JDBC:<br/>
如多用户同时访问数据库,应采用什么技术来进行数据库连接管理？<br/>
可采用数据库连接池。<br/><br/>
Java中访问数据库的步骤,Statement和PreparedStatement的区别？<br/>
（1）.注册驱动<br/>
（2）创建连接<br/>
（3）创建执行对象<br/>
（4）执行SQL语句<br/>
（5）处理结果集<br/>
（6）关闭连接<br/>
PreparedStatement是预编译的处理语句，可以使语句本身保存在内存中，在多次执行时效率很高。<br/><br/>
JDBC如何实现分页<br/>
JDBC分页分为数据库分页和应用程序分页两种。应用程序分页讲求将所有符合条件数据一次性取出，存放在数组或动态数组中，然后按要求提取。数据库分页按照数据库的不同，采取的方式也不一样，如MSSQL中按照TOP来进行分页，而Oracle中则根据伪列来进行分页。<br/><br/>
事务处理的方法<br/>
Connection中有3种事务处理方案:setAutoCommit(boolean)自动提交;commit()提交;rollback回滚。<br/>
XML:<br/>
XML文档定义有几种形式？有什么本质区别？解析XML文档有哪几种方式？<br/>
有DTD和schema两种方式。本质区别在于schema本事就是一份格式良好的XML文档，并且加入了类型指定，名称空间等内容，更加适合于XML文档的定义和规范。解析XML文档有多种方式，如DOM,SAX,JDOM等。<br/><br/>
XML在项目中的运用有哪些？<br/>
临时性的数据存储及传递：如AJAX技术从后台将数据传递到前台时，可以写成XML文档的格式进行传递，并在前台进行解析。<br/>
配置文件：如数据源的配置，框架的配置，JavaWeb应用的信息配置等。<br/>
Java Web:<br/>
Servlet生命周期，说出Servlet和CGI的区别<br/>
生命周期：new&gt;init&gt;service&gt;destory。<br/>
CGI对每个请求都产生新的进程，而servlet是通过多线程的方式服务于每个请求。CGI效率较低。<br/><br/>
forward和redirect的区别<br/>
forward是服务器请求资源，服务器直接访问目标地址URL，把URL的响应内容读取过来，再发送给浏览器，浏览器无法得知服务器从哪里获得来的内容，所以地址栏中不变。redirect是服务端根据逻辑，发送一个状态码告诉浏览器重新去请求一个地址。forward之后request不变，而redirect之后request已经改变。<br/><br/>
动态include和静态include区别<br/>
动态include用jsp:include动作实现，它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数。静态include不会检查所含文件的变化，适合包含静态页面。<br/><br/>
说出数据库连接池的工作机制<br/>
J2EE服务器启动时会建立一定数量的连接，并一直维持不少于此数目的连接，连接有两个状态，繁忙和空闲。按客户访问量进行增加和减少连接数量。在所有连接都处于繁忙状态时，连接池将增加连接数，当大部分连接都属于空闲状态时，连接池将自动清理一些连接。<br/><br/>
JSP的内置对象及方法<br/>
request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, header, 和session数据的有用的方法。<br/>
response表示HttpServletResponse对象，并提供了几个用于设置送回浏览器的响应的方法（如cookies,头信息等）。<br/>
out对象是javax.servlet.jsp.JspWriter的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。<br/>
pageContext表示一个javax.servlet.jsp.PageContext对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。<br/>
session表示一个请求的javax.servlet.http.HttpSession对象。Session可以存贮用户的状态信息。<br/>
applicaton 表示一个javax.servle.ServletContext对象。这有助于查找有关servlet引擎和servlet环境的信息。<br/>
config表示一个javax.servlet.ServletConfig对象。该对象用于存取servlet实例的初始化参数。<br/>
page表示从该页面产生的一个servlet实例。<br/>
exception记录了页面中的异常信息，此对象只可在page指令属性isErrorPage=”true”的页面中才能访问到。<br/><br/>
JSP常用指令<br/>
page、taglib、include<br/><br/>
什么情况下调用goGet()和doPost()<br/>
servlet在接收到用户请求时，调用service方法，此方法根据请求的类型(get或post)调用相应的方法。<br/><br/>
JSP和Sevlet的相同和不同，有什么联系？<br/>
JSP是Servlet技术的演变和扩展，JSP更强调和适合于视图层，Servlet则更适合于控制层。<br/><br/>
MVC的各个部分都有哪些技术来实现？<br/>
Java的WEB应用中，M层由JavaBean来实现，V层由JSP或HTML来实现，C层由Servlet来实现。<br/><br/>
JSP的6个基本动作是什么？作用是什么？<br/>
include动作用于动态包含一个文件。useBean动作用于在指定范围内获取一个指定名称及类型的对象。setProperty动作用于对指定的对象进行赋值操作。getProperty动作用于对指定对象的指定属性进行取值。forward动作用于把请求转发到另一个页面。plugin动作用于为java插件生成object或embed标记。<br/><br/>
get和post的区别<br/>
get将表单数据按照variable=value的形式，添加到action所指向的URL后面，并且两者使用“？”连接，各变量之间使用“&amp;”连接；post是将表单中的数据放在form的数据体中，按照变量和值相对应的方式，传递到action所指URL。get不安全;post相对较安全。get受URL长度限制，传输的数据量小，post则可以传输较大数据。get限制form表单的数据集必须为ASCII字符，而post支持整个ISO10646个字符集。<br/><br/>
Servlet2.2以上Web Application的基本目录结构<br/>
webapps---|<br/><br/>
|---Application---|<br/><br/><br/>
|----JSP页面<br/><br/>
|----WEB-INF--|<br/><br/>
|----classes<br/><br/>
|----lib<br/><br/>
|----web.xml<br/><br/>
JSP的四种范围<br/>
page是代表与一个页面相关的对象和属性。<br/>
request是代表与web客户机发出的一个请求相关的对西哪个和属性，一个请求可能跨越多个页面。<br/>
session是代表与用于某个web客户机的一个用户体验相关的对象和属性。一个web会话可以跨越多个客户请求。<br/>
application代表与整个web应用程序相关的对象和属性。跨越整个web应用程序，包括多个页面，请求和会话。<br/><br/>
过滤器的用途有哪些？<br/>
过滤器主要做拦截作用，所以可以做很多事情，比如过滤一些不合法的词汇、验证是否正常登陆、字符编码的转换。<br/><br/>
过滤器的用法？<br/>
实现Filter接口，覆盖init(FilterConfig config)、doFilter(ServletRequest request,ServletResponse response,FilterChain chain)、destroy()方法。<br/><br/>
JSP中如何使用JavaBeans?<br/>
JSP有对于JavaBean操作的标准动作，useBean、setProperty、getProperty<br/><br/>
JSP和Servlet中的请求转发分别如何来实现？<br/>
JSP中可以使用forward动作来实现。同时JSP和Servlet都可以使用request.getRequestDispatcher(path).forward(req,res);来进行请求转发。<br/><br/>
web.xml的作用<br/>
用于配置web应用的信息，如servlet,filter等。<br/>
JavaEE:Base:<br/>
J2EE是技术还是平台还是框架<br/>
J2EE本身是一个标准，一个为企业分布式应用的开发提供的标准平台。<br/>
J2EE也是一个框架，包括JDBC、JNDI、RMI、JMS、EJB、JTA等技术。<br/><br/>
请解释一下以下J2EE名词：WEB容器、EJB容器、JNDI、JMS、JTA、JAF、RMI/IIOP<br/>
WEB容器：给处于其中的应用程序组件（JSP、Servlet）提供一个环境，使JSP、Servlet直接与容器中的环境变量接口交互，不必关注其它系统问题。该容器提供的接口严格遵守J2EE规范中的WebApplication标准。遵守以上标准的WEB服务器就叫做J2EE的WEB容器。<br/>
EJB容器：EnterpriseJavaBean容器。更具有行业领域特色。提供给运行在其中的组件EJB各种管理功能。只要满足J2EE规范的EJB放入该容器，马上就会被容器进行高效率的管理。并且可以通过现成的接口来获得系统级别的服务。<br/>
JNDI：（Java Naming &amp; Directory Interface）Java命名目录服务。主要提供的功能是：提供一个目录系统，让其它各地的应用程序在某上面留下自己的索引，从而满足快速查找和定位分布式应用程序的功能。<br/>
JMS：（Java Message Service）Java消息服务。主要实现各个应用程序之间的通讯。包括点对点和广播。<br/>
JTA：（Java Transaction API）Java事务服务。提供各种分布式事务服务。应用程序只需调用其提供的接口即可。<br/>
JAF：（Java Action Framework）Java安全认证框架。提供一些安全控制方面的框架。让开发者通过各种部署和自定义实现自己的个性安全控制策略。<br/>
RMI/IIOP（Remote Method Invocation/internet对象请求中介协议）他们主要用于通过远程调用服务。<br/>
Struts:<br/>
什么是STRUTS？<br/>
struts本意为结构，在J2EE中为一个WEB框架，采用了JSP/Servlet/JavaBean技术。可以开发出基于MVC模式的应用架构。<br/><br/>
STRUTS的入口类？<br/>
ActionServlet，所有对Action的请求都经由该类转发处理。<br/>
Hibernate:<br/>
什么是ORM？<br/>
Object Relational Mapping。是一种为了解决面向对象与面向关系数据库存在的互不匹配的现象的技术。通过使用描述对象和数据库之间映射的元数据，将java程序中的对象自动持久化到关系数据库中。<br/><br/>
Hibernate比JDBC的优点？<br/>
解决了对象模型与关系模型之间的阻抗不匹配问题。Hibernate灵活且运用简单，大量使用配置文件和映射文件来解决类与表或视图的对应关系，便于维护。完善的事务处理和利用缓存以性能。<br/><br/>
Hibernate有哪5个核心接口<br/>
Configuration:配置Hibernate,根据其启动hibernate,创建SessionFaction对象。<br/>
SessionFactory:初始化Hibernate,充当数据存储源的代理，创建session对象，SessionFactiory是线程安全的，同一个实例可以被应用的多个线程共享。<br/>
Session:负责保存、更新、删除、加载和查询对象，线程不安全，需要避免多个线程共享同一个session。<br/>
Transaction:管理事务。<br/>
Query和Criteria:执行数据库的查询。<br/><br/>
关于Hibernate，配置文件呈现一对多，多对多的标签是什么？Hibernate的二级缓存是什么？Hibernate是如何处理事务的？<br/>
一对多的标签是&lt;one-to-many&gt;,多对多的标签是&lt;many-to-many&gt;。SessionFactory的缓存是Hibernate的二级缓存。Hibernate的事务实际上是底层的JDBC Transaction的封装或者是JTA Transaction的封装。默认情况下使用JDBC Transaction。<br/><br/>
Hibernate映射文件中属性与表中列的关系，如属性String对应的表中的类型为？<br/>
字符型，如char,varchar等或大文本text。<br/><br/>
Hibernate分页实现代码<br/>
Query query = session.createQuery(“from Emp”);<br/>
query.setFirstResult(first);<br/>
query.setMaxResults(pageSize);<br/>
Collection emps = query.list();<br/><br/>
Session中的load和get的区别<br/>
当给定的对象标识不存在时，get返回null，而load则抛出一个异常。<br/>
Spring:<br/>
简述Spring框架。<br/>
Spring框架是一个分层架构，由七个定义良好的模块组成，Spring模块构建在核心容器之上，核心容器定义了创建、配置和管理bean的方式。组成Spring框架的每个模块都可以单独存在，或者与其他一个或多个模块联合实现。<br/>
Spring Core、Spring Context、Spring AOP、Spring DAO、Spring ORM、Spring Web、Spring MVC<br/>
EJB:<br/>
EJB是基于哪些技术实现的，SessionBean和EntityBean的区别<br/>
EJB包括SessionBean,EntityBean,MessageDrivenBean,基于JNDI、RMI、JTA等技术实现。SessionBean在J2EE应用程序中被用来完成一些服务器端的业务操作，例如访问数据库，调用其他EJB组件。EntityBean用来临时性存储数据。<br/><br/>
EJB与JavaBean的区别<br/>
JavaBean是可复用的组件，对JavaBean并没有严格的规范，任何一个java类都可以是一个Bean，但由于通常JavaBean是被容器所创建，所以JavaBean应具有一个无参的构造器，并实现Serializable接口用于持久化，JavaBean是不能被跨进程访问的。EJB是基于java的RMI技术，所以EJB可以被远程访问（跨进程，跨计算机）。但EJB必须被部署在支持EJB的容器中（如Webspere，WebLogic等），EJB客户不直接访问EJB组件，而是通过容器访问。<br/><br/>
说明EJB中的SessionBean和EntityBean的生命周期，以及如何进行事务管理<br/>
SessionBean：StatelessSessionBean的生命周期由容器决定，当客户机发出请求要建立一个Bean的实例时，EJB容器不一定要创建一个新的Bean的实例给客户机调用，而是找一个现有的实例提供给客户机。客户机第一次调用一个StatefulSessionBean时，容器会立刻在服务器中创建一个新的Bean实例，并关联到客户机上，以后此客户机调用StatefulSessionBean的方法时容器会把调用分派到与此客户机相关联的Bean实例。<br/>
EntityBean：EntityBean能存活相对较长的时间，并且状态是持续的。只要数据库中的数据存在，EntityBean就一直存活。而不按照应用程序或者服务进程来结束生命。EntityBean生命周期能够被容器或Bean自己管理。<br/>
EJB通过以下技术管理事务：OTS（Object Transaction Service）,JTS（Java Transaction Service）,JTA（Java Transaction API）<br/><br/>
EJB的角色和三个对象<br/>
一个完整的基于EJB的分布式计算结构由六个角色组成，每个角色所做的工作必须遵循Sun公司提供的EJB规范，以保证彼此之间的兼容性。这六个角色分别是EJB组件开发者（Enterprise Bean Provider）、应用组合者（Application Assembler）、部署者（Deployer）、EJB服务提供者（EJB ServerProvider）、EJB容器提供者（EJB Container Provider）、系统管理员（System Administrator）。三个对象是Remote（Local）接口、Home（LocalHome）接口、Bean类。<br/><br/>
EJB容器提供的服务<br/>
主要提供生命周期管理、代码产生、持续性管理、安全、事务管理、锁和并发管理等服务。<br/><br/>
EJB禁止哪些操作<br/>
1.不能操作线程和线程API（线程API指非线程对象的方法如notify,wait等）。<br/>
2.不能操作awt。<br/>
3.不能实现服务器功能。<br/>
4.不能对静态属性存取。<br/>
5.不能使用IO操作直接存取文件系统。<br/>
6.不能加载本地库。<br/>
7.不能将this作为变量和返回。<br/>
8.不能循环调用。<br/><br/>
remote接口和home接口主要作用<br/>
remote接口定义了业务方法，用于EJB客户端调用业务方法。home接口是EJB工厂用于创建和移除查找EJB实例。<br/><br/>
bean实例的生命周期<br/>
对于Stateless Session Bean、Entity Bean、Message Driven Bean一般存在缓冲池管理，而对于Entity Bean和Statefull Session Bean存在Cache管理，通常包含创建实例，设置上下文、创建EJBObject（create）、业务方法调用、remove等过程，对于存在缓冲池管理的Bean，在create之后实例并不从内存清除，而是采用缓冲池调度机制不断重用实例，而对于存在Cache管理的Bean则通过激活和去激活机制保持Bean的状态并限制内存中实例数量。<br/><br/>
EJB的激活机制<br/>
以Stateful Session Bean为例：其Cache大小决定了内存中可以同时存在的Bean实例的数量，根据MRU或NRU算法，实例在激活和去激活状态之间迁移，激活机制是当客户端调用某个EJB实例业务方法时，如果对应EJBObject发现自己没有绑定对应的Bean实例则从其去激活Bean存储中（通过序列化机制存储实例）回复（激活）此实例。状态变迁前会调用对应的EJBActive和EJBPassivate方法。<br/><br/>
EJB的几种类型<br/>
Session Bean,Entity Bean和Message Driven Bean。Session Bean又可分为Stateless Session Bean和Stateful Session Bean。Entity Bean又可分为Bean管理持续性（BMP）和容器管理的持续性（CMP）。<br/><br/>
客服端调用EJB对象的几个基本步骤<br/>
设置JNDI服务工厂以及JNDI服务地址系统属性，查找Home接口，从Home接口调用create方法创建Remote接口，通过Remote接口调用其业务方法。<br/>
RDBMS&amp;SQL:<br/>
3张表student学生表（学号，姓名，性别，年龄，组织部门）、course课程表（编号，课程名称）、sc选课表（学号，课程编号，成绩）。<br/>
写一个SQL语句，查询选修了“计算机原理”的学生学号和姓名。<br/>
写一个SQL语句，查询“周星驰”同学选修的课程名称。<br/>
写一个SQL语句，查询选修了5门课程的学生学号和姓名。<br/>
写一个SQL语句，查询选修了所有课程的学生学号和姓名。<br/>
（1）SELECT sno,sname FROM student stu WHERE stu.sno IN (SELECT sc.sno FROM sc WHERE sc.cno = (SELECT course.cno FROM course WHERE cname LIKE ‘计算机原理’));<br/>
（2）SELECT cname FROM course cou WHERE cou.cno IN (SELECT sc.cno FROM sc WHERE sc.sno IN (SELECT student.sno FROM student WHERE sname like ‘周星驰’));<br/>
（3）SELECT student.sno,sname FROM student WHERE student.sno IN (SELECT sc.sno FROM sc GROUP BY sc.sno HAVING count(*)=5);<br/>
（4）SELECT student.sno,sname FROM student WHERE student.sno IN (SELECT sc.sno FROM sc GROUP BY sc.sno HAVING count(*)=(SELECT count(*) FROM course));<br/><br/>
有一张表EMP，表中字段为（empno,ename,mgr,age）,写出语句查询所有雇员年龄大于其领导的人员名单。<br/>
SELECT worker.ename FROM emp worker WHERE worker.age&gt;(SELECT manager.age FROM emp manager WHERE manager.empno = worker.mgr);<br/><br/>
有两张表分别代表的省和市的信息，其中省信息表中字段为（stateno,statename）,市信息表中字段为（cityno,cityname,stateno），省信息表中有广东，江苏，辽宁，黑龙江，市信息表中有上海，广州，北京，南京。现在需要查询出所有市信息及相关省信息，请写出查询语句。<br/>
SELECT cityname,cityno,s.stateno,s.statename FROM city c,state s WHERE c.stateno = s.stateno(+);<br/>
Base Web:Javascript<br/>
一个动态的下拉列表，如何在每一次点击后显示出所有被选中的值？<br/>
&lt;script type=&quot;text/javascript&quot;&gt;<br/><br/>
function choose(sel){<br/><br/><br/>
alert(sel.options[sel.selectedIndex].innerHTML);<br/>
     }<br/>
&lt;/script&gt;<br/>
&lt;select onchange=”choose(this)”&gt;<br/><br/>
&lt;option&gt;1&lt;/option&gt;<br/><br/>
&lt;option&gt;2&lt;/option&gt;<br/><br/>
&lt;option&gt;3&lt;/option&gt;<br/>
&lt;/select&gt;<br/>
封装一个类，包含属性name和sex，在设置其值后再取出<br/><br/>
function myObject(){<br/>
var innerClass = new Object();<br/>
innerClass.name='undefined';<br/>
innerClass.sex='undefined';<br/>
innerClass.setName = function (n){<br/><br/>
name = n;<br/>
}<br/>
innerClass.setSex = function (s){<br/>
sex = s;<br/>
}<br/>
innerClass.getName = function (){<br/>
return name;<br/>
}<br/>
innerClass.getSex = function (){<br/>
return sex;<br/>
}<br/>
return innerClass;<br/>
}
</span>
</div></body></html> 