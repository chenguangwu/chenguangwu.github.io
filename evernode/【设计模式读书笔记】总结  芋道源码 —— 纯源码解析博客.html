<html>
<head>
  <title>【设计模式读书笔记】总结 | 芋道源码 —— 纯源码解析博客</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="10110"/>
<h1>【设计模式读书笔记】总结 | 芋道源码 —— 纯源码解析博客</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2018/5/28 0:45</i></td></tr>
<tr><td><b>标签：</b></td><td><i>微信</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/"><i>http://www.iocoder.cn/DesignPattern/xiaomingge/summary/</i></a></td></tr>
</table>
</div>
<br/>

<div><span style="margin:0px;"><div style="color:#817c7c;margin:0;padding:0;outline:0;font-style:inherit;vertical-align:baseline;background:#ddd;font-size:100%;line-height:1.5;font-weight:inherit;border:0;-webkit-margin-before:0;-webkit-margin-after:0;font-family:&quot;微软雅黑&quot;"><div style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;width:95%;margin:0 auto;overflow:hidden"><div style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;margin:1em 0 0;line-height:1.8;background:#fafafa"><div style="-webkit-margin-before:0;-webkit-margin-after:0;margin:0;padding:0"><div style="margin:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;padding:1.5em 4%"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">摘要: 原创出处 <a href="http://cmsblogs.com/?p=457" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank">http://cmsblogs.com/?p=457</a> 「小明哥」欢迎转载，保留摘要，谢谢！</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">一、设计原则</a><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">1、单一职责原则</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">2、开闭原则（Open Close Principle）</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">3、里氏代换原则（Liskov Substitution Principle）</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">4、依赖倒转原则（Dependence Inversion Principle）</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">5、接口隔离原则（Interface Segregation Principle）</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">6、合成复用原则（Composite Reuse Principle）</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">7、迪米特法则（最少知道原则）（Demeter Principle）</a></li></ul></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">二、创建型模式</a><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">1、抽象工厂模式(Abstract Factory)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">2、建造者模式(Builder)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">3、工厂方法模式(Factory Method)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">4、原型模式(Prototype)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">5、单例模式(Singleton)</a></li></ul></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">三、结构型模式</a><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">1、适配器模式(Adapter)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">2、桥接模式(Bridge)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">3、组合模式(Composite)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">4、装饰者模式(Decorator)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">5、外观模式(Facade)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">6、享元模式(Flyweight)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">7、代理模式(Proxy)、</a></li></ul></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">四、行为型模式</a><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">1、职责链模式(Chain of Responsibility)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">2、命令模式(Command)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">3、解释器模式(Interpreter)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">4、迭代器模式(Iterator)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">5、中介者模式(Mediator)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">6、备忘录模式(Memento)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">7、观察者模式(Observer)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">8、状态模式(State)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">9、策略模式(Strategy)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">10、模板方法模式(Template Method)</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">11、访问者模式(Visitor)</a></li></ul></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">五、更多</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">六、最后</a></li></ul><hr style="-webkit-margin-before:0;-webkit-margin-after:0;border:1px solid #dbdbdb;margin:0;padding:0"/><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/wechat_mp_2017_07_31.jpg" type="image/jpeg" data-filename="wechat_mp_2017_07_31.jpg" alt="" style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></p><blockquote style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;border-left:.2em solid #2e68aa;margin:.65em 0 .65em 4%;padding-left:1%;line-height:1.5;font-size:110%"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">???关注<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">微信公众号：【芋道源码】</strong>有福利： </p><ol style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style-type:decimal;margin:.5em 0">RocketMQ / MyCAT / Sharding-JDBC <strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">所有</strong>源码分析文章列表 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style-type:decimal;margin:.5em 0">RocketMQ / MyCAT / Sharding-JDBC <strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">中文注释源码 GitHub 地址</strong></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style-type:decimal;margin:.5em 0">您对于源码的疑问每条留言<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">都</strong>将得到<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">认真</strong>回复。<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">甚至不知道如何读源码也可以请教噢</strong>。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style-type:decimal;margin:.5em 0"><strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">新的</strong>源码解析文章<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">实时</strong>收到通知。<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">每周更新一篇左右</strong>。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style-type:decimal;margin:.5em 0"><strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">认真的</strong>源码交流微信群。</li></ol></blockquote><hr style="-webkit-margin-before:0;-webkit-margin-after:0;border:1px solid #dbdbdb;margin:0;padding:0"/><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">从七月份开始一直到九月底才看完设计模式，在这个过程中我不敢说我已经掌握了那本书里面的内容，或者说1/5，没能力说也没有资格说。但是结果不重要，重要的是这个过程我的收获！主要包括如下几个方面：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">1、认识了这么多设计模式。刚刚接触java没多久就在学长那里听过设计模式的大名，但是由于能力有限，一直不敢触碰。而今有幸将其都认识了。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">2、开始有设计的理论了。在接触设计模式之前没有怎么想过设计方面东东，看到问题就立马动手解决，没有想到怎么样来设计更好，如何来是这块更加优化、漂亮。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">3、开始考虑系统的可扩展性了。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">4、在遇到问题后开始想有那个设计模式会适用这个场景。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">5、对面向对象有了更深一步的了解。</p></li></ul><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">鄙人天资不聪慧，既不是聪明人，更不是那种天才，所有顿悟有限！！！闲话过多，先看如下两幅图片</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"> 设计模式之间的关系：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/57a92d42-4d84-3aa9-a8b9-63a0b02c2c36.jpg" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/57a92d42-4d84-3aa9-a8b9-63a0b02c2c36_thumb.jpg" type="image/jpeg" data-filename="57a92d42-4d84-3aa9-a8b9-63a0b02c2c36_thumb.jpg" alt="57a92d42-4d84-3aa9-a8b9-63a0b02c2c36" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">设计模式总概况：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/b65972595d6b.jpg" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb.jpg" type="image/jpeg" data-filename="thumb.jpg" alt="设计模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">一、设计原则</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#1、单一职责原则" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="1、单一职责原则"></a>1、单一职责原则</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离。from：百度百科</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#2、开闭原则（Open-Close-Principle）" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="2、开闭原则（Open Close Principle）"></a>2、开闭原则（Open Close Principle）</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">开闭原则就是说<strong style="margin:0;padding:0;border:0;outline:0;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-weight:700">对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#3、里氏代换原则（Liskov-Substitution-Principle）" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="3、里氏代换原则（Liskov Substitution Principle）"></a>3、里氏代换原则（Liskov Substitution Principle）</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。from：百度百科</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#4、依赖倒转原则（Dependence-Inversion-Principle）" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="4、依赖倒转原则（Dependence Inversion Principle）"></a>4、依赖倒转原则（Dependence Inversion Principle）</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。 from：百度百科</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#5、接口隔离原则（Interface-Segregation-Principle）" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="5、接口隔离原则（Interface Segregation Principle）"></a>5、接口隔离原则（Interface Segregation Principle）</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#6、合成复用原则（Composite-Reuse-Principle）" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="6、合成复用原则（Composite Reuse Principle）"></a>6、合成复用原则（Composite Reuse Principle）</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#7、迪米特法则（最少知道原则）（Demeter-Principle）" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="7、迪米特法则（最少知道原则）（Demeter Principle）"></a>7、迪米特法则（最少知道原则）（Demeter Principle）</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">二、创建型模式</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#1、抽象工厂模式-Abstract-Factory" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="1、抽象工厂模式(Abstract Factory)"></a>1、抽象工厂模式(Abstract Factory)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所谓抽象工厂模式就是她提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类。其UML结构图如下：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/jpeg.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/jpeg_thumb.png" type="image/png" data-filename="jpeg_thumb.png" alt="抽象工厂模式.jpeg" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">AbstractFactory：抽象工厂。抽象工厂定义了一个接口，所有的具体工厂都必须实现此接口，这个接口包含了一组方法用来生产产品。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteFactory：具体工厂。具体工厂是用于生产不同产品族。要创建一个产品，客户只需要使用其中一个工厂完全不需要实例化任何产品对象。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">AbstractProduct：抽象产品。这是一个产品家族，每一个具体工厂都能够生产一整组产品。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Product：具体产品。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#2、建造者模式-Builder" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="2、建造者模式(Builder)"></a>2、建造者模式(Builder)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">对于建造者模式而已，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点大的两个产品并不是很多，所以它的使用范围有限。其UML结构图：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/91243fe327f1.jpg" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb1.jpg" type="image/jpeg" data-filename="thumb1.jpg" alt="建造者模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a> 参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Builder：抽象建造者。它声明为创建一个Product对象的各个部件指定的抽象接口。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteBuilder：具体建造者。实现抽象接口，构建和装配各个部件。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Director：指挥者。构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象，它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Product：产品角色。一个具体的产品对象。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#3、工厂方法模式-Factory-Method" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="3、工厂方法模式(Factory Method)"></a>3、工厂方法模式(Factory Method)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。其UML结构图：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/cfbd5b754c5a.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb.png" type="image/png" data-filename="thumb.png" alt="工厂方法模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Product：抽象产品。所有的产品必须实现这个共同的接口，这样一来，使用这些产品的类既可以引用这个接口。而不是具体类 。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteProduct：具体产品。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Creator：抽象工厂。它实现了所有操纵产品的方法，但不实现工厂方法。Creator所有的子类都必须要实现factoryMethod()方法。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteCreator：具体工厂。制造产品的实际工厂。它负责创建一个或者多个具体产品，只有ConcreteCreator类知道如何创建这些产品。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#4、原型模式-Prototype" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="4、原型模式(Prototype)"></a>4、原型模式(Prototype)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">它主要应用与那些创建新对象的成本过大时。它的主要优点就是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构。UML结构图：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/f607e4eb1fef.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb1.png" type="image/png" data-filename="thumb1.png" alt="原型模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Prototype：抽象原型类。声明克隆自身的接口。</li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcretePrototype：具体原型类。实现克隆的具体操作。</li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Client：客户类。让一个原型克隆自身，从而获得一个新的对象。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#5、单例模式-Singleton" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="5、单例模式(Singleton)"></a>5、单例模式(Singleton)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">单例模式，从字面上看就是一个实例的意思。所以它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">单例模式具备如下几个特点：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">1、只有一个实例。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">2、能够自我实例化。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">3、提供全局访问点。</p></li></ul><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所以说当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。其UML结构图非常简单，就只有一个类：</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/9335c8e9a591.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb2.png" type="image/png" data-filename="thumb2.png" alt="单例模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Singleton：单例。</li></ul><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">三、结构型模式</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">结构型模式主要是用于处理类或者对象的组合，它描述了如何来类或者对象更好的组合起来，是从程序的结构上来解决模块之间的耦合问题。它主要包括适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式这个七个模式。</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#1、适配器模式-Adapter" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="1、适配器模式(Adapter)"></a>1、适配器模式(Adapter)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/7971fb6846a8.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb3.png" type="image/png" data-filename="thumb3.png" alt="适配器模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Target：目标抽象类 。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Adapter：适配器类 。通过在内部包装一个Adaptee，将源接口转成目标接口。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Adaptee：适配者类 。需要适配的类。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Client：客户类。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#2、桥接模式-Bridge" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="2、桥接模式(Bridge)"></a>2、桥接模式(Bridge)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是讲这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离过程就使用了桥接模式。所谓桥接模式就是讲抽象部分和实现部分隔离开来，使得他们能够独立变化。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/cd272a088ad4.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb4.png" type="image/png" data-filename="thumb4.png" alt="桥接模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Abstraction：抽象类。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">RefinedAbstraction：扩充抽象类。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Implementor：实现类接口。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteImplementor：具体实现类 。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#3、组合模式-Composite" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="3、组合模式(Composite)"></a>3、组合模式(Composite)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。它定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">虽然组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象，如果系统的业务规则比较复杂的话，使用组合模式就有一定的挑战了。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/003040198ddf.jpg" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb2.jpg" type="image/jpeg" data-filename="thumb2.jpg" alt="组合模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Component ：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Leaf：叶子对象。叶子结点没有子结点。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Composite：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#4、装饰者模式-Decorator" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="4、装饰者模式(Decorator)"></a>4、装饰者模式(Decorator)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。在这里我们可以通过使用装饰者模式来解决这个问题。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/92de9a2de934.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb5.png" type="image/png" data-filename="thumb5.png" alt="装饰者模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Component: 抽象构件。是定义一个对象接口，可以给这些对象动态地添加职责。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteComponent:具体构件。是定义了一个具体的对象，也可以给这个对象添加一些职责。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Decorator: 抽象装饰类。是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteDecorator:具体装饰类，起到给Component添加职责的功能。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#5、外观模式-Facade" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="5、外观模式(Facade)"></a>5、外观模式(Facade)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">我们都知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。外观模式非常好的诠释了这段话。外观模式提供了一个统一的接口，用来访问子系统中的一群接口。它让一个应用程序中子系统间的相互依赖关系减少到了最少，它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">通过使用外观模式，使得客户对子系统的引用变得简单了，实现了客户与子系统之间的松耦合。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/0e762b8a579b.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb6.png" type="image/png" data-filename="thumb6.png" alt="外观模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Facade: 外观角色。知道哪些子系统类负责处理请求，将客户的请求代理给适合的子系统处理。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">SubSystem:子系统角色。实现子系统功能，处理Facade对象发来的请求。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#6、享元模式-Flyweight" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="6、享元模式(Flyweight)"></a>6、享元模式(Flyweight)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在一个系统中对象会使得内存占用过多，特别是那些大量重复的对象，这就是对系统资源的极大浪费。享元模式对对象的重用提供了一种解决方案，它使用共享技术对相同或者相似对象实现重用。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。这里有一点要注意：享元模式要求能够共享的对象必须是细粒度对象。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">享元模式通过共享技术使得系统中的对象个数大大减少了，同时享元模式使用了内部状态和外部状态，同时外部状态相对独立，不会影响到内部状态，所以享元模式能够使得享元对象在不同的环境下被共享。同时正是分为了内部状态和外部状态，享元模式会使得系统变得更加复杂，同时也会导致读取外部状态所消耗的时间过长。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/a5d1092ddbef.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb7.png" type="image/png" data-filename="thumb7.png" alt="享元模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Flyweight: 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，Flyweight可以接受并作用于外部专题。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteFlyweight: 具体享元类。指定内部状态，为内部状态增加存储空间。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">UnsharedConcreteFlyweight: 非共享具体享元类。指出那些不需要共享的Flyweight子类。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">FlyweightFactory: 享元工厂类。用来创建并管理Flyweight对象，它主要用来确保合理地共享Flyweight，当用户请求一个Flyweight时，FlyweightFactory就会提供一个已经创建的Flyweight对象或者新建一个（如果不存在）。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#7、代理模式-Proxy-、" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="7、代理模式(Proxy)、"></a>7、代理模式(Proxy)、</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/beab0265e520.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb8.png" type="image/png" data-filename="thumb8.png" alt="代理模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Subject: 抽象角色。声明真实对象和代理对象的共同接口。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Proxy: 代理角色。代理对象与真实对象实现相同的接口，所以它能够在任何时刻都能够代理真实对象。代理角色内部包含有对真实对象的引用，所以她可以操作真实对象，同时也可以附加其他的操作，相当于对真实对象进行封装。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">RealSubject: 真实角色。它代表着真实对象，是我们最终要引用的对象。</p></li></ul><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">四、行为型模式</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">行为型模式主要是用于描述类或者对象是怎样交互和怎样分配职责的。它涉及到算法和对象间的职责分配，不仅描述对象或者类的模式，还描述了他们之间的通信方式，它将你的注意力从控制流转移到了对象间的关系上来。行为型类模式采用继承机制在类间分派行为，而行为型对象模式使用对象复合而不是继承。它主要包括如何11中设计模式：职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#1、职责链模式-Chain-of-Responsibility" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="1、职责链模式(Chain of Responsibility)"></a>1、职责链模式(Chain of Responsibility)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"> 职责链模式描述的请求如何沿着对象所组成的链来传递的。它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，这就是职责链模式。在职责链模式中，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。但是在职责链中我们不能保证所有的请求都能够被处理，而且不利于观察运行时特征。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/thumb9.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb_thumb.png" type="image/png" data-filename="thumb_thumb.png" alt="职责链模式_thumb" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Handler: 抽象处理者。定义了一个处理请求的方法。所有的处理者都必须实现该抽象类。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteHandler: 具体处理者。处理它所负责的请求，同时也可以访问它的后继者。如果它能够处理该请求则处理，否则将请求传递到它的后继者。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Client: 客户类。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#2、命令模式-Command" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="2、命令模式(Command)"></a>2、命令模式(Command)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">有些时候我们想某个对象发送一个请求，但是我们并不知道该请求的具体接收者是谁，具体的处理过程是如何的，们只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式。所以命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支持可撤销的操作。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">命令模式可以将请求的发送者和接收者之间实现完全的解耦，发送者和接收者之间没有直接的联系，发送者只需要知道如何发送请求命令即可，其余的可以一概不管，甚至命令是否成功都无需关心。同时我们可以非常方便的增加新的命令，但是可能就是因为方便和对请求的封装就会导致系统中会存在过多的具体命令类。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/thumb10.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb_thumb1.png" type="image/png" data-filename="thumb_thumb1.png" alt="命令模式_thumb" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a> 参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Command: 抽象命令类。用来声明执行操作的接口。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteCommand: 具体命令类。将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Excute。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Invoker: 调用者。要求该命令执行这个请求。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Receiver: 接收者。知道如何实施与执行一个请求相关的操作，任何类都有可能成为一个接收者。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Client:客户类。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#3、解释器模式-Interpreter" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="3、解释器模式(Interpreter)"></a>3、解释器模式(Interpreter)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"> 所谓解释器模式就是定义语言的文法，并且建立一个解释器来解释该语言中的句子。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。它描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/thumb31.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb3_thumb.png" type="image/png" data-filename="thumb3_thumb.png" alt="解释器模式_thumb[3\]" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">AbstractExpression: 抽象表达式。声明一个抽象的解释操作，该接口为抽象语法树中所有的节点共享。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">TerminalExpression: 终结符表达式。实现与文法中的终结符相关的解释操作。实现抽象表达式中所要求的方法。文法中每一个终结符都有一个具体的终结表达式与之相对应。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">NonterminalExpression: 非终结符表达式。为文法中的非终结符相关的解释操作。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Context: 环境类。包含解释器之外的一些全局信息。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Client: 客户类。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#4、迭代器模式-Iterator" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="4、迭代器模式(Iterator)"></a>4、迭代器模式(Iterator)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"> ​ 对于迭代在编程过程中我们经常用到，能够游走于聚合内的每一个元素，同时还可以提供多种不同的遍历方式，这就是迭代器模式的设计动机。在我们实际的开发过程中，我们可能会需要根据不同的需求以不同的方式来遍历整个对象，但是我们又不希望在聚合对象的抽象接口中充斥着各种不同的遍历操作，于是我们就希望有某个东西能够以多种不同的方式来遍历一个聚合对象，这时迭代器模式出现了。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">何为迭代器模式？所谓迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。迭代器模式是将迭代元素的责任交给迭代器，而不是聚合对象，我们甚至在不需要知道该聚合对象的内部结构就可以实现该聚合对象的迭代。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">通过迭代器模式，使得聚合对象的结构更加简单，它不需要关注它元素的遍历，只需要专注它应该专注的事情，这样就更加符合单一职责原则了。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/thumb11.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb_thumb2.png" type="image/png" data-filename="thumb_thumb2.png" alt="迭代器模式_thumb" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a><br style="-webkit-margin-before:0;-webkit-margin-after:0;margin:0;padding:0"/> 参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Iterator: 抽象迭代器：所有迭代器都需要实现的接口，提供了游走聚合对象元素之间的方法。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteIterator: 具体迭代器。利用这个具体的迭代器能够对具体的聚合对象进行遍历。每一个聚合对象都应该对应一个具体的迭代器。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Aggregate: 抽象聚合类。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteAggregate: 具体聚合类。实现creatorIterator()方法，返回该聚合对象的迭代器。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#5、中介者模式-Mediator" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="5、中介者模式(Mediator)"></a>5、中介者模式(Mediator)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">租房各位都有过的经历吧！在这个过程中中介结构扮演着很重要的角色，它在这里起到一个中间者的作用，给我们和房主互相传递信息。在外面软件的世界里同样需要这样一个中间者。在我们的系统中有时候会存在着对象与对象之间存在着很强、复杂的关联关系，如果让他们之间有直接的联系的话，必定会导致整个系统变得非常复杂，而且可扩展性很差！在前面我们就知道如果两个类之间没有不必彼此通信，我们就不应该让他们有直接的关联关系，如果实在是需要通信的话，我们可以通过第三者来转发他们的请求。同样，这里我们利用中介者来解决这个问题。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所谓中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。在中介者模式中，中介对象用来封装对象之间的关系，各个对象可以不需要知道具体的信息通过中介者对象就可以实现相互通信。它减少了对象之间的互相关系，提供了系统可复用性，简化了系统的结构。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在中介者模式中，各个对象不需要互相知道了解，他们只需要知道中介者对象即可，但是中介者对象就必须要知道所有的对象和他们之间的关联关系，正是因为这样就导致了中介者对象的结构过于复杂，承担了过多的职责，同时它也是整个系统的核心所在，它有问题将会导致整个系统的问题。所以如果在系统的设计过程中如果出现“多对多”的复杂关系群时，千万别急着使用中介者模式，而是要仔细思考是不是您设计的系统存在问题。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/thumb21.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb2_thumb.png" type="image/png" data-filename="thumb2_thumb.png" alt="中介者模式_thumb[2\]" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Mediator: 抽象中介者。定义了同事对象到中介者对象之间的接口。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteMediator: 具体中介者。实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Colleague: 抽象同事类。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteColleague: 具体同事类。每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#6、备忘录模式-Memento" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="6、备忘录模式(Memento)"></a>6、备忘录模式(Memento)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"> ​ 后悔药人人都想要，但是事实却是残酷的，根本就没有后悔药可买，但是也不仅如此，在软件的世界里就有后悔药！备忘录模式就是一种后悔药，它给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它实现了对信息的封装，使得客户不需要关心状态保存的细节。保存就要消耗资源，所以备忘录模式的缺点就在于消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/3e3b7950f26b.jpg" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb3.jpg" type="image/jpeg" data-filename="thumb3.jpg" alt="备忘录模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Originator: 原发器。负责创建一个备忘录，用以记录当前对象的内部状态，通过也可以使用它来利用备忘录恢复内部状态。同时原发器还可以根据需要决定Memento存储Originator的那些内部状态。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Memento: 备忘录。用于存储Originator的内部状态，并且可以防止Originator以外的对象访问Memento。在备忘录Memento中有两个接口，其中Caretaker只能看到备忘录中的窄接口，它只能将备忘录传递给其他对象。Originator可以看到宽接口，允许它访问返回到先前状态的所有数据。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Caretaker: 负责人。负责保存好备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#7、观察者模式-Observer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="7、观察者模式(Observer)"></a>7、观察者模式(Observer)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/8c0e6bf0d53f.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb12.png" type="image/png" data-filename="thumb12.png" alt="观察者模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Subject：目标。他把所有对观察者对戏的引用保存在一个聚集里，每一个主题都可以有多个观察者。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">Observer：观察者。为所有的具体观察者定义一个接口，在得到主题的通知时能够及时的更新自己。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteSubject：具体主题。将有关状态存入具体观察者对象。在具体主题发生改变时，给所有的观察者发出通知。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteObserver：具体观察者。实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态相协调。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#8、状态模式-State" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="8、状态模式(State)"></a>8、状态模式(State)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在很多情况下我们对象的行为依赖于它的一个或者多个变化的属性，这些可变的属性我们称之为状态，也就是说行为依赖状态，即当该对象因为在外部的互动而导致他的状态发生变化，从而它的行为也会做出相应的变化。对于这种情况，我们是不能用行为来控制状态的变化，而应该站在状态的角度来思考行为，即是什么状态就要做出什么样的行为。这个就是状态模式。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所以状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在状态模式中我们可以减少大块的if…else语句，它是允许态转换逻辑与状态对象合成一体，但是减少if…else语句的代价就是会换来大量的类，所以状态模式势必会增加系统中类或者对象的个数。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">同时状态模式是将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。但是这样就会导致系统的结构和实现都会比较复杂，如果使用不当就会导致程序的结构和代码混乱，不利于维护。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/f598782f541f.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb13.png" type="image/png" data-filename="thumb13.png" alt="状态模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Context：环境类。可以包括一些内部状态。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">State： 抽象状态类。State定义了一个所有具体状态的共同接口，任何状态都实现这个相同的接口，这样一来，状态之间就可以互相转换了。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteState：具体状态类。具体状态类，用于处理来自Context的请求，每一个ConcreteState都提供了它对自己请求的实现，所以，当Context改变状态时行为也会跟着改变。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#9、策略模式-Strategy" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="9、策略模式(Strategy)"></a>9、策略模式(Strategy)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">我们知道一件事可能会有很多种方式来实现它，但是其中总有一种最高效的方式，在软件开发的世界里面同样如此，我们也有很多中方法来实现一个功能，但是我们需要一种简单、高效的方式来实现它，使得系统能够非常灵活，这就是策略模式。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所以策略模式就是定义了算法族，分别封装起来，让他们之前可以互相转换，此模式然该算法的变化独立于使用算法的客户。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">在策略模式中它将这些解决问题的方法定义成一个算法群，每一个方法都对应着一个具体的算法，这里的一个算法我就称之为一个策略。虽然策略模式定义了算法，但是它并不提供算法的选择，即什么算法对于什么问题最合适这是策略模式所不关心的，所以对于策略的选择还是要客户端来做。客户必须要清楚的知道每个算法之间的区别和在什么时候什么地方使用什么策略是最合适的，这样就增加客户端的负担。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">同时策略模式也非常完美的符合了“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。但是一个策略对应一个类将会是系统产生很多的策略类。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/262e1c44a9d8.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb14.png" type="image/png" data-filename="thumb14.png" alt="策略模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Context: 环境类。维护一个Strategy对象的引用，用一个ConcreteStrategy来配置，可定义一个接口来让Strategy访问它的数据。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Strategy: 抽象策略类。定义所有支持算法的公共接口。Context使用这个接口来调用某个Concretestrategy定义的算法。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteStrategy: 具体策略类。封装了具体的算法实现。</li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#10、模板方法模式-Template-Method" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="10、模板方法模式(Template Method)"></a>10、模板方法模式(Template Method)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">有些时候我们做某几件事情的步骤都差不多，仅有那么一小点的不同，在软件开发的世界里同样如此，如果我们都将这些步骤都一一做的话，费时费力不讨好。所以我们可以将这些步骤分解、封装起来，然后利用继承的方式来继承即可，当然不同的可以自己重写实现嘛！这就是模板方法模式提供的解决方案。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。也就是说我们需要声明一个抽象的父类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法让子类来实现剩余的逻辑，不同的子类可以以不同的方式来实现这些逻辑。所以模板方法的模板其实就是一个普通的方法，只不过这个方法是将算法实现的步骤封装起来的。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/64993a1431b7.png" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb15.png" type="image/png" data-filename="thumb15.png" alt="模板方法模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">AbstractClass: 抽象类。实现了一个模板，实现算法的基本骨架，具体子类将重定义primitiveOperation()方法以实现一个算法步骤。</p></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">ConcreteClass: 具体子类。实现primitiveOperation()方法以完成算法中与特定子类相关的步骤。</p></li></ul><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#11、访问者模式-Visitor" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="11、访问者模式(Visitor)"></a>11、访问者模式(Visitor)</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">访问者模式俗称23大设计模式中最难的一个。除了结构复杂外，理解也比较难。在我们软件开发中我们可能会对同一个对象有不同的处理，如果我们都做分别的处理，将会产生灾难性的错误。对于这种问题，访问者模式提供了比较好的解决方案。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"> ​ 访问者模式即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式。同时我们还需要明确一点那就是访问者模式是适用于那些数据结构比较稳定的，因为他是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><a href="http://cmsblogs.com/wp-content/uploads/2014/02/dfb3d7b8756e.jpg" rel="external nofollow noopener noreferrer" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" target="_blank"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/thumb4.jpg" type="image/jpeg" data-filename="thumb4.jpg" alt="访问者模式" style="padding:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;border:0;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></a></p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">参与者：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Vistor: 抽象访问者。为该对象结构中的ConcreteElement的每一个类声明的一个操作。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteVisitor: 具体访问者。实现Visitor申明的每一个操作，每一个操作实现算法的一部分。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">Element: 抽象元素。定义一个Accept操作，它以一个访问者为参数。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ConcreteElement: 具体元素 。实现Accept操作。 </li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0">ObjectStructure: 对象结构。能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。</li></ul><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">五、更多</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">上面只是对各个设计模式的一个简单的总结，下面我将列出详情，各位看客有兴趣的可以点点：</p><ul style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;list-style:none;-webkit-margin-before:0;-webkit-margin-after:0;padding-left:2em;font-size:105%"><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】总结》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Simple-Factory-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】简单工厂模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Factory-Method" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】工厂方法模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Abstract-Factory-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】抽象工厂》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Builder-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】建造者模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Prototype-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】原型模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Singleton-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】单例模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Adapter-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】适配器模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Bridge-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】桥接模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Composite-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】组合模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Decorator-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】装饰者模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Facade-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】外观模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Flyweight-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】享元模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Proxy-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】代理模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Chain-of-Responsibility" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】职责链模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Command-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】命令模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Interpreter-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】解释器模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Iterator-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】迭代器模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Mediator-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】中介者模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Memento-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】备忘录模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Observer-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】观察者模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/State-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】状态模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Strategy-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】策略模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Template-Method" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】模板方法模式》</a></li><li style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;list-style:disc;text-align:match-parent;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/Visitor-Pattern" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb">《【设计模式读书笔记】访问者模式》</a></li></ul><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">六、最后</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">感谢Eric Freeman , Elisabeth Freeman , Kathy Sierra &amp; Bert Bates所编写的《Head First design patterns》，正是这本书将我领入设计模式的大门，虽然只是刚刚跨过门槛，但早已陶醉于那浓浓的、醇正的知识香中。还要感谢刘伟老师的PPT，您的教程给了我一个很好的参考。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">虽然看完了设计模式，但这并不是结束，而是刚刚开始，在以后的项目过程中，我会尽量去优化，思考。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">诚然，最近在做项目的过程中深感基础不够扎实，所以下一步就是java基础了：think in java ,I must conquer you!!!!</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">博文有点儿长，感谢各位看客能够看完，如果觉得不错，请推荐个吧！！！！</p><h1 style="outline:0;font-style:inherit;vertical-align:baseline;border:0;font-weight:inherit;font-family:inherit;-webkit-margin-before:0;-webkit-margin-after:0;font-size:180%;line-height:1.2em;color:#333;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:.3em 0;margin:.5em 0"><a href="http://www.iocoder.cn/DesignPattern/xiaomingge/summary/#666-彩蛋" style="margin:0;padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;text-decoration:none;color:#2ca6cb" title="666. 彩蛋"></a>666. 彩蛋</h1><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0">如果你对 设计模式 感兴趣，欢迎加入我的知识一起交流。</p><p style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;vertical-align:baseline;-webkit-margin-before:0;-webkit-margin-after:0;font-size:105%;line-height:1.7;margin:.7em 0"><img src="【设计模式读书笔记】总结  芋道源码 —— 纯源码解析博客_files/01.png" type="image/png" data-filename="01.png" alt="知识星球" style="padding:0;border:0;outline:0;font-weight:inherit;font-style:inherit;font-family:inherit;font-size:100%;-webkit-margin-before:0;-webkit-margin-after:0;max-width:100%;display:block;margin:auto;height:auto;vertical-align:middle;padding-top:.5em"/></p></div></div></div></div></div></span>
</div></body></html> 