<html>
<head>
  <title>JAVA正则表达式 Pattern和Matcher - 山岭巨人 - 博客园</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="7656"/>
<h1>JAVA正则表达式 Pattern和Matcher - 山岭巨人 - 博客园</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2015/10/6 16:12</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://www.cnblogs.com/playing/archive/2011/03/15/1984943.html"><i>http://www.cnblogs.com/playing/archive/2011/03/15/1984943.html</i></a></td></tr>
</table>
</div>
<br/>

<div><span><br/><div style="font-size: 16px"><div><div style="font-family:Verdana, Geneva, Arial, Helvetica, sans-serif;font-size:12px;"><div style="background-color:rgb(255, 255, 255);"><div><div><div style="font-size:13px;line-height:1.5;"><div style="word-break:break-word;"><p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;color:#ff0000;">java.util.regex</span>是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;font-size:14pt;"><strong>1.简介： </strong></span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。 <br/>它包括两个类：Pattern和Matcher 。</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">Pattern： 一个Pattern是一个正则表达式经编译后的表现模式。 </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">Matcher： 一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。 </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">以下我们就分别来看看这两个类：</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;font-size:14pt;"><strong>2.Pattern类:</strong> </span><br/>Pattern的方法如下：</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">static Pattern compile(String regex) <br/>  将给定的正则表达式编译并赋予给Pattern类 <br/>static Pattern compile(String regex, int flags) <br/>  同上，但增加flag参数的指定，可选的flag参数包括：CASE INSENSITIVE,MULTILINE,DOTALL,UNICODE CASE， CANON EQ <br/>int flags() <br/>  返回当前Pattern的匹配flag参数. <br/>Matcher matcher(CharSequence input) <br/>  生成一个给定命名的Matcher对象 <br/>static boolean matches(String regex, CharSequence input) <br/>  编译给定的正则表达式并且对输入的字串以该正则表达式为模开展匹配,该方法适合于该正则表达式只会使用一次的情况，也就是只进行一次匹配工作，因为这种情况下并不需要生   成一个Matcher实例。 <br/>String pattern() <br/>  返回该Patter对象所编译的正则表达式。 <br/>String[] split(CharSequence input) <br/>  将目标字符串按照Pattern里所包含的正则表达式为模进行分割。 <br/>String[] split(CharSequence input, int limit) <br/>  作用同上，增加参数limit目的在于要指定分割的段数，如将limi设为2，那么目标字符串将根据正则表达式分为割为两段。 </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;">一个正则表达式，也就是一串有特定意义的字符，必须首先要编译成为一个Pattern类的实例，这个Pattern对象将会使用matcher()方法来生成一个Matcher实例，接着便可以使用该 Matcher实例以编译的正则表达式为基础对目标字符串进行匹配工作，多个Matcher是可以共用一个Pattern对象的。</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;color:#ff0000;">现在我们先来看一个简单的例子，再通过分析它来了解怎样生成一个Pattern对象并且编译一个正则表达式，最后根据这个正则表达式将目标字符串进行分割：</span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;color:#ff0000;">import java.util.regex.*; </span><br/><span style="line-height:1.5;color:#ff0000;">public class Replacement{ </span><br/><span style="line-height:1.5;color:#ff0000;">public static void main(String[] args) throws Exception { </span><br/><span style="line-height:1.5;color:#ff0000;">// 生成一个Pattern,同时编译一个正则表达式 </span><br/><span style="line-height:1.5;color:#ff0000;">Pattern p = Pattern.compile(&quot;[/]+&quot;); </span><br/><span style="line-height:1.5;color:#ff0000;">//用Pattern的split()方法把字符串按&quot;/&quot;分割 </span><br/><span style="line-height:1.5;color:#ff0000;">String[] result = p.split( </span><br/><span style="line-height:1.5;color:#ff0000;">&quot;Kevin has seen《LEON》seveal times,because it is a good film.&quot; </span><br/><span style="line-height:1.5;color:#ff0000;">+&quot;/ 凯文已经看过《这个杀手不太冷》几次了，因为它是一部&quot; </span><br/><span style="line-height:1.5;color:#ff0000;">+&quot;好电影。/名词:凯文。&quot;); </span><br/><span style="line-height:1.5;color:#ff0000;">for (int i=0; i&lt;result.length; i++) </span><br/><span style="line-height:1.5;color:#ff0000;">System.out.println(result[i]); </span><br/><span style="line-height:1.5;color:#ff0000;">} </span><br/><span style="line-height:1.5;color:#ff0000;">} </span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;color:#ff0000;">输出结果为： </span><br/><span style="line-height:1.5;color:#ff0000;">Kevin has seen《LEON》seveal times,because it is a good film. </span><br/><span style="line-height:1.5;color:#ff0000;">凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。 </span><br/><span style="line-height:1.5;color:#ff0000;">名词:凯文。</span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;color:#000000;">很明显，该程序将字符串按&quot;/&quot;进行了分段。</span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;color:#000000;"> </span><span style="line-height:1.5;color:#ff0000;">我们以下再使用 split(CharSequence input, int limit)方法来指定分段的段数，程序改动为： <br/>tring[] result = p.split(&quot;Kevin has seen《LEON》seveal times,because it is a good film./ 凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。/名词:凯文。&quot;，2); <br/>这里面的参数&quot;2&quot;表明将目标语句分为两段。 <br/>输出结果则为： <br/>Kevin has seen《LEON》seveal times,because it is a good film. <br/>凯文已经看过《这个杀手不太冷》几次了，因为它是一部好电影。/名词:凯文。</span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;font-size:14pt;"><strong>3.Matcher类: </strong></span><br/>Matcher方法如下： Matcher appendReplacement(StringBuffer sb, String replacement) <br/>将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里。 <br/>StringBuffer appendTail(StringBuffer sb) <br/>  将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里。 <br/>int end() <br/>  返回当前匹配的子串的最后一个字符在原目标字符串中的索引位置 。 <br/>int end(int group) <br/>  返回与匹配模式里指定的组相匹配的子串最后一个字符的位置。 <br/>boolean find() <br/>  尝试在目标字符串里查找下一个匹配子串。 <br/>boolean find(int start) <br/>  重设Matcher对象，并且尝试在目标字符串里从指定的位置开始查找下一个匹配的子串。 <br/>String group() <br/>  返回当前查找而获得的与组匹配的所有子串内容 <br/>String group(int group) <br/>  返回当前查找而获得的与指定的组匹配的子串内容 <br/>int groupCount() <br/>  返回当前查找所获得的匹配组的数量。 <br/>boolean lookingAt() <br/>  检测目标字符串是否以匹配的子串起始。 <br/>boolean matches() <br/>  尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值。 <br/>Pattern pattern() <br/>  返回该Matcher对象的现有匹配模式，也就是对应的Pattern 对象。 <br/>String replaceAll(String replacement) <br/>  将目标字符串里与既有模式相匹配的子串全部替换为指定的字符串。 <br/>String replaceFirst(String replacement) <br/>  将目标字符串里第一个与既有模式相匹配的子串替换为指定的字符串。 <br/>Matcher reset() <br/>  重设该Matcher对象。 <br/>Matcher reset(CharSequence input) <br/>  重设该Matcher对象并且指定一个新的目标字符串。 <br/>int start() <br/>  返回当前查找所获子串的开始字符在原目标字符串中的位置。 <br/>int start(int group) <br/>  返回当前查找所获得的和指定组匹配的子串的第一个字符在原目标字符串中的位置。 <br/>（光看方法的解释是不是很不好理解？不要急，待会结合例子就比较容易明白了） </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><br/>一个Matcher实例是被用来对目标字符串进行基于既有模式（也就是一个给定的Pattern所编译的正则表达式）进行匹配查找的，所有往Matcher的输入都是通过CharSequence接口提供的，这样做的目的在于可以支持对从多元化的数据源所提供的数据进行匹配工作。 <br/>我们分别来看看各方法的使用： <br/>★matches()/lookingAt ()/find()： <br/>一个Matcher对象是由一个Pattern对象调用其matcher()方法而生成的，一旦该Matcher对象生成,它就可以进行三种不同的匹配查找操作： <br/>matches()方法尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值。 <br/>lookingAt ()方法将检测目标字符串是否以匹配的子串起始。 <br/>find()方法尝试在目标字符串里查找下一个匹配子串。 <br/>以上三个方法都将返回一个布尔值来表明成功与否。 <br/>★replaceAll ()/appendReplacement()/appendTail()： <br/>Matcher类同时提供了四个将匹配子串替换成指定字符串的方法： <br/>replaceAll() <br/>replaceFirst() <br/>appendReplacement() <br/>appendTail() <br/>replaceAll()与replaceFirst()的用法都比较简单，请看上面方法的解释。我们主要重点了解一下appendReplacement()和appendTail()方法。 <br/>appendReplacement(StringBuffer sb, String replacement) 将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个StringBuffer对象里，而appendTail(StringBuffer sb) 方法则将最后一次匹配工作后剩余的字符串添加到一个StringBuffer对象里。 <br/><span style="line-height:1.5;color:#ff0000;">例如，有字符串fatcatfatcatfat,假设既有正则表达式模式为&quot;cat&quot;，第一次匹配后调用appendReplacement(sb,&quot;dog&quot;),那么这时StringBuffer sb的内容为fatdog，也就是fatcat中的cat被替换为dog并且与匹配子串前的内容加到sb里，而第二次匹配后调用appendReplacement(sb,&quot;dog&quot;)，那么sb的内容就变为fatdogfatdog，如果最后再调用一次appendTail（sb）,那么sb最终的内容将是fatdogfatdogfat。</span> </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><strong>还是有点模糊？那么我们来看个简单的程序： </strong><br/><strong>//该例将把句子里的&quot;Kelvin&quot;改为&quot;Kevin&quot; </strong><br/><strong>import java.util.regex.*; </strong><br/><strong>public class MatcherTest{ </strong><br/><strong>public static void main(String[] args) throws Exception { </strong><br/><strong>//生成Pattern对象并且编译一个简单的正则表达式&quot;Kelvin&quot; </strong><br/><strong>Pattern p = Pattern.compile(&quot;Kevin&quot;); </strong><br/><strong>//用Pattern类的matcher()方法生成一个Matcher对象 </strong><br/><strong>Matcher m = p.matcher(&quot;Kelvin Li and Kelvin Chan are both working in Kelvin Chen's KelvinSoftShop company&quot;); </strong><br/><strong>StringBuffer sb = new StringBuffer(); </strong><br/><strong>int i=0; </strong><br/><strong>//使用find()方法查找第一个匹配的对象 </strong><br/><strong>boolean result = m.find(); </strong><br/><strong>//使用循环将句子里所有的kelvin找出并替换再将内容加到sb里 </strong><br/><strong>while(result) { </strong><br/><strong>i++; </strong><br/><strong>m.appendReplacement(sb, &quot;Kevin&quot;); </strong><br/><strong>System.out.println(&quot;第&quot;+i+&quot;次匹配后sb的内容是：&quot;+sb); </strong><br/><strong>//继续查找下一个匹配对象 </strong><br/><strong>result = m.find(); </strong><br/><strong>} </strong><br/><strong>//最后调用appendTail()方法将最后一次匹配后的剩余字符串加到sb里； </strong><br/><strong>m.appendTail(sb); </strong><br/><strong>System.out.println(&quot;调用m.appendTail(sb)后sb的最终内容是:&quot;+ sb.toString()); </strong><br/><strong>} </strong><br/><strong>} </strong><br/><strong>最终输出结果为： </strong><br/><strong>第1次匹配后sb的内容是：Kevin </strong><br/><strong>第2次匹配后sb的内容是：Kevin Li and Kevin </strong><br/><strong>第3次匹配后sb的内容是：Kevin Li and Kevin Chan are both working in Kevin </strong><br/><strong>第4次匹配后sb的内容是：Kevin Li and Kevin Chan are both working in Kevin Chen's Kevin </strong><br/><strong>调用m.appendTail(sb)后sb的最终内容是：Kevin Li and Kevin Chan are both working in Kevin Chen's KevinSoftShop company. </strong><br/><strong>看了上面这个例程是否对appendReplacement()，appendTail()两个方法的使用更清楚呢，如果还是不太肯定最好自己动手写几行代码测试一下。</strong> <br/>★group()/group(int group)/groupCount()： <br/>该系列方法与我们在上篇介绍的Jakarta-ORO中的MatchResult .group()方法类似(有关Jakarta-ORO请参考上篇的内容)，都是要返回与组匹配的子串内容，下面代码将很好解释其用法： <br/>import java.util.regex.*; <br/>public class GroupTest{ <br/>public static void main(String[] args) <br/>throws Exception { <br/>Pattern p = Pattern.compile(&quot;(ca)(t)&quot;); <br/>Matcher m = p.matcher(&quot;one cat,two cats in the yard&quot;); <br/>StringBuffer sb = new StringBuffer(); <br/>boolean result = m.find(); <br/>System.out.println(&quot;该次查找获得匹配组的数量为：&quot;+m.groupCount()); <br/>for(int i=1;i&lt;=m <br/>} <br/>} <br/>输出为： <br/>该次查找获得匹配组的数量为：2 <br/>第1组的子串内容为：ca <br/>第2组的子串内容为：t <br/>Matcher对象的其他方法因比较好理解且由于篇幅有限，请读者自己编程验证。 </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><br/><strong><span style="line-height:1.5;font-size:14pt;">4．一个检验Email地址的小程序： </span></strong><br/>最后我们来看一个检验Email地址的例程，该程序是用来检验一个输入的EMAIL地址里所包含的字符是否合法，虽然这不是一个完整的EMAIL地址检验程序，它不能检验所有可能出现的情况，但在必要时您可以在其基础上增加所需功能。 <br/>import java.util.regex.*; <br/>public class Email { <br/>public static void main(String[] args) throws Exception { <br/>String input = args[0]; <br/>//检测输入的EMAIL地址是否以 非法符号&quot;.&quot;或&quot;@&quot;作为起始字符 <br/>Pattern p = Pattern.compile(&quot;^.|^@&quot;); <br/>Matcher m = p.matcher(input); <br/>if (m <br/>//检测是否以&quot;www.&quot;为起始 <br/>p = Pattern.compile(&quot;^www.&quot;); <br/>m = p.matcher(input); <br/>if (m <br/>//检测是否包含非法字符 <br/>p = Pattern.compile(&quot;[^A-Za-z0-9.@_-~#]+&quot;); <br/>m = p.matcher(input); <br/>StringBuffer sb = new StringBuffer(); <br/>boolean result = m.find(); <br/>boolean deletedIllegalChars = false; <br/>while(result) { <br/>//如果找到了非法字符那么就设下标记 <br/>deletedIllegalChars = true; <br/>//如果里面包含非法字符如冒号双引号等，那么就把他们消去，加到SB里面 <br/>m.appendReplacement(sb, &quot;&quot;); <br/>result = m.find(); <br/>} <br/>m.appendTail(sb); <br/>input = sb.toString(); <br/>if (deletedIllegalChars) { <br/>System.out.println(&quot;输入的EMAIL地址里包含有冒号、逗号等非法字符，请修改&quot;); <br/>System.out.println(&quot;您现在的输入为: &quot;+args[0]); <br/>System.out.println(&quot;修改后合法的地址应类似: &quot;+input); <br/>} <br/>} <br/>} <br/>例如，我们在命令行输入：java Email www.kevin@163.net <br/>那么输出结果将会是：EMAIL地址不能以'www.'起始 <br/>如果输入的EMAIL为@kevin@163.net <br/>则输出为：EMAIL地址不能以'.'或'@'作为起始字符 <br/>当输入为：cgjmail#$%@163.net <br/>那么输出就是： <br/>输入的EMAIL地址里包含有冒号、逗号等非法字符，请修改 <br/>您现在的输入为: cgjmail#$%@163.net <br/>修改后合法的地址应类似: cgjmail@163.net </p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:1.5;font-size:14pt;"><strong>5.正则表达式规则：</strong></span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><span style="line-height:27px;font-size:19px;"><b><a href="http://edu.yesky.com/edupxpt/18/2143018.shtml" style="color:navy;text-decoration:none;">http://edu.yesky.com/edupxpt/18/2143018.shtml</a><br/></b></span></p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><strong>字符  </strong> <br/>x 字符 x <br/>\\ 反斜线字符 <br/>\0n 八进制值的字符0n (0 &lt;= n &lt;= 7) <br/>\0nn 八进制值的字符 0nn (0 &lt;= n &lt;= 7) <br/>\0mnn 八进制值的字符0mnn 0mnn (0 &lt;= m &lt;= 3, 0 &lt;= n &lt;= 7) <br/>\xhh 十六进制值的字符0xhh <br/>\uhhhh 十六进制值的字符0xhhhh <br/>\t 制表符('\u0009') <br/>\n 换行符 ('\u000A') <br/>\r 回车符 ('\u000D') <br/>\f 换页符 ('\u000C') <br/>\a 响铃符 ('\u0007') <br/>\e 转义符 ('\u001B') <br/>\cx T对应于x的控制字符 x <br/>  <br/><strong>字符类 </strong><br/>[abc] a, b, or c (简单类) <br/>[^abc] 除了a、b或c之外的任意 字符（求反） <br/>[a-zA-Z] a到z或A到Z ，包含（范围) <br/>[a-z-[bc]] a到z，除了b和c ： [ad-z]（减去） <br/>[a-z-[m-p]] a到z，除了m到 p： [a-lq-z] <br/>[a-z-[^def]] d, e, 或 f <br/>备注：<br/>方括号的正则表达式“t[aeio]n”只匹配“tan”、“Ten”、“tin”和“ton”，只能匹配单个字符。<br/>圆括号，因为方括号只允许匹配单个字符；故匹配多个字符时使用圆括号“()”。比如使用“t(a|e|i|o|oo)n”正则表达式，就必须用圆括号。</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><strong>预定义的字符类 </strong><br/>. 任意字符（也许能与行终止符匹配，也许不能） 备注：句点符号代表任意一个字符。比如：表达式就是“t.n”，它匹配“tan”、“ten”、“tin”和“ton”，还匹配“t#n”、“tpn”甚至“t n”。<br/>\d 数字: [0-9] <br/>\D 非数字: [^0-9] <br/>\s 空格符: [ \t\n\x0B\f\r] <br/>\S 非空格符: [^\s] <br/>\w 单词字符: [a-zA-Z_0-9] <br/>\W 非单词字符: [^\w]</p>
<p style="font-size:13px;line-height:1.5;margin:10px auto;text-indent:0px;"><strong>表达次数的符号</strong><br/>符号 次数<br/>* 0次或者多次<br/>+ 1次或者多次<br/>? 0次或者1次<br/>{n} 恰好n次<br/>{n,m} 从n次到m次</p></div></div></div></div></div></div></div></div><br/></span>
</div></body></html> 