<html>
<head>
  <title>5个用/不用GraphQL的理由</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601935 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="12732"/>
<h1>5个用/不用GraphQL的理由</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/8/26 13:59</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="https://www.jianshu.com/p/12dff5905cf6"><i>https://www.jianshu.com/p/12dff5905cf6</i></a></td></tr>
</table>
</div>
<br/>

<div><span><div style="-evernote-webclip:true"><br/><div style="font-size: 16px; display: inline-block;"><div style="font-family:sans-serif;text-size-adjust:100%;box-sizing:border-box;font-size:10px;-webkit-tap-highlight-color:transparent;"><div style="box-sizing:border-box;font-family:-apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;font-size:17px;line-height:1.42857;background-color:rgb(255, 255, 255);min-width:768px;color:rgb(51, 51, 51);"><div style="box-sizing:border-box;"><div style="box-sizing:border-box;"><div style="box-sizing:border-box;">
        <h1 style="font-size:34px;margin:20px 0px 0px;box-sizing:border-box;font-family:-apple-system, &quot;SF UI Display&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif;font-weight:700;line-height:1.3;color:inherit;word-break:break-word;margin-top:20px;margin-bottom:10px;">5个用/不用GraphQL的理由</h1>

        
        <div style="box-sizing:border-box;margin:30px 0px 40px;">
          <a href="https://www.jianshu.com/u/202618da286b" style="background-color:transparent;box-sizing:border-box;color:rgb(51, 51, 51);text-decoration:none;cursor:pointer;width:48px;height:48px;display:inline-block;vertical-align:middle;">
            <img src="5个用不用GraphQL的理由_files/96.jpg" type="image/jpeg" data-filename="96.jpg" alt="96" height="46" style="border:1px solid rgb(221, 221, 221);box-sizing:border-box;vertical-align:middle;width:100%;height:100%;border-radius:50%;" width="46"/>
</a>          <div style="box-sizing:border-box;vertical-align:middle;display:inline-block;margin-left:8px;">
            <span style="box-sizing:border-box;margin-right:3px;font-size:16px;vertical-align:middle;"><a href="https://www.jianshu.com/u/202618da286b" style="background-color:transparent;box-sizing:border-box;color:rgb(51, 51, 51);text-decoration:none;cursor:pointer;">freenik</a></span>
            
            <a style="background-color:rgb(66, 192, 46);box-sizing:border-box;color:rgb(255, 255, 255);text-decoration:none;display:inline-block;margin-bottom:0px;font-weight:400;text-align:center;vertical-align:middle;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;padding:0px 7px 0px 5px;font-size:12px;line-height:normal;border-radius:40px;user-select:none;border-color:rgb(66, 192, 46);"><i style="box-sizing:border-box;font-size:inherit;font-style:normal;-webkit-font-smoothing:antialiased;font-family:iconfont;font-weight:400;"><span style="font-size:inherit;font-style:normal;font-family:iconfont;font-weight:400;"></span></i><span style="box-sizing:border-box;margin-left:2px;display:inline;">关注</span></a>
            
            <div style="box-sizing:border-box;margin-top:5px;font-size:12px;color:rgb(150, 150, 150);">
              
                <span style="box-sizing:border-box;color:rgb(234, 111, 90);padding-right:5px;">
                  <i style="box-sizing:border-box;font-size:inherit;font-style:normal;-webkit-font-smoothing:antialiased;font-family:iconfont;font-weight:400;"><span style="font-size:inherit;font-style:normal;font-family:iconfont;font-weight:400;"></span></i> 2.9
                </span>
              
                <span style="box-sizing:border-box;padding-right:5px;">2018.09.28 13:49</span>
              <span style="box-sizing:border-box;padding-right:5px;">字数 4022</span>
            <span style="box-sizing:border-box;padding-right:5px;">阅读 28325</span><span style="box-sizing:border-box;padding-right:5px;">评论 8</span><span style="box-sizing:border-box;padding-right:5px;">喜欢 26</span></div>
          </div>
          
        </div>


        
        <div style="box-sizing:border-box;color:rgb(47, 47, 47);font-size:16px;font-weight:400;line-height:1.7;word-break:break-word;">
          <div style="box-sizing:border-box;">
            <p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">我在<a href="https://www.jianshu.com/p/4f33f36bb034" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">如何使用Gatsby建立博客 / How to build a blog with Gatsby</a>这篇文章中提过GraphQL在Gatsby中的应用。总的来讲，它是一个新潮的技术，在适宜的使用场景威力无穷。这里我们来讨论一下用/不用GraphQL的理由吧。</p>
<h1 style="font-size:26px;margin:0px 0px 15px;box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">简单介绍GraphQL</h1>
<div style="box-sizing:border-box;padding-bottom:25px;width:700px;margin-left:-40px;text-align:center;">
<div style="box-sizing:border-box;z-index:100;position:relative;background-color:transparent;transition:background-color 0.1s linear 0s;margin:0px auto;max-width:300px;max-height:315px;">
<div style="box-sizing:border-box;z-index:50;padding-bottom:105.0%;"></div>
<div style="box-sizing:border-box;position:absolute;top:0px;left:0px;width:100%;height:100%;overflow:hidden;"><img src="5个用不用GraphQL的理由_files/webp.webp" type="image/webp" data-filename="webp.webp" height="315" style="border:0px;box-sizing:border-box;vertical-align:middle;max-width:100%;display:block;transition:all 0.15s linear 0s;z-index:100;filter:blur(0px);opacity:1;height:auto;cursor:zoom-in;" width="300"/></div>
</div>
<div style="box-sizing:border-box;min-width:20%;max-width:80%;min-height:22px;display:inline-block;padding:10px;margin:0px auto;border-bottom:1px solid rgb(217, 217, 217);font-size:14px;color:rgb(150, 150, 150);line-height:1.7;">GrahQL</div>
</div>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">GraphQL是Facebook2015年开源的数据查询规范。现今的绝大多数Web Service都是RESTful的，也就是说，client和server的主要沟通模式还是靠client根据自己的需要向server的若干个endpoint (url)发起请求。由于功能的日渐丰富，对Web Application的要求变得复杂，REST的一些问题逐渐暴露，人们开始思考如何应对这些问题。GraphQL便是具有代表性的一种。GraphQL这个名字，Graph + Query Language，就表明了它的设计初衷是想要用类似图的方式表示数据：即不像在REST中，数据被各个API endpoint所分割，而是有关联和层次结构的被组织在一起。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">比方说，假设这么一个提供user信息的REST API: &lt;server&gt;/users/&lt;id&gt;，和提供用户的关注者的API：&lt;server&gt;/users/&lt;id&gt;/followers，以及该用户关注对象的API: &lt;server&gt;/users/&lt;id&gt;/followed-users。传统的REST会需要3次API call才能请求出这三份信息（假设&lt;server&gt;/users/&lt;id&gt; 没有包含followers and followed-users信息，which will be a definite redundancy if it does）:<br style="box-sizing:border-box;"/>
1 GET &lt;server&gt;/users/&lt;id&gt;</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;">{
 <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;user&quot;</span>: {
    <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;id&quot;</span> : <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;u3k2k3k178&quot;</span>,
    <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span> : <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;graph_ql_activist&quot;</span>,
    <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;email&quot;</span> : <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;graph_ql@activist.com&quot;</span>,
    <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;avatar&quot;</span> : <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;img-url&quot;</span>
  }
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">2 GET &lt;server&gt;/users/&lt;id&gt;/followed-users<br style="box-sizing:border-box;"/>
3 GET &lt;server&gt;/users/&lt;id&gt;/followers</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">然而如果使用GraphQL，一次API请求即可获取所有信息并且只选取需要的信息（比如关于用户只需要name不要email, followers只要最前面的5个name，followed-users只要头像等等）:</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;">query {
  user (id : <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;u3k2k3k178&quot;</span>) {
    <span style="box-sizing:border-box;">name
    <span style="box-sizing:border-box;color:rgb(97, 174, 238);">followers</span> <span style="box-sizing:border-box;">(first: <span style="box-sizing:border-box;color:rgb(209, 154, 102);">5</span>)</span> </span>{
      name
    }
    followed-users {
      avatar
    }
  }
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">我们会得到一个完全按照query定制的，不多不少的返回结果（一般是一个json对象）。</p>
<h1 style="font-size:26px;margin:0px 0px 15px;box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">5个使用GraphQL的理由</h1>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">使用GraphQL的理由， 必然是从讨论RESTful Service的局限性和问题开始。</p>
<ol style="box-sizing:border-box;word-break:break-word;padding:0px;margin:-5px 0px 20px 20px;margin-top:0px;margin-bottom:10px;">
<li style="box-sizing:border-box;line-height:30px;">数据冗余和请求冗余 (overfetching &amp; underfetching)</li>
<li style="box-sizing:border-box;line-height:30px;">灵活而强类型的schema</li>
<li style="box-sizing:border-box;line-height:30px;">接口校验 (validation)</li>
<li style="box-sizing:border-box;line-height:30px;">接口变动，维护与文档</li>
<li style="box-sizing:border-box;line-height:30px;">开发效率</li>
</ol>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">1 数据冗余和请求冗余 (overfetching &amp; underfetching)</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">根据users API的例子，我们可以想见，GET用户信息的REST call，我们就算只是想要一个用户的一两条信息(比如name &amp; avatar)，通过该API，我们也会得到他的整个信息。所谓的<em style="box-sizing:border-box;">overfetching</em>就是指的这种情况——请求包含当前不需要的信息。这种浪费会一定程度地整体影响performance，毕竟更多的信息会占用带宽和占用资源来处理。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">同样从上面的例子我们可以看出来，在许多情况下，如果我们使用RESTful Application，我们常常会需要为联系紧密并总量不大的信息，对server进行多次请求，call复数个API。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">举一个例子，获取ID为&quot;abc1&quot;和&quot;abc2&quot;的两个用户的信息，我们可能都需要两个API call，一百个用户就是一百个GET call，这是不是很莫名其妙呢？这种情况其实就是<code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:rgb(199, 37, 78);background-color:rgb(246, 246, 246);border-radius:4px;padding:2px 4px;border:none;white-space:pre-wrap;vertical-align:middle;">underfetching</code>——API的response没有合理的包含足够信息。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">然而在GraphQL，我们只需要非常简单地改变schema的处理方式，就可以用一个GET call解决：</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;">query {
  user (ids : [<span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;ab1&quot;</span>, <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;abc2&quot;</span>, ...])
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">我们新打开一个网页，如果是RESTful Application，可能请求数据就会马上有成百上千的HTTP Request，然而GraphQL的Application则可能只需要一两个，这相当于把复杂性和heavy lifting交给了server端和cache层，而不是资源有限，并且speed-sensitive的client端。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">2 灵活而强类型的schema</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">GraphQL是强类型的。也就是说，我们在定义schema时，类似于使用SQL，是显式地为每一个域定义类型的，比如说：</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;"><span style="box-sizing:border-box;color:rgb(230, 192, 123);">type</span> User {
  id: ID!
  name: String!
  joinedAt: DateTime!
  profileViews: Int! @default(value: 0)
}

<span style="box-sizing:border-box;color:rgb(230, 192, 123);">type</span> Query {
  user(id: ID!): User
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">GraphQL的schema的写作语言，其实还有一个专门的名称——<a href="https://blog.graph.cool/graphql-sdl-schema-definition-language-6755bcb9ce51" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">Schema Definition Language</a> (SDL)。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">这件事情的一大好处是，在编译或者说build这个Application时，我们就可以检查并应对很多mis-typed的问题，而不需要等到runtime。同时，这样的写作方式，也为开发者提供了巨大的便利。比如说使用YAML来定义API时，编写本身就是十分麻烦的——可能没有理想的auto-complete，语法或者语义有错无法及时发现，文档也需要自己小心翼翼地编写。就算有许多工具(比如<a href="https://swagger.io/" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">Swagger</a>)帮助，这仍然是一个很令人头疼的问题。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">3 接口校验 (validation)</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">显而易见，由于强类型的使用，我们对收到的数据进行检验的操作变得更为容易和严格，自动化的简便度和有效性也大大提高。对query本身的结构的校验也相当于是在schema完成后就自动得到了，所以我们甚至不需要再引入任何别的工具或者依赖，就可以很方便地解决所有的validation。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">4 接口变动，维护与文档</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">RESTful Application里面，一旦要改动API，不管是增删值域，改变值域范围，还是增减API数量，改变API url，都很容易变成伤筋动骨的行为。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">如果说改动API url(比如/posts --&gt; /articles)，我们思考一下那些地方可能要改动呢？首先client端的代码定然要改变request的API endpoint；中间的caching service可能也需要改要访问的endpoint；如果有load balancer, reverse proxy，那也可能需要变动；server端自己当然也是需要做相应改变的，这根据application自己的编写情况而定。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">相比之下，GraphQL就轻松多了。GraphQL的Service，API endpoint很可能就只有一个，根本不太会有改动URL path的情况。至始至终，数据的请求方都只需要说明自己需要什么内容，而不需要关心后端的任何表述和实现。数据提供方，比如server，只要提供的数据是请求方的母集，不论它们各自怎么变，都不需要因为对方牵一发而动全身。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">在现有工具下，REST API的文档没有到过分难以编写和维护的程度，不过跟可以完全auto-generate并且可读性可以很好地保障的GraphQL比起来，还是略显逊色——毕竟GraphQL甚至不需要我们费力地引入多少其他的工具。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">再一点，我们都知道REST API有一个versioning: V1, V2, etc.这件事非常的鸡肋而且非常麻烦，有时候还要考虑backward compatibility。GraphQL从本质上不存在这一点，大大减少了冗余。增加数据的fields和types甚至不需要数据请求方做任何改动，只需要按需添加相应queries即可。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">另外，有了GraphQL的queries，我们可以非常精准地进行数据分析(Analytics)。比如说具体哪些queries下的fields / objects在哪些情况下是被请求的最多/最频繁的——而不像RESTful Application中，如果不进行复杂的Analytics，我们只能知道每个API被请求的情况，而不是具体到它们内含的数据。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">5 开发效率</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">相信上面说的这些点已经充分能够说明GraphQL对于开发效率能够得到怎样的提升了。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">再补充几点。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">GraphQL有一个非常好的ecosystem。由于它方便开发者上手和使用--&gt;大家争相为它提供各种工具和支持--&gt;GraphQL变得更好用--&gt;社区文化和支持更盛--&gt;... 如同其他好的开源项目一样，GraphQL有着一个非常好的循环正向反馈。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">对于一套REST API，哪怕只是其使用者(consumer)，新接触的开发者需要一定时间去熟悉它的大致逻辑，要求乃至实现。然而GraphQL使用者甚至不需要去看类似API文档的东西，因为我们可以直接通过query查询query里面所有层级的type的所有域和它们各自的type，这不得不说很方便：</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;">{
  __schema {
    types {
      name
    }
  }
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">==&gt; 我们可以看到query所涉及的所有内容的类型：</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;">{
  <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;data&quot;</span>: {
    <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;__schema&quot;</span>: {
      <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;types&quot;</span>: [
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;Query&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;Episode&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;Character&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;ID&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;String&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;Int&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;FriendsConnection&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;FriendsEdge&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;PageInfo&quot;</span>
        }
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;__Schema&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;__Type&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;__TypeKind&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;__Field&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;__InputValue&quot;</span>
        },
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;name&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;__EnumValue&quot;</span>
        }
        }
      ]
    }
  }
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">对于GraphQL，我还有个非常个人的理由偏爱它：对于API的测试，相比于比较传统的Postman或者自己写脚本进行最基本的http call（或者curl），我更喜欢使用<a href="https://insomnia.rest/" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">insomnia</a>这个更为优雅的工具。而在此之上，它还非常好地<a href="https://insomnia.rest/blog/introducing-graphql/" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">支持了GraphQL</a>，这让我的开发和测试体验变得更好了。（Postman至今还不支持GraphQL，虽然本质上我们可以用它make GraphQL query call）</p>
<h1 style="font-size:26px;margin:0px 0px 15px;box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">5个不用GraphQL的理由</h1>
<ol style="box-sizing:border-box;word-break:break-word;padding:0px;margin:-5px 0px 20px 20px;margin-top:0px;margin-bottom:10px;">
<li style="box-sizing:border-box;line-height:30px;">迁移成本</li>
<li style="box-sizing:border-box;line-height:30px;">牺牲Performance</li>
<li style="box-sizing:border-box;line-height:30px;">缺乏动态类型</li>
<li style="box-sizing:border-box;line-height:30px;">简单问题复杂化</li>
<li style="box-sizing:border-box;line-height:30px;">缓存能解决很多问题</li>
</ol>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">1 使用与迁移成本</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">现有的RESTful Application如果要改造成GraphQL Application？</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">hmmm...</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">我们需要三思。首先我就不说RESTful本来从end to end都有成熟高效解决方案这样的废话了。迁移的主要问题在于，它从根本上改变了我们组织并暴露数据的方式，也就是说对于application本身，从数据层到业务逻辑层，可能有极其巨大的影响。所以它非常不适合现有的复杂系统“先破后立”。一个跑着SpringMVC的庞大Web Application如果要改成时髦的GraphQL应用？这个成本和破坏性难以预计。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">并且，尽管我们说GraphQL有着很好的社区支持，但本质上使用GraphQL，就等于要使用React与NodeJS。所以如果并不是正在使用或者计划使用React和Node，GraphQL是不适合的。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">2 牺牲Performance</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">Performance这件事是无数人所抱怨的。如同我们前面所说的，GraphQL的解决方案，相当于把复杂性和heavy lifting从用户的眼前，移到了后端——很多时候，就是数据库。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">要讨论这一点，我们首先要提的是，为了支持GraphQL queries对于数据的查询，开发者需要编写resolvers。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">比如说这样一个schema:</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;"><span style="box-sizing:border-box;color:rgb(230, 192, 123);">type</span> Query {
  human(id: ID!): Human
}

<span style="box-sizing:border-box;color:rgb(230, 192, 123);">type</span> Human {
  name: String
  appearsIn: [Episode]
  starships: [Starship]
}

enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}

<span style="box-sizing:border-box;color:rgb(230, 192, 123);">type</span> Starship {
  name: String
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">对于human，我们就需要一个最基础的resolver:</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;">Query: {
  human(obj, args, context, info) {
    <span style="box-sizing:border-box;color:rgb(198, 120, 221);">return</span> context.db.loadHumanByID(args.id).then(
      <span style="box-sizing:border-box;"><span style="box-sizing:border-box;">userData</span> =&gt;</span> <span style="box-sizing:border-box;color:rgb(198, 120, 221);">new</span> Human(userData)
    )
  }
}
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">当然这还没完，对不同的请求类型，我们要写不同的resolver——不仅原来REST API的CRUD我们都要照顾到，可能还要根据业务需求写更多的resolver。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">这件事情造成的影响，除了开发者要写大量boilerplate code以外，还可能导致查询性能低下。一个RESTful Application，由于每个API的确定性，我们可以针对每一个API的逻辑，非常好的优化它们的性能，所以就算存在一定程度的overfetching/underfetching，前后端的性能都可以保持在能够接受的范围内。然而想要更普适性一些的GraphQL，则可能会因为一个层级结构复杂而且许多域都有很大数据量的query跑许多个resolvers，使得数据库的查询性能成为了瓶颈。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">3 缺乏动态类型</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">强类型的schema固然很省力，但是如果我们有时候想要一些自由(flexibility)呢？</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">比方说，有时候请求数据时，请求方并不打算定义好需要的所有层级结构和类型与域。比方说，我们想要单纯地打印一些数据，或者获取一个user的一部分fields直接使用，剩下部分保存起来之后可能使用可能不使用，但并不确定也不关心剩下的部分具体有那些fields——多余的部分可能作为additional info，有些域如果有则使用，没有则跳过。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">这只是一个例子，但是并不是一个钻牛角尖的例子——因为有时候我们所要的objects的properties本来就可能是dynamic的，我们甚至可能会通过它的properties/fields来判定它是一个怎样的object。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">我们要怎么处理这种问题呢？一种有些荒诞现实主义的做法是，往Type里加一个JSON string field，用来提供其相关的所有信息，这样就可以应对这种情况了。但是这是不是一个合理的做法呢？</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">4 简单问题复杂化</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">最显著的例子，就是error handling。REST API的情况下，我们不需要解析Response的内容，只需要看HTTP status code和message，就能知道请求是否成功，大概问题是什么，处理错误的程序也十分容易编写。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">然而GraphQL的情景下，hmmm...</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">只要Service本身还在正常运行，我们就会得到200的HTTP status，然后需要专门检查response的内容才知道是否有error：</p>
<pre style="overflow:auto;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;display:block;padding:15px;margin:0px 0px 10px;line-height:1.42857;word-break:break-word;overflow-wrap:normal;color:rgb(171, 178, 191);border:1px solid rgb(204, 204, 204);border-radius:4px;margin-bottom:20px;white-space:pre;overflow-x:auto;background:rgb(40, 44, 52);background-color:rgb(245, 245, 245);"><code style="font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;box-sizing:border-box;color:inherit;background-color:transparent;border-radius:0px;padding:0px;white-space:pre;border:none;vertical-align:middle;"> {
      <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;errors&quot;</span>: [
        {
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;message&quot;</span>: <span style="box-sizing:border-box;color:rgb(152, 195, 121);">&quot;Field \&quot;name\&quot; must not have a selection since type \&quot;String\&quot; has no subfields.&quot;</span>,
          <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;locations&quot;</span>: [
            {
              <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;line&quot;</span>: <span style="box-sizing:border-box;color:rgb(209, 154, 102);">31</span>,
              <span style="box-sizing:border-box;color:rgb(209, 154, 102);">&quot;column&quot;</span>: <span style="box-sizing:border-box;color:rgb(209, 154, 102);">101</span>
            }
          ]
        }
      ]
    }
</code></pre>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">Another layer of complexity.</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">同时，简单的Application，使用GraphQL其实是非常麻烦的——比如前面提到的resolvers，需要大量的boilerplate code。另外，还有各种各样的Types, Queries, Mutators, High-order components需要写。相比之下，反倒是REST API更好编写和维护。</p>
<h2 style="box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);font-size:24px;margin:0px 0px 15px;text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">5 缓存能解决很多问题</h2>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">编写过HTTP相关程序之后应该都知道，HTTP本身就是<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">涵盖caching的</a>，更不要提人们为了提高RESTful Application的performance而针对<a href="http://www.kennethlange.com/posts/Boost-Your-REST-API-with-HTTP-Caching.html" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">缓存</a>作出的种种努力。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">对于overfetching和请求次数冗余的问题，假设我们的整个application做了足够合理的设计，并且由于REST API的固定和单纯性，缓存已经能非常好地减少大量的traffic。</p>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">然而如果选择使用GraphQL，我们就没有了那么直白的caching解决方案。首先，只有一个API endpoint的情况下，每个query都可能不同，我们不可能非常轻松地对request分门别类做caching。当然并不是说真的没有现成的工具，比如说Appollo client就提供了<a href="https://www.apollographql.com/docs/react/advanced/caching.html" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">InMemoryCache</a>并且，不论有多少queries，总是有hot queries和cold ones，那么pattern总是有的。针对一些特定的query我们还可以定向地缓存，比如说<a href="https://github.com/apollographql/persistgraphql" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">PersistGraphQL</a>便是这样一个工具。然而这样做其实又是相当于从queries中提炼出类似于原来的REST API的部分了，并且又增加了一层complexity，不管是对于开发还是对于performance，这都可能有不容忽视的影响。</p>
<h1 style="font-size:26px;margin:0px 0px 15px;box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">总结</h1>
<p style="box-sizing:border-box;margin:0px 0px 25px;word-break:break-word;">GraphQL最大的优势，就是它能够大大提高开发者的效率，而且最大化地简化了前端的数据层的复杂性，并且使得前后端对数据的组织观点一致。只是使用时，需要考察scale, performance, tech stack, migration等等方面的要求，做合理的trade-off，否则它可能不仅没能提高开发者效率，反倒制造出更多的问题。</p>
<h1 style="font-size:26px;margin:0px 0px 15px;box-sizing:border-box;font-family:inherit;font-weight:700;line-height:1.7;color:rgb(47, 47, 47);text-rendering:optimizelegibility;margin-top:20px;margin-bottom:10px;">References</h1>
<ul style="box-sizing:border-box;word-break:break-word;padding:0px;margin:-5px 0px 20px 20px;margin-top:0px;margin-bottom:10px;padding-left:0px;">
<li style="box-sizing:border-box;line-height:30px;"><a href="https://graphql.org/learn/execution/" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">Execution</a></li>
<li style="box-sizing:border-box;line-height:30px;"><a href="https://graphql.org/learn/queries/#mutations" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">Mutations</a></li>
<li style="box-sizing:border-box;line-height:30px;"><a href="https://graphql.org/learn/" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">Introduction to GraphQL</a></li>
<li style="box-sizing:border-box;line-height:30px;"><a href="https://github.com/facebook/graphql/releases/tag/June2018" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">graphql/releases/tag/June2018</a></li>
<li style="box-sizing:border-box;line-height:30px;"><a href="https://graphql.org/blog/mocking-with-graphql/" rel="nofollow" style="background-color:transparent;box-sizing:border-box;color:rgb(49, 148, 208);text-decoration:none;cursor:pointer;" target="_blank">Mocking your server is easy with GraphQL</a></li>
</ul>

          </div>
        </div>
    </div></div></div></div></div></div><br/></div></span>
</div></body></html> 