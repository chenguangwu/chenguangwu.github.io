<html>
<head>
  <title>[高并发Java 九] 锁的优化和注意事项 - God is a Coder.. - 开源中国</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="11752"/>
<h1>[高并发Java 九] 锁的优化和注意事项 - God is a Coder.. - 开源中国</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/2/23 14:23</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="https://my.oschina.net/hosee/blog/615865"><i>https://my.oschina.net/hosee/blog/615865</i></a></td></tr>
</table>
</div>
<br/>

<div><span><div style="-evernote-webclip:true"><br/><div style="font-size: 16px; display: inline-block;"><div style="box-sizing:border-box;line-height:1.15;text-size-adjust:100%;-webkit-font-smoothing:antialiased;font-size:14px;"><div style="box-sizing:inherit;overflow-x:hidden;min-width:320px;background:rgb(84, 84, 84);font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;font-size:14px;line-height:1.4285em;color:rgba(0, 0, 0, 0.87);"><div style="box-sizing:inherit;backface-visibility:hidden;overflow:hidden;transition:transform 0.5s ease 0s, -webkit-transform 0.5s ease 0s;background:rgb(255, 255, 255);"><div style="box-sizing:inherit;background:rgb(249, 249, 249);"><div style="box-sizing:inherit;"><div style="box-sizing:inherit;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row wrap;-webkit-box-align:stretch;align-items:stretch;align-content:flex-start;background:rgb(249, 249, 249);"><div style="box-sizing:inherit;-webkit-box-orient:horizontal;-webkit-box-direction:normal;flex-flow:row wrap;-webkit-box-pack:inherit;justify-content:inherit;-webkit-box-align:stretch;align-items:stretch;"><div style="box-sizing:inherit;vertical-align:top;background:rgb(255, 255, 255);"><div style="box-sizing:inherit;"><div style="box-sizing:inherit;"><div style="box-sizing:inherit;word-break:break-word;overflow-wrap:break-word;font-size:16px;font-family:&quot;Pingfang SC&quot;, STHeiti, &quot;Lantinghei SC&quot;, &quot;Open Sans&quot;, Arial, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif;color:rgb(61, 70, 77);line-height:28px;"><span style="font-size:16px;font-family:&quot;Pingfang SC&quot;, STHeiti, &quot;Lantinghei SC&quot;, &quot;Open Sans&quot;, Arial, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif;color:rgb(61, 70, 77);line-height:28px;display:table;"></span>
                                                    <div style="box-sizing:inherit;overflow:hidden;">
                                                                </div>
                                                <span style="box-sizing:inherit;"></span>
<h2 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:22px;border:none;"> 1. 锁优化的思路和方法 </h2> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 在<a href="http://my.oschina.net/hosee/blog/597934" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 一] 前言</a>中有提到并发的级别。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 一旦用到锁，就说明这是阻塞式的，所以在并发度上一般来说都会比无锁的情况低一点。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 这里提到的锁优化，是指在阻塞式的情况下，如何让性能不要变得太差。但是再怎么优化，一般来说性能都会比无锁的情况差一点。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 这里要注意的是，在<a href="http://my.oschina.net/hosee/blog/607677" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 五] JDK并发包1</a>中提到的ReentrantLock中的tryLock，偏向于一种无锁的方式，因为在tryLock判断时，并不会把自己挂起。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 锁优化的思路和方法总结一下，有以下几种。 </p> 
<ul style="box-sizing:inherit;margin:0px;padding:0px 0px 0px 2.5em;list-style-type:disc;"> 
 <li style="box-sizing:inherit;"> 减少锁持有时间  </li> 
 <li style="box-sizing:inherit;margin-top:0.25em;"> 减小锁粒度 </li> 
 <li style="box-sizing:inherit;margin-top:0.25em;"> 锁分离  </li> 
 <li style="box-sizing:inherit;margin-top:0.25em;"> 锁粗化  </li> 
 <li style="box-sizing:inherit;margin-top:0.25em;"> 锁消除 </li> 
</ul> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 1.1 <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;">减少锁持有时间 </span> </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">syncMethod</span><span style="box-sizing:inherit;">()</span></span>{  
		othercode1();  
		mutextMethod();  
		othercode2(); 
	}</code></pre> 像上述代码这样，在进入方法前就要得到锁，其他线程就要在外面等待。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;">这里优化的一点在于，要减少其他线程等待的时间，所以，只用在有线程安全要求的程序上加锁</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">syncMethod</span><span style="box-sizing:inherit;">()</span></span>{  
		othercode1();  
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span>(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">this</span>)
		{
			mutextMethod();  
		}
		othercode2(); 
	}</code></pre> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 1.2 减小锁粒度 </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 最最典型的减小锁粒度的案例就是ConcurrentHashMap。这个在<a href="http://my.oschina.net/hosee/blog/607677" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 五] JDK并发包1</a>有提到。 </p> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 1.3 锁分离 </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看<a href="http://my.oschina.net/hosee/blog/607677" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 五] JDK并发包1</a><span style="box-sizing:inherit;"></span>。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 读写分离思想可以延伸，只要操作互不影响，锁就可以分离。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 比如LinkedBlockingQueue   </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <img src="[高并发Java 九] 锁的优化和注意事项 - God is a Coder.. - 开源_files/123140_PhBr_2243330.png" type="image/png" data-filename="123140_PhBr_2243330.png" alt="" height="166" style="box-sizing:border-box;margin:auto;max-width:80%;border:0px;vertical-align:middle;height:auto;cursor:zoom-in;" width="602"/> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 从头部取出，从尾部放数据。当然也类似于<a href="http://my.oschina.net/hosee/blog/614319" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 六] JDK并发包2</a>中提到的ForkJoinPool中的工作窃取。 </p> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 1.4 锁粗化 </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 举个例子： </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">demoMethod</span><span style="box-sizing:inherit;">()</span></span>{  
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span>(lock){   
			<span style="box-sizing:inherit;color:rgb(106, 115, 125);">//do sth.  </span>
		}  
		<span style="box-sizing:inherit;color:rgb(106, 115, 125);">//做其他不需要的同步的工作，但能很快执行完毕  </span>
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span>(lock){   
			<span style="box-sizing:inherit;color:rgb(106, 115, 125);">//do sth.  </span>
		} 
	}</code></pre> 这种情况，根据锁粗化的思想，应该合并 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">demoMethod</span><span style="box-sizing:inherit;">()</span></span>{  
		<span style="box-sizing:inherit;color:rgb(106, 115, 125);">//整合成一次锁请求 </span>
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span>(lock){   
			<span style="box-sizing:inherit;color:rgb(106, 115, 125);">//do sth.   </span>
			<span style="box-sizing:inherit;color:rgb(106, 115, 125);">//做其他不需要的同步的工作，但能很快执行完毕  </span>
		}
	}</code></pre> 当然这是有前提的，前提就是中间的那些不需要同步的工作是很快执行完成的。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 再举一个极端的例子： </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">for</span>(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i=<span style="box-sizing:inherit;">0</span>;i&lt;CIRCLE;i++){  
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span>(lock){  
				
			} 
		}</code></pre> 在一个循环内不同得获得锁。虽然JDK内部会对这个代码做些优化，但是还不如直接写成 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span>(lock){ 
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">for</span>(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i=<span style="box-sizing:inherit;">0</span>;i&lt;CIRCLE;i++){ 
				
			} 
		}</code></pre> 当然如果有需求说，这样的循环太久，需要给其他线程不要等待太久，那只能写成上面那种。如果没有这样类似的需求，还是直接写成下面那种比较好。 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 1.5 锁消除 </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 锁消除是在编译器级别的事情。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 也许你会觉得奇怪，既然有些对象不可能被多线程访问，那为什么要加锁呢？写代码时直接不加锁不就好了。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 但是有时，这些锁并不是程序员所写的，有的是JDK实现中就有锁的，比如Vector和StringBuffer这样的类，它们中的很多方法都是有锁的。当我们在一些不会有线程安全的情况下使用这些类的方法时，达到某些条件时，编译器会将锁消除来提高性能。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 比如： </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">main</span><span style="box-sizing:inherit;">(String args[])</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">throws</span> InterruptedException </span>{
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">long</span> start = System.currentTimeMillis();
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">for</span> (<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i = <span style="box-sizing:inherit;">0</span>; i &lt; <span style="box-sizing:inherit;">2000000</span>; i++) {
			createStringBuffer(<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;JVM&quot;</span>, <span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;Diagnosis&quot;</span>);
		}
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">long</span> bufferCost = System.currentTimeMillis() - start;
		System.out.println(<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;craeteStringBuffer: &quot;</span> + bufferCost + <span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot; ms&quot;</span>);
	}

	<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> String <span style="box-sizing:inherit;color:rgb(111, 66, 193);">createStringBuffer</span><span style="box-sizing:inherit;">(String s1, String s2)</span> </span>{
		StringBuffer sb = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> StringBuffer();
		sb.append(s1);
		sb.append(s2);
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">return</span> sb.toString();
	}</code></pre> 上述代码中的StringBuffer.append是一个同步操作，但是StringBuffer却是一个局部变量，并且方法也并没有把StringBuffer返回，所以不可能会有多线程去访问它。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;">那么此时StringBuffer中的同步操作就是没有意义的。</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;">开启锁消除是在JVM参数上设置的，当然需要在server模式下：</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">-server</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:+DoEscapeAnalysis</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:+EliminateLocks</span></code></pre> 并且要开启逃逸分析。 逃逸分析的作用呢，就是看看变量是否有可能逃出作用域的范围。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 比如上述的<span style="box-sizing:inherit;">StringBuffer，上述代码中craeteStringBuffer的返回是一个String，所以这个局部变量<span style="box-sizing:inherit;">StringBuffer在其他地方都不会被使用。如果</span>将<span style="box-sizing:inherit;">craeteStringBuffer改成</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);">public <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> StringBuffer craeteStringBuffer(<span style="box-sizing:inherit;">String</span> s1, <span style="box-sizing:inherit;">String</span> s2) {
		StringBuffer sb = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> StringBuffer();
		sb.append(s1);
		sb.append(s2);
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">return</span> sb;
	}</code></pre> 那么这个 
<span style="box-sizing:inherit;">StringBuffer被返回后，是有可能被任何其他地方所使用的（譬如被主函数将返回结果put进map啊等等）。那么JVM的逃逸分析可以分析出，这个局部变量</span> 
<span style="box-sizing:inherit;">StringBuffer逃出了它的作用域。</span> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">所以基于逃逸分析，JVM可以判断，如果这个局部变量<span style="box-sizing:inherit;">StringBuffer并没有逃出它的作用域，那么可以确定这个<span style="box-sizing:inherit;">StringBuffer并不会被多线程所访问，那么就可以把这些多余的锁给去掉来提高性能。</span></span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">当JVM参数为：</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">-server</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:+DoEscapeAnalysis</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:+EliminateLocks</span></code></pre> 输出： 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(0, 92, 197);">craeteStringBuffer</span>: 302 ms</code></pre> JVM参数为： 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">-server</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:+DoEscapeAnalysis</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:-EliminateLocks</span></code></pre> 输出： 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(0, 92, 197);">craeteStringBuffer</span>: 660 ms</code></pre> 显然，锁消除的效果还是很明显的。 
<span style="box-sizing:inherit;"></span>
<h2 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:22px;border:none;"> <span style="box-sizing:inherit;">2. 虚拟机内的锁优化 </span> </h2> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 首先要介绍下对象头，在JVM中，每个对象都有一个对象头。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> Mark Word，对象头的标记，32位（32位系统）。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 描述对象的hash、锁信息，垃圾回收标记，年龄  </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 还会保存指向锁记录的指针，指向monitor的指针，偏向锁线程ID等。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 简单来说，对象头就是要保存一些系统性的信息。<span style="box-sizing:inherit;line-height:1.5;font-size:12.5px;"></span> </p> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> <span style="box-sizing:inherit;">2.1 偏向锁</span> </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;">所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程 。</span><br style="box-sizing:inherit;"/> </span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 大部分情况是没有竞争的（某个同步块大多数情况都不会出现多线程同时竞争锁），所以可以通过偏向来提高性能。即在无竞争时，之前获得锁的线程再次获得锁时，会判断是否偏向锁指向我，那么该线程将不用再次获得锁，直接就可以进入同步块。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 偏向锁的实施就是将对象头Mark的标记设置为偏向，并将线程ID写入对象头Mark  </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 当其他线程请求相同的锁时，偏向模式结束 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> JVM默认启用偏向锁 -XX:+UseBiasedLocking  </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 在竞争激烈的场合，偏向锁会增加系统负担（每次都要加一次是否偏向的判断）  </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 偏向锁的例子： </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">package</span> test;

<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.List;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.Vector;

<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">Test</span> </span>{
	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> List&lt;Integer&gt; numberList = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> Vector&lt;Integer&gt;();

	<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">main</span><span style="box-sizing:inherit;">(String[] args)</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">throws</span> InterruptedException </span>{
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">long</span> begin = System.currentTimeMillis();
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> count = <span style="box-sizing:inherit;">0</span>;
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> startnum = <span style="box-sizing:inherit;">0</span>;
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">while</span> (count &lt; <span style="box-sizing:inherit;">10000000</span>) {
			numberList.add(startnum);
			startnum += <span style="box-sizing:inherit;">2</span>;
			count++;
		}
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">long</span> end = System.currentTimeMillis();
		System.out.println(end - begin);
	}

}</code></pre> Vector是一个线程安全的类，内部使用了锁机制。每次add都会进行锁请求。上述代码只有main一个线程再反复add请求锁。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 使用如下的JVM参数来设置偏向锁： </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(189, 44, 0);background-color:rgb(255, 236, 236);">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span></code></pre> BiasedLockingStartupDelay表示系统启动几秒钟后启用偏向锁。默认为4秒，原因在于，系统刚启动时，一般数据竞争是比较激烈的，此时启用偏向锁会降低性能。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 由于这里为了测试偏向锁的性能，所以把延迟偏向锁的时间设置为0。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 此时输出为9209 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 下面关闭偏向锁： </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">-XX</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:-UseBiasedLocking</span></code></pre> 输出为9627 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 一般在无竞争时，启用偏向锁性能会提高5%左右。 </p> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 2.2 轻量级锁 </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> Java的多线程安全是基于Lock机制实现的，而Lock的性能往往不如人意。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 原因是，monitorenter与monitorexit这两个控制多线程同步的bytecode原语，是JVM依赖操作系统互斥(mutex)来实现的。<br style="box-sizing:inherit;"/> <br style="box-sizing:inherit;"/> 互斥是一种会导致线程挂起，并在较短的时间内又需要重新调度回原线程的，较为消耗资源的操作。<br style="box-sizing:inherit;"/> <br style="box-sizing:inherit;"/> 为了优化Java的Lock机制，从Java6开始引入了轻量级锁的概念。<br style="box-sizing:inherit;"/> <br style="box-sizing:inherit;"/> 轻量级锁（Lightweight Locking）本意是为了减少多线程进入互斥的几率，并不是要替代互斥。<br style="box-sizing:inherit;"/> <br style="box-sizing:inherit;"/> 它利用了CPU原语Compare-And-Swap(CAS，汇编指令CMPXCHG)，尝试在进入互斥前，进行补救。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 如果偏向锁失败，那么系统会进行轻量级锁的操作。它存在的目的是尽可能不用动用操作系统层面的互斥，因为那个性能会比较差。因为JVM本身就是一个应用，所以希望在应用层面上就解决线程同步问题。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 总结一下就是轻量级锁是一种快速的锁定方法，在进入互斥之前，使用CAS操作来尝试加锁，尽量不要用操作系统层面的互斥，提高了性能。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 那么当偏向锁失败时，轻量级锁的步骤： </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 1.将对象头的Mark指针保存到锁对象中（这里的对象指的就是锁住的对象，比如synchronized (this){}，this就是这里的对象）。 </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(106, 115, 125);">lock-&gt;</span><span style="box-sizing:inherit;">set_displaced_header(mark);</span></code></pre> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 2.将对象头设置为指向锁的指针（在线程栈空间中）。 </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">if</span> (mark == <span style="box-sizing:inherit;"><span style="box-sizing:inherit;">(markOop)</span> Atomic::cmpxchg_ptr<span style="box-sizing:inherit;">(lock, obj()-&gt;mark_addr(),mark)</span>) 
		 {       
			 TEVENT <span style="box-sizing:inherit;">(slow_enter: release stacklock)</span> ;       
			 return ; 
		 }</span></code></pre> lock位于线程栈中。所以判断一个线程是否持有这把锁，只要判断这个对象头指向的空间是否在这个线程栈的地址空间当中。 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 如果轻量级锁失败，表示存在竞争，升级为重量级锁（常规锁），就是操作系统层面的同步方法。在没有锁竞争的情况，轻量级锁减少传统锁使用OS互斥量产生的性能损耗。在竞争非常激烈时（轻量级锁总是失败），轻量级锁会多做很多额外操作，导致性能下降。 </p> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 2.3 自旋锁 </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 当竞争存在时，因为轻量级锁尝试失败，之后有可能会直接升级成重量级锁动用操作系统层面的互斥。也有可能再尝试一下自旋锁。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 如果线程可以很快获得锁，那么可以不在OS层挂起线程，让线程做几个空操作（自旋），并且不停地尝试拿到这个锁（类似tryLock），当然循环的次数是有限制的，当循环次数达到以后，仍然升级成重量级锁。所以在每个线程对于锁的持有时间很少时，自旋锁能够尽量避免线程在OS层被挂起。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> JDK1.6中-XX:+UseSpinning开启 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> JDK1.7中，去掉此参数，改为内置实现  </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 如果同步块很长，自旋失败，会降低系统性能。如果同步块很短，自旋成功，节省线程挂起切换时间，提升系统性能。 </p> 
<span style="box-sizing:inherit;"></span>
<h3 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:20px;border:none;"> 2.4 偏向锁，轻量级锁，自旋锁总结  </h3> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 上述的锁不是Java语言层面的锁优化方法，是内置在JVM当中的。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 首先偏向锁是为了避免某个线程反复获得/释放同一把锁时的性能消耗，如果仍然是同个线程去获得这个锁，尝试偏向锁时会直接进入同步块，不需要再次获得锁。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 而轻量级锁和自旋锁都是为了避免直接调用操作系统层面的互斥操作，因为挂起线程是一个很耗资源的操作。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 为了尽量避免使用重量级锁（操作系统层面的互斥），首先会尝试轻量级锁，轻量级锁会尝试使用CAS操作来获得锁，如果轻量级锁获得失败，说明存在竞争。但是也许很快就能获得锁，就会尝试自旋锁，将线程做几个空循环，每次循环时都不断尝试获得锁。如果自旋锁也失败，那么只能升级成重量级锁。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 可见偏向锁，轻量级锁，自旋锁都是乐观锁。 </p> 
<span style="box-sizing:inherit;"></span>
<h2 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:22px;border:none;"> 3. 一个错误使用锁的案例  </h2> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">IntegerLock</span> </span>{
	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> Integer i = <span style="box-sizing:inherit;">0</span>;

	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">AddThread</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">extends</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">Thread</span> </span>{
		<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">run</span><span style="box-sizing:inherit;">()</span> </span>{
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">for</span> (<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> k = <span style="box-sizing:inherit;">0</span>; k &lt; <span style="box-sizing:inherit;">100000</span>; k++) {
				<span style="box-sizing:inherit;color:rgb(215, 58, 73);">synchronized</span> (i) {
					i++;
				}
			}
		}
	}

	<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">main</span><span style="box-sizing:inherit;">(String[] args)</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">throws</span> InterruptedException </span>{
		AddThread t1 = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> AddThread();
		AddThread t2 = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> AddThread();
		t1.start();
		t2.start();
		t1.join();
		t2.join();
		System.out.println(i);
	}
}</code></pre> 一个很初级的错误在于，在 
<a href="http://my.oschina.net/hosee/blog/614826" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 七] 并发设计模式</a>提到，Interger是final不变的，每次++后，会产生一个新的 
<span style="box-sizing:inherit;">Interger再赋给i，所以两个线程争夺的锁是不同的。所以并不是线程安全的。</span> 
<span style="box-sizing:inherit;"></span>
<h2 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:22px;border:none;"> 4. ThreadLocal及其源码分析  </h2> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 这里来提ThreadLocal可能有点不合适，但是ThreadLocal是可以把锁代替的方式。所以还是有必要提一下。 </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 基本的思想就是，在一个多线程当中需要把有数据冲突的数据加锁，使用<span style="box-sizing:inherit;">ThreadLocal的话，为每一个线程都提供一个对象实例。不同的线程只访问自己的对象，而不访问其他的对象。这样锁就没有必要存在了。</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">package</span> test;

<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.text.ParseException;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.text.SimpleDateFormat;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.Date;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.concurrent.ExecutorService;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.concurrent.Executors;

<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">Test</span> </span>{
	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">private</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">final</span> SimpleDateFormat sdf = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> SimpleDateFormat(
			<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);

	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">ParseDate</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">implements</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">Runnable</span> </span>{
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i = <span style="box-sizing:inherit;">0</span>;

		<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">ParseDate</span><span style="box-sizing:inherit;">(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i)</span> </span>{
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">this</span>.i = i;
		}

		<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">run</span><span style="box-sizing:inherit;">()</span> </span>{
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">try</span> {
				Date t = sdf.parse(<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;2016-02-16 17:00:&quot;</span> + i % <span style="box-sizing:inherit;">60</span>);
				System.out.println(i + <span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;:&quot;</span> + t);
			} <span style="box-sizing:inherit;color:rgb(215, 58, 73);">catch</span> (ParseException e) {
				e.printStackTrace();
			}
		}
	}

	<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">main</span><span style="box-sizing:inherit;">(String[] args)</span> </span>{
		ExecutorService es = Executors.newFixedThreadPool(<span style="box-sizing:inherit;">10</span>);
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">for</span> (<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i = <span style="box-sizing:inherit;">0</span>; i &lt; <span style="box-sizing:inherit;">1000</span>; i++) {
			es.execute(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> ParseDate(i));
		}
	}

}</code></pre> 由于SimpleDateFormat并不线程安全的，所以上述代码是错误的使用。最简单的方式就是，自己定义一个类去用synchronized包装（类似于Collections.synchronizedMap）。这样做在高并发时会有问题，对 
<span style="box-sizing:inherit;">synchronized的争用导致每一次只能进去一个线程，并发量很低。</span> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">这里使用<span style="box-sizing:inherit;">ThreadLocal去封装</span><span style="box-sizing:inherit;">SimpleDateFormat就解决了这个问题</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">package</span> test;

<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.text.ParseException;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.text.SimpleDateFormat;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.Date;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.concurrent.ExecutorService;
<span style="box-sizing:inherit;color:rgb(215, 58, 73);">import</span> java.util.concurrent.Executors;

<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">Test</span> </span>{
	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> ThreadLocal&lt;SimpleDateFormat&gt; tl = <span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> ThreadLocal&lt;SimpleDateFormat&gt;();

	<span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">class</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">ParseDate</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">implements</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">Runnable</span> </span>{
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i = <span style="box-sizing:inherit;">0</span>;

		<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">ParseDate</span><span style="box-sizing:inherit;">(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i)</span> </span>{
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">this</span>.i = i;
		}

		<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">run</span><span style="box-sizing:inherit;">()</span> </span>{
			<span style="box-sizing:inherit;color:rgb(215, 58, 73);">try</span> {
				<span style="box-sizing:inherit;color:rgb(215, 58, 73);">if</span> (tl.get() == <span style="box-sizing:inherit;color:rgb(215, 58, 73);">null</span>) {
					tl.set(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> SimpleDateFormat(<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));
				}
				Date t = tl.get().parse(<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;2016-02-16 17:00:&quot;</span> + i % <span style="box-sizing:inherit;">60</span>);
				System.out.println(i + <span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;:&quot;</span> + t);
			} <span style="box-sizing:inherit;color:rgb(215, 58, 73);">catch</span> (ParseException e) {
				e.printStackTrace();
			}
		}
	}

	<span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">static</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">main</span><span style="box-sizing:inherit;">(String[] args)</span> </span>{
		ExecutorService es = Executors.newFixedThreadPool(<span style="box-sizing:inherit;">10</span>);
		<span style="box-sizing:inherit;color:rgb(215, 58, 73);">for</span> (<span style="box-sizing:inherit;color:rgb(215, 58, 73);">int</span> i = <span style="box-sizing:inherit;">0</span>; i &lt; <span style="box-sizing:inherit;">1000</span>; i++) {
			es.execute(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> ParseDate(i));
		}
	}

}</code></pre> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">每个线程在运行时，会判断是否当前线程有SimpleDateFormat对象</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">if</span> (tl.<span style="box-sizing:inherit;color:rgb(215, 58, 73);">get</span>() == <span style="box-sizing:inherit;color:rgb(0, 92, 197);">null</span>)</code></pre> 如果没有的话，就new个 
<span style="box-sizing:inherit;">SimpleDateFormat与当前线程绑定</span> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);">tl.<span style="box-sizing:inherit;">set</span>(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">new</span> SimpleDateFormat(<span style="box-sizing:inherit;color:rgb(3, 47, 98);">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</code></pre> 然后用当前线程的 
<span style="box-sizing:inherit;">SimpleDateFormat</span>去解析 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">tl</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">.get</span>()<span style="box-sizing:inherit;color:rgb(111, 66, 193);">.parse</span>(&quot;2016<span style="box-sizing:inherit;color:rgb(215, 58, 73);">-02-16</span> 17<span style="box-sizing:inherit;color:rgb(111, 66, 193);">:00</span><span style="box-sizing:inherit;color:rgb(111, 66, 193);">:&quot;</span> + <span style="box-sizing:inherit;color:rgb(215, 58, 73);">i</span> % 60);</code></pre> 一开始的代码中，只有一个 
<span style="box-sizing:inherit;">SimpleDateFormat，使用了</span> 
<span style="box-sizing:inherit;">ThreadLocal，为每一个线程都new了一个</span> 
<span style="box-sizing:inherit;">SimpleDateFormat。</span> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;">需要注意的是，这里不要把公共的</span><span style="box-sizing:inherit;">一个</span><span style="box-sizing:inherit;">SimpleDateFormat设置给每一个</span><span style="box-sizing:inherit;">ThreadLocal，这样是没用的。</span>需要给每一个都new一个<span style="box-sizing:inherit;">SimpleDateFormat。</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">在hibernate中，对<span style="box-sizing:inherit;">ThreadLocal有典型的应用。</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">下面来看一下<span style="box-sizing:inherit;">ThreadLocal的源码实现</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">首先Thread类中有一个成员变量：</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);">ThreadLocal.ThreadLocalMap threadLocals = <span style="box-sizing:inherit;color:rgb(0, 92, 197);">null</span>;</code></pre> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">而这个Map就是<span style="box-sizing:inherit;">ThreadLocal的实现关键</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<pre style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:16px 0px 14px;padding:14px 15px 12px;border-radius:3px;border:none;display:block;line-height:1.6;background:rgb(246, 246, 246);word-break:initial;overflow-wrap:initial;white-space:pre;overflow:auto;"><code style="box-sizing:inherit;font-family:Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;font-size:13px;margin:0px;padding:0px;border-radius:3px;overflow:visible;display:block;line-height:1.6;background:rgb(246, 246, 246);color:rgb(51, 51, 51);"><span style="box-sizing:inherit;"><span style="box-sizing:inherit;color:rgb(215, 58, 73);">public</span> <span style="box-sizing:inherit;color:rgb(215, 58, 73);">void</span> <span style="box-sizing:inherit;color:rgb(111, 66, 193);">set</span>(<span style="box-sizing:inherit;">T <span style="box-sizing:inherit;color:rgb(215, 58, 73);">value</span></span>) </span>{
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        <span style="box-sizing:inherit;color:rgb(215, 58, 73);">if</span> (map != <span style="box-sizing:inherit;color:rgb(0, 92, 197);">null</span>)
            map.<span style="box-sizing:inherit;color:rgb(215, 58, 73);">set</span>(<span style="box-sizing:inherit;color:rgb(215, 58, 73);">this</span>, <span style="box-sizing:inherit;color:rgb(215, 58, 73);">value</span>);
        <span style="box-sizing:inherit;color:rgb(215, 58, 73);">else</span>
            createMap(t, <span style="box-sizing:inherit;color:rgb(215, 58, 73);">value</span>);
    }</code></pre> 根据 
<span style="box-sizing:inherit;">ThreadLocal可以set和get相对应的value。</span> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;">这里的ThreadLocalMap实现和HashMap差不多，但是在hash冲突的处理上有区别。</span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"><span style="box-sizing:inherit;">ThreadLocalMap中发生hash冲突时，不是像</span><span style="box-sizing:inherit;">HashMap这样用链表来解决冲突，而是是将索引++，放到下一个索引处来解决冲突。</span></span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"><br style="box-sizing:inherit;"/> </span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"><br style="box-sizing:inherit;"/> </span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <span style="box-sizing:inherit;"> </span> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> 系列： </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/597934" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank"></a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/597934" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank"></a><a href="http://my.oschina.net/hosee/blog/597934" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 一] 前言</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/599000" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 二] 多线程基础</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/599884" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 三] Java内存模型和线程安全</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/600994" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 四] 无锁</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/607677" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 五] JDK并发包1</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/614319" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;">[高并发Java 六] JDK并发包2</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/614826" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 七] 并发设计模式</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/615269" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 八] NIO和AIO</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/615865" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 九] 锁的优化和注意事项</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/615927" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank">[高并发Java 十] JDK8对并发的新支持</a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"></p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <a href="http://my.oschina.net/hosee/blog/615865" rel="nofollow" style="box-sizing:inherit;background-color:transparent;color:rgb(65, 131, 196);text-decoration:none;" target="_blank"></a> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <br style="box-sizing:inherit;"/> </p> 
<p style="box-sizing:inherit;margin:0px 0px 1em;line-height:28px;margin-top:16px;margin-bottom:14px;"> <br style="box-sizing:inherit;"/> </p> 
<span style="box-sizing:inherit;"></span>
<h2 style="box-sizing:inherit;font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, Arial, Helvetica, sans-serif;line-height:1.28571em;margin:1.2em 0px 0.8em;font-weight:500;padding:0px;font-size:22px;border:none;"> Reference： </h2> 1. http://blog.csdn.net/songylwq/article/details/5585734
                                                    <div style="box-sizing:inherit;overflow:hidden;margin-top:12px;">
                                                        <div style="box-sizing:inherit;">


<ins style="box-sizing:inherit;display:block;width:824px;height:90px;"><ins style="box-sizing:inherit;display:inline-table;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:824px;background-color:transparent;"><ins style="box-sizing:inherit;display:block;border:none;height:90px;margin:0;padding:0;position:relative;visibility:visible;width:824px;background-color:transparent;"><div style="box-sizing:inherit;left:0;position:absolute;top:0;border:0px;width:824px;height:90px;"></div></ins></ins></ins>

</div>


                                        </div>
                                            <span style="font-size:16px;font-family:&quot;Pingfang SC&quot;, STHeiti, &quot;Lantinghei SC&quot;, &quot;Open Sans&quot;, Arial, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, SimSun, sans-serif;color:rgb(61, 70, 77);line-height:28px;display:table;clear:both;"></span></div></div></div></div></div></div></div></div></div></div></div></div><br/></div></span>
</div></body></html> 